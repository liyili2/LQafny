\section{Background}
\label{sec:background}

Here, we provide background information for quantum computing, and the details of classical separation logic methodologies are in \Cref{sec:related}. 

\noindent\textbf{\textit{Quantum States and Alternative State Representations.}} A quantum state consists of one or more quantum bits (\emph{qubits}). A qubit can be expressed as a two dimensional vector $\begin{psmallmatrix} \alpha \\ \beta \end{psmallmatrix}$ where $\alpha,\beta$ are complex numbers such that $|\alpha|^2 + |\beta|^2 = 1$.  The $\alpha$ and $\beta$ are called \emph{amplitudes}. 
%
We frequently write the qubit vector as $\alpha\ket{0} + \beta\ket{1}$ where $\ket{0} = \begin{psmallmatrix} 1 \\ 0 \end{psmallmatrix}$ and $\ket{1} = \begin{psmallmatrix} 0 \\ 1 \end{psmallmatrix}$ are \emph{computational basis states}. When both $\alpha$ and $\beta$ are non-zero, we can think of the qubit as being ``both 0 and 1 at once,'' a.k.a. a \emph{superposition}. For example, $\frac{1}{\sqrt{2}}(\ket{0} + \ket{1})$ is an equal superposition of $\ket{0}$ and $\ket{1}$. 
We can join multiple qubits together to form a larger quantum state with the \emph{tensor product} ($\otimes$) from linear algebra. For example, the two-qubit state $\ket{0} \otimes \ket{1}$ (also written as $\ket{01}$) corresponds to vector $[~0~1~0~0~]^T$. 
Sometimes a multi-qubit state cannot be expressed as the tensor of individual states; such states are called \emph{entangled}. One example is the state $\frac{1}{\sqrt{2}}(\ket{00} + \ket{11})$, known as a \emph{Bell pair}.

$n$-qubit quantum states are typically represented as $2^n$ dimensional vectors. Alternatively, the states can be represented as different forms. For example, a newly generated qubit typically has a state $\ket{0}$ or $\ket{1}$, which is named \textit{normal typed state} ($\tnort$) in QNP. $n$ Qubits that are in superposition but not entangled, such as $\frac{1}{\sqrt{2}}(\ket{0} + \ket{1})\otimes ... \otimes \frac{1}{\sqrt{2}}(\ket{0} + \ket{1})$, can be expressed as a summation of tensor products as $\shad{2^n}{n}{\alpha(r_j)}$, where $\alpha(r_j)=e^{2\pi i r}$ and $r \in \mathbb{R}$, which is named \textit{Hadamard typed state} ($\thadt$) in QNP.
$\alpha(r_j)$ is named the \emph{local phase} of the state, which are special quantum amplitudes (see below) such that the norm is $1$, i.e., $\slen{\alpha(r_j)}=1$. In the above state, we can view the local phase $1$ as $e^{0}$, and $\frac{1}{\sqrt{2^n}}e^{0}$ is the amplitude for every basis state.

The most general representation is to express quantum states as a path-sum formula as: $\sch{m}{z_j}{c_j}$, where $z_j\in \mathbb{C}$ is an amplitude, $c_j$ is an $n$-length bitstring named \emph{basis}, and $m \le 2^n$. The path-sum formula is same as ${z_0}\ket{c_0}+...+{z_{m-1}}\ket{c_{m-1}}$, such that each $j$-th element ${z_j}\ket{c_j}$ represents a \emph{basis state} in the superposition state. 
This is named \textit{entanglement typed state} ($\tcht$) in QNP.
For example, the bell pair can be represented as $\sch{2}{\frac{1}{\sqrt{2}}}{c_j}$ with $c_0=00$ and $c_1=11$.
Notice that the the bitstrings ($c_j$) of basis states are all distinct in a state. 

%Notice that the amplitudes satisfy the relation $\sum_{0}^{m}\slen{z_j}^2 = 1$. However, in some intermediate program evaluation in QNP, we loose the restriction to be $\sum_{0}^{m}\slen{z_j}^2 \le 1$, because a state $\sch{m}{z_j}{c_j}$ can be split into two parts as $\sch{m}{z_j}{c_j}=\schii{m_1}{z_i}{c_i}+\schk{m_2}{z_k}{c_k}$, and we might only want to reason about a portion of the state $\schii{m_1}{z_i}{c_i}$ locally, so that $\sum_{0}^{m_1}\slen{z_i}^2 < 1$. 
QNP identifies these three different representations and use a type system to properly transform quantum state representations.
In QNP, each quantum state is associated with a \emph{session}, referring to a cluster of quantum array pieces possibly entangled with each other. We can view a session as a virtual quantum array that manages quantum physical qubit array pieces living in different locations but are locally connected through entanglement. See \Cref{sec:quantum-state}.

\ignore{
As a shortcut of basis state representations, we might write $\ket{c_1}\otimes \ket{c_2}=\ket{c_1}\ket{c_2}=\ket{c_1.c_2}$ where $c_1.c_2$ is the bitstring concatenation and $c_1$ and $c_2$ are bitstrings of some sizes that relate to session lengths.
\myparagraph{Sessions}
If we analogize a quantum state $\sch{m}{z_j}{c_j}$ as an $m$-length array and each basis state $z_j\ket{c_j}$ as the $j$-th element in the array. \Cref{fig:background-circuit-example-proof} line 1, we have a singleton array $x[0..n]$, each element of which is $n$-length.
In QNP, we named the name structure referring to an array representing a quantum state as a \emph{session}. Here $x[0..n]$ is a session indicating that the location of the array is in a region named $x$, and the range is from $0$ to $n$, which means that the length of each element is $n$. After the application of $\ssassign{x[0]}{}{\ihadh}$, we split the session into two parts: $x[0..1]$ and $x[1..n]$ having a $\thadt$ type ($\frac{1}{\sqrt{2}}(\ket{0}+\ket{1})$) and $\tnort$ ($\ket{\overline{0}}$) type states, respectively.
Here, the singleton element in $x[1..n]$ is now $n-1$ length.
State $\frac{1}{\sqrt{2}}(\ket{0}+\ket{1})$ can also be viewed as $\sch{2}{\frac{1}{\sqrt{2}}}{\overline{i}}$ with $i\in[0,1]$.
Here, $\overline{i}$ is a singleton bitstring. 
In each step of the loop in line 4-6, we cut off the $j$-th bit in the singleton element array, so the array session becomes $x[\snext{j}..n]$, then we put the bit in the original $x[0..1]$ session which is now structured as $x[0..j]$.
The state becomes $\sch{2}{\frac{1}{\sqrt{2}}}{\overline{i}}\ket{0}$. Notice that the quantum conditional in each loop step applies on the $j$-th and $(\snext{j})$-th bits of the two basis states ($\overline{0}$ and $\overline{1}$). When $i=0$, we do nothing; if $i=1$, we flip the bit, which means that we turn the state to be $\sch{2}{\frac{1}{\sqrt{2}}}{\overline{i}}$, with the $\overline{i}$ length increases by one and it is the same as the length the session $x[0..\snext{j}]$. In the end, we can remove the $x[n..n]\mapsto \ket{\overline{0}}$ in the final state, because session $x[n..n]$ means that each element in the state array is $0$, so we claim such session as empty. 
}

\noindent\textbf{\textit{Quantum Computations and Conditionals.}} High-level quantum programming languages are usually designed to follow the \emph{QRAM model}~\cite{Knill1996}, where quantum computers are used as co-processors to classical computers. The classical computer generates descriptions of circuits to send to the quantum computer and then processes the measurement results.
Computation on a quantum state consists of a series of \emph{quantum operations}, each of which acts on a subset of qubits in the quantum state. In the standard presentation, quantum computations are expressed as \emph{circuits}, as shown in \Cref{fig:background-circuit-examplea}, which constructs a circuit that prepares the Greenberger-Horne-Zeilinger (GHZ) state \cite{Greenberger1989}, which is an $n$-qubit entangled quantum state of the form: $\ket{\text{GHZ}^n} = \frac{1}{\sqrt{2}}(\ket{0}^{\otimes n}+\ket{1}^{\otimes n})$.

In these circuits, each horizontal wire represents a qubit and boxes on these wires indicate quantum operations, or \emph{gates}. The circuit in \Cref{fig:background-circuit-examplea} uses $n$ qubits and applies $n$ gates: a \emph{Hadamard} (\coqe{H}) gate and $n-1$ \emph{controlled-not} (\coqe{CNOT}) gates.
Applying a gate to a state \emph{evolves} the state. 
The \qafny implementation in \Cref{fig:background-circuit-example-proof} shows the evolving. In the $j$-th loop step, the quantum state of array $x[0..j]$ is $\frac{1}{\sqrt{2}}(\ket{\overline{0}}+\ket{\overline{1}})$ \footnote{$\ket{\overline{0}}$ and $\ket{\overline{1}}$ have the same length as $x[0..j]$}, and a qubit $\ket{0}$ is added to the state and transforms the state to $\frac{1}{\sqrt{2}}(\ket{\overline{0}}\ket{0}+\ket{\overline{1}}\ket{0})$, which adds a bit $0$ to the end of every basis state. Then, the quantum conditional 
($\sifq{x[j]}{\ssassign{x[\snext{j}]}{}{x[\snext{j}]+1}}$) turns $\ket{0}$ in the second basis state to $\ket{1}$ as $\frac{1}{\sqrt{2}}(\ket{\overline{0}}\ket{0}+\ket{\overline{1}}\ket{1})$, because the quantum conditional checks the $j$-th qubit in every basis state, if it is $1$, then the conditional body is applied; otherwise, it does nothing.

\noindent\textbf{\textit{Measurement.}} A special, non-unitary \emph{measurement} operation is used to extract classical information from a quantum state, typically when a computation completes. Measurement collapses the state to one of the basis states with a probability related to the state's amplitudes. For example, measuring $\frac{1}{\sqrt{2}}(\ket{0} + \ket{1})$ will collapse the state to $\ket{0}$ with probability $\frac{1}{2}$ and likewise for $\ket{1}$, returning classical values 0 or 1, respectively.

\noindent\textbf{\textit{Quantum Oracles.}} Quantum algorithms manipulate input information encoded in ``oracles,'' which are callable black box circuits. For example, Grover's algorithm for unstructured quantum search \cite{grover1996,grover1997} is a general approach for searching a quantum ``database,'' which is encoded in an oracle for a function $f : \{0, 1\}^n \to \{0, 1\}$. Grover's finds an element $x \in \{0, 1\}^n$ such that $f(x) = 1$ using $O(2^{n/2})$ queries, a quadratic speedup over the best possible classical algorithm, which requires $\Omega(2^n)$ queries. Oracles are typically viewed as quantum reversible implementations of classical operations, especially arithmetic operations. OQASM \cite{oracleoopsla} is a language that permits the effective testing of quantum oracles.









