\section{Evaluation and Case Studies}
\label{sec:arith-oqasm}

\begin{figure*}[t]
{\footnotesize
\begin{tabular}{|l|c|c|c|c|c|}
\hline
Algorithm & Run Time (sec) & QBricks Run Time (sec) & \# Lines& QBricks \# Lines  & Human Effort (days)\\
                     \hline
GHZ & 4.2 & - & 11 & - & < 1 \\
Controlled GHZ & 6.4 & - & 7 & - & < 1 \\
Deutschâ€“Jozsa & 3.3 & 79 & 8 & 57  & < 1 \\
Grover's search & 26.7 & 283 & 22 & 193 &  2\\
Shor's algorithm & 36.3 & 1380  & 31 & 1163 & 30  \\
Quantum Walk & 43.1 & - & 43 & - & 3 \\
\hline                           
\end{tabular}
}
\caption{Computer running time and program line numbers and human effort for verifying algorithms in \qafny. Verification running time (Run Time) is measured in a i7 windows computer. 
QBricks running time is based on \cite{qbricks}, and \texttt{-} means no data.
The human effort measures the time for a single person to finish programming and verifying an algorithm. The quantum walk algorithm is the core in \cite{Wong_2022}.}
\label{fig:circ-evaluation}
\end{figure*}

We evaluate QNP by (1) demonstrating how quantum algorithms are verified in the framework, and (2) showing that it saves the time for programmers to write and verify quantum programs, especially, it helps them to discover possible new ways of integrating quantum operations.
%
This section presents the facts about verifying quantum programs in \qafny. Then, we discuss two case studies, including the verification of the controlled GHZ and quantum walk algorithms, as demonstrations of verifying quantum algorithms in \qafny.

\Cref{fig:circ-evaluation} shows the algorithms being verified in \qafny. When we started the QNP project, we first tried to verify Shor's algorithm directly on Dafny, which spent a researcher 30 days to finish. After that, we built the \qafny compiler on Dafny, and run a \qafny version of the Shor's algorithm proof, which is much more cleaner than the code written directly in Dafny. The running time for that proof is 36.3 seconds. In fact, running any \qafny verification does not take more than a minute to finish, which is relatively comparable with most nowadays automated verification framework \cite{DBLP:conf/pldi/Qiu0SM13,dafnyref}, and better than the existing quantum automated frameworks, such as QBricks \cite{qbricks}, as indicated in \Cref{fig:circ-evaluation}.

Computer running time is usually a less important factor in verifying programs, while the human effort is more concerning. We believe that QNP saves a great amount of human resources. This fact is indicated by the number of lines in writing the algorithm specifications in \qafny. As shown in \Cref{fig:circ-evaluation}, all the algorithms are written with less than 43 lines of code.
In contrast, algorithm specifications and verification in other framework requires much more lines.
For example, the Grover's search specification in quantum Haore Logic \cite{qhoreusage} has 3184 lines of code, and the Shor's algorithm specification in QBricks \cite{qbricks} has 1163 lines of code in \Cref{fig:circ-evaluation} \footnote{We do not mean to compare the coding lines to other frameworks since the coding line numbers might be varied depending on many factors, but we only provide a hint on the automation in \qafny.}.
In terms of human effort, other than Shor's algorithm, which was done before the \qafny compiler was fully constructed, most algorithms were written and verified in \qafny (\Cref{fig:circ-evaluation}) in three days by a single researcher. 
As a comparison, the complete Shor's algorithm correctness proof \cite{shorsprove} was finished by four researchers that spent two years. Even the oracle in the Shor's algorithm, the modulo multiplication circuit, was verified by three researchers that spent four months. We believe that QNP relieves programmers' pain in reasoning about quantum programs.
Below, we show two examples of helping programmings to understand and integrate quantum algorithms by QNP.

\begin{figure}[t]
{\centering
{
\begin{tabular}{c c}
  \small
  \Qcircuit @C=0.5em @R=0.5em {
    \lstick{\ket{0}} & \gate{H} & \qw & \ctrl{1} & \qw & \qw  & \\
    \lstick{\ket{0}} & \qw & \qw & \multigate{3}{\texttt{GHZ}} & \qw &\qw &  \\
    & \vdots &   &  &  & & \\
    & \vdots &  & \dots & & &  \\
    \lstick{\ket{0}} & \qw & \qw & \ghost{\texttt{GHZ}} &\qw &\qw &
    }

&
{
$\small
\begin{array}{r l}
\textcolor{blue}{1}
&
\{x[0..1]\mapsto \ket{0},y[0..n]\mapsto \ket{\overline{0}}\}\\[0.2em]
\textcolor{blue}{2}
&
\ssassign{x[0]}{}{\ihadh};\\[0.2em]

\textcolor{blue}{3}
&
\textcolor{teal}{
\{x[0..1]\mapsto \frac{1}{\sqrt{2}}(\ket{0}+\ket{1}) * y[0..n]\mapsto \ket{\overline{0}}\}
}
\\[0.2em]

\textcolor{blue}{4}
&
\textcolor{teal}{
\Rightarrow
\{\{x[0..1],y[0..n]\}\mapsto \scha{2}{}{j}{\ket{\overline{0}}}\}
}
\\[0.2em]

\textcolor{blue}{5}
&
\sifq{x[0]}{\texttt{ghz}(y)};
\\[0.2em]

\textcolor{blue}{6}
&
\{\{x[0..1],y[0..n]\}\mapsto \frac{1}{\sqrt{2}}\ket{\overline{0}}+\frac{1}{2}\ket{1}\ket{\overline{0}}+\frac{1}{2}\ket{\overline{1}} \}
\end{array}
$
}
\end{tabular}
}
}
\vspace*{-0.5em}
\caption{Controlled GHZ circuit and proof. $\texttt{ghz}(y)$ is given in \Cref{fig:background-circuit-example}. Lines 3-4 are automatically inferred.}
\label{fig:background-circuit-example-controlled}
\end{figure}

\subsection{Controlled GHZ Case Study: Building Quantum Algorithms on Others}

One important criteria appearing in many automated verification frameworks is to reuse existing verification proofs to synthesize new algorithm verification. 
However, in most quantum proof systems nowadays, this criteria is neglected. For example, QBricks did not utilize the quantum phase estimation (QPE) proof, which is the core part of Shor's algorithm, to construct their Shor's algorithm proof.
In VOQC \cite{VOQC}, the QPE reuse in the Shor's proof was done by proving many new theorems that were not originally required in the QPE proofs. QNP opens a windows towards the reusable proofs for verifying new algorithms.
\Cref{fig:background-circuit-example-controlled} provides a proof of the Controlled GHZ algorithm based on the GHZ proof in \Cref{fig:background-circuit-example-proof}. The focal point is at \Cref{fig:background-circuit-example-controlled} line 5, where the GHZ function requires input to be a $\tnort$ state of all $0$ qubits, but the given state, in line 4, is an entanglement $\scha{2}{}{j}{\ket{\overline{0}}}$. In \qafny, we automatically verify the proof by rule \rulelab{PIF} and the equational relation to rewrite a singleton $\tcht$ state to a $\tnort$ state, as $\sch{1}{z_j}{c_j}\equiv z_0\ket{c_0}$. The detailed proofs for the conditional is given below, where $\kappa=\{x[0..1],y[0..n]\}$. 

\vspace*{-1em}
{\footnotesize
  \begin{mathpar}
\inferrule[]{
   \inferrule[]
   { 
  { \fivepule{\Omega}{\{y[0..n]:\tnort\}}{\mmode}
{\textcolor{teal}{
y[0..n]\mapsto {\ket{\overline{0}}}}
\textcolor{purple}{\ket{1}}
}{ \texttt{ghz}(y) }{
\textcolor{teal}{
y[0..n]\mapsto \schii{2}{\frac{1}{\sqrt{2}}}{\overline{i}}}
\textcolor{purple}{\ket{1}}
}
} }
   {
\fivepule{\Omega}{\{y[0..n]:\tcht\}}{\cmode}
{\textcolor{teal}{
\mathpzc{M}(x[0],y[0..n])\mapsto \scha{2}{}{j}{\ket{\overline{0}}}
}
}{ \texttt{ghz}(y) }{
\textcolor{teal}{
y[0..n]\mapsto \schii{2}{\frac{1}{\sqrt{2}}}{\overline{i}}}
\textcolor{purple}{\ket{1}}
}} } {
\inferrule[]
{\fivepule{\Omega}{\sigma}{\cmode}
{\textcolor{teal}{
\kappa\mapsto \scha{2}{}{j}{\ket{\overline{0}}}
}
}{ \sifq{x[0]}{\texttt{ghz}(y)} }{
\textcolor{teal}{
\mathpzc{U}(\neg x[0],\kappa)\mapsto \scha{2}{}{j}{\ket{\overline{0}}}
*
\mathpzc{U}(x[0],\kappa)\mapsto \schii{2}{\frac{1}{\sqrt{2}}}{\overline{i}}}
\textcolor{purple}{\ket{1}} }}
{\fivepule{\Omega}{\sigma}{\cmode}
{\textcolor{teal}{
\kappa\mapsto \scha{2}{}{j}{\ket{\overline{0}}}
}
}{ \sifq{x[0]}{\texttt{ghz}(y)} }{
\textcolor{teal}{
\kappa \mapsto \frac{1}{\sqrt{2}}\ket{\overline{0}}+\frac{1}{2}\ket{1}\ket{\overline{0}}+\frac{1}{2}\ket{\overline{1}}
} }}
}
  \end{mathpar}
}

Once rule \rulelab{PIF} is applied on the second and third line, session $y[0..n]$'s state is actually a $\tnort$ type state $\textcolor{teal}{\ket{\overline{0}}}\textcolor{purple}{\ket{1}}$, where $\overline{0}$ is $n$ qubits and $\ket{1}$ is frozen, which is marked purple. Now, the state satisfies the input state for GHZ above,
so that we can safely reuse the GHZ proof in \Cref{fig:background-circuit-example-proof} and finish the proof. 
The type of $y[0..n]:\tcht$ on the top of \Cref{fig:background-circuit-example-controlled} is turned to $\tnort$ by extra axioms defined in the \qafny to Dafny compiler to rewrite type predicates.
In \Cref{sec:newtype}, we implement a new type system that tracks both sessions and basis states, where the type rewrite can automatically happens without extra predicate axioms.

\begin{figure}[t]
{\centering
{\small
\[
\begin{array}{r l}
\textcolor{blue}{1}
&
\textcolor{teal}{
\{ x[0..t] \mapsto \shadi{2^t}{t}{} *
   y[0..m] \mapsto \ket{\overline{0}} *
   u[0..1] \mapsto \ket{0} *
   w[0..n] \mapsto \ket{\overline{0}} * m = 2^t \wedge m < n\}
}
\\[0.3em]
\textcolor{blue}{2}
&
\texttt{for}~{(\texttt{int}~j \in [0,m)~\&\&~x < \snext{j} \,@\, y[j])}
\\[0.3em]

\textcolor{blue}{3}
&
\;\;
\textcolor{purple}{\{ \{x[0..t],y[0..j],u[0..1],w[0..n]\} \mapsto q(j) \wedge \texttt{is\_steps}(j,q(j)) \}}
\\[0.3em]

\textcolor{blue}{4}
&
\{
\;\;\;
\ssassign{u}{}{\sdis};
\\[0.2em]

\textcolor{blue}{5}
&
\quad
\sifq{u[0]}{\texttt{left}(w)};
\\[0.2em]

\textcolor{blue}{6}
&
\quad
\sifq{\neg u[0]}{\texttt{right}(w)}; \;\}
\\[0.4em]

\textcolor{blue}{7}
&
\textcolor{teal}{
\{ \{x[0..n],y[0..m],u[0..1],w[0..n]\} \mapsto q(m) \wedge \texttt{is\_steps}(m,q(m)) \}
}
\end{array}
\]
}
{\footnotesize
$
\begin{array}{l}
\texttt{pat}(i,j) = \ket{0}^{\otimes \lfloor\log\;i \rfloor}\ket{1}^{\otimes (j\,\sminus\,\lfloor\log\;i \rfloor)}\\[0.1em]

q(j)=\schai{2^{(\snext{j})}\,\sminus\,2}{z_i}{\lfloor\log\;i \rfloor}{\ket{\texttt{pat}(i,j)}\ket{u_i}\ket{\texttt{key}(i)}} + \ssum{k=j}{2^t}{z_k\ket{k}\ket{\overline{0}}\ket{0}\ket{\overline{0}}}
\\[0.1em]
\texttt{is\_steps}(j,q(j))=
\forall i.\, \ket{\lfloor\log\;i \rfloor}\ket{\texttt{pat}(i,j)}\ket{u_i}\ket{\texttt{key(i)}} \in q(j)
\Rightarrow \texttt{is\_suc}(j\,\sminus\,\lfloor\log\;i \rfloor,\texttt{key}(i))
  \end{array}
$
}
}
\caption{Quantum walk reachable node verification for a complete binary tree. As a circuit, the conditional ($\texttt{if}~(\neg u[0]) \,s$) is interpreted as $\texttt{X}(u[0]);\,\texttt{if}~(u[0])\,s$. $\texttt{left}$ and $\texttt{right}$ reach the left and right children in a tree. $q(j)$ is a quantum state with variable $j$. $\texttt{key}(i)$ accesses $i$-th node's key in a tree.
$\texttt{is\_suc}(t,i)$ judges if $i$ is a $t$-depth node. $\lfloor r \rfloor$ rounds $r$ down to nearest nat. }
\label{fig:background-circuit-example-walk}
\end{figure}

\subsection{Case Study: Understanding Quantum Walk}\label{sec:quantumwalk}

Quantum walk \cite{Wong_2022,ChildsNAND,Venegas_Andraca_2012} is a quantum version of the classical random walk \cite{RayleighThePO}, and an important algorithmic protocol for writing quantum algorithms. However, most quantum walk analyses were based on Hamiltonian simulation evolving, which deters many computer programmers to invent quantum walk algorithms. Here, we show that discrete time quantum walk, at its very least, is a quantum version of breadth first search. 

\Cref{fig:background-circuit-example-walk} provides the core loop of a discrete time quantum walk algorithm on a complete binary tree. In quantum walk, there are four quantum array pieces: $x$ (size $t$) is the loop step register in superposition; $y$ (size $m=2^t$) stores the result of evaluating $x<\snext{j}$ in every loop step; $u$ (size $1$) is the coin, $1$ for the left direction and $0$ for the right one, and determines the moving direction of next step ; and $w$ (size $n$) stores the node keys with $\overline{0}$ being the root node. The loop entangles all these four pieces together as session $\{x[0..t],y[0..j],u[0..1],w[0..n]\}$. 
Before the $j$-th step, every basis states are divided into two sets based on the values of range $x[0..t]$, described by $q(j)$'s two parts separated by $+$, if a basis state has $\tov{x[0..n]}<j$, it is in the active set, while the rest ones are inactive. In the loop, we first compare $x[0..n]$ with $\snext{j}$; move exactly one basis state, the one $\tov{x[0..n]}=j$, to the active set; insert $y[j]$ qubit into the four piece session; and store the Boolean result $\tov{x[0..n]}<\snext{j}$ to $y[j]$.
Then, we apply a diffusion operation on the coin of all active set basis states and double the active set size. In each loop step, we have $2^{(\snext{j})}-2$ numbers of active basis states.
For every basis state, diffusion redistributes its amplitude to "copy" a new basis state with exactly the same content except that the $u$ coin is now in an opposite direction. 
The next two statements in \Cref{fig:background-circuit-example-walk} line 5-6 transition every active set basis state's node key to its child's keys depending on the coin directions \footnote{The tree representations and \texttt{left} and \texttt{right} functions can be implemented as data structures based on \oqasm.}.

If the for-loop executes $m$ steps, the result state contains all possible tree nodes up to $m$-depth except the root node, stored as basis states; stated as the post-condition in \Cref{fig:background-circuit-example-walk}.
Apparently, the amplitudes, which represent the basis state likelihood, are low for each basis state here. In quantum computing, there are amplification operations that serve the opposite of quantum diffusion to increase certain basis state amplitudes. In the full \qafny implementation, we have an amplifier operation $\ssassign{w}{}{\texttt{reduce}(\overline{0})}$ that reduces the root node amplitude while increases the other basis state amplitudes. We can insert the operation in \Cref{fig:background-circuit-example-walk} line 4, so that every time if am active set basis state holds the root node key in range $w$, we reduce its amplitude. Notice that every new basis state that just becomes active in each loop step starts with the root node, which means that basis states having $\snext{j}$-th depth nodes have a higher amplitudes than basis states having $j$-th depth nodes, so that leaf nodes having the biggest amplitudes, which is ideal because most tree algorithms are likely to work on the leaves rather than the middle transition nodes. 













