\section{\qafny Evaluation and Case Studies}
\label{sec:arith-oqasm}

\begin{figure*}[t]
{\footnotesize
\begin{tabular}{|l|c|c|c|c|c|}
\hline
Algorithm & Run Time (sec) & QBricks Run Time (sec) & \# Lines& QBricks \# Lines  & Human Effort (days)\\
                     \hline
GHZ & 4.2 & - & 8 & - & < 1 \\
Controlled GHZ & 6.4 & - & 6 & - & < 1 \\
Deutschâ€“Jozsa & 3.3 & 79 & 6 & 57  & < 1 \\
Grover's search & 26.7 & 283 & 19 & 193 &  3\\
Shor's algorithm & 36.3 & 1380  & 28 & 1163 & 30  \\
Quantum Walk & 43.1 & - & 35 & - & 2 \\
\hline                           
\end{tabular}
}
\caption{Computer running time and human labor time for verifying algorithms in \qafny. Verification running time (Run Time) is measured in a i7 windows computer. 
QBricks running time is based on \cite{qbricks}, and \texttt{-} means no data.
Every algorithm is verified by a single person, thus the human effort measures the time for a person to finish programming and verifying an algorithm. The quantum walk algorithm is the core of the Childs' Boolean equation algorithm \cite{ChildsNAND}.}
\label{fig:circ-evaluation}
\end{figure*}

We evaluate QNP by (1) demonstrating how quantum algorithms are verified in the framework, and (2) showing that it saves the time for programmers to write and verify quantum programs, especially, it helps them to discover possible new ways of integrating quantum operations.
%
This section presents the facts about verifying quantum programs in \qafny. Then, we discuss two case studies, including the verification of the controlled GHZ, Grover's search, and Shor's algorithm, as a demonstration of verifying quantum algorithms in \qafny.

\Cref{fig:circ-evaluation} shows the algorithms being verified in \qafny. When we started the QNP project, we first tried to verify Shor's algorithm directly on Dafny, which spent a researcher 30 days to finish. After that, we built the \qafny compiler on Dafny, and run a \qafny version of the Shor's algorithm proof, which is much more cleaner than the code written directly in Dafny. The running time for that proof is 36.3 seconds. In fact, running any \qafny verification does not take more than a minute to finish, which is relatively comparable with most nowadays automated verification framework \cite{DBLP:conf/pldi/Qiu0SM13,dafnyref}, and better than the existing quantum automated frameworks, such as QBricks \cite{qbricks}, as indicated in \Cref{fig:circ-evaluation}.

The computer running time is usually a less important factor in verifying programs, while the human effort is the more important issues. We believe that QNP saves a great amount of human resources. This fact is indicated by the number of lines in writing the algorithm specifications in \qafny. As shown in \Cref{fig:circ-evaluation}, all the algorithms are written with less than 35 lines of code. One of the examples is the Shor's algorithm specification written in the \qafny interface in \Cref{fig:shorexample}.
In contrast, most algorithms written in other quantum automated verification frameworks require more than 1000 lines of code.
For example, the Grover's search specification in quantum Haore Logic \cite{qhoreusage} has 3184 lines of code, and the Shor's algorithm specification in QBricks \cite{qbricks} has 1163 lines of code \footnote{We do not mean to compare the coding lines to other frameworks since the coding line numbers might be varied depending on many factors, but we only provide a hint on the automation in \qafny.}.
In terms of human resources, other than Shor's algorithm, which was done before the \qafny compiler was fully constructed, most algorithms were written and verified in \qafny (\Cref{fig:circ-evaluation}) in two days by a single researcher. 
As a comparison, the complete Shor's algorithm correctness proof \cite{shorsprove} was finished by four researchers that spent two years. Even the oracle in the Shor's algorithm, the modulo multiplication circuit, was verified by three researchers that spent four months. Therefore, QNP help relieve programmers' pain in reasoning about quantum programs.

\begin{figure}[t]
{\centering
\begin{minipage}[t]{.4\textwidth}
\subcaption{Quantum circuit}
  \vspace{0.5cm}
\qquad\qquad
  \small
  \Qcircuit @C=0.5em @R=0.5em {
    \lstick{\ket{0}} & \gate{H} & \qw & \ctrl{1} & \qw & \qw  & \\
    \lstick{\ket{0}} & \qw & \qw & \multigate{3}{\texttt{GHZ}} & \qw &\qw &  \\
    & \vdots &   &  &  & & \\
    & \vdots &  & \dots & & &  \\
    \lstick{\ket{0}} & \qw & \qw & \ghost{\texttt{GHZ}} &\qw &\qw &
    }
\end{minipage}
%
\begin{minipage}[t]{.5\textwidth}
\subcaption{\qafny Program and Proof}
{\small
\[
\begin{array}{r l}
\textcolor{blue}{1}
&
\{x[0..1]\mapsto \ket{0},y[0..n]\mapsto \ket{\overline{0}}\}\\[0.2em]
\textcolor{blue}{2}
&
\ssassign{x[0]}{}{\ihadh};\\[0.2em]

\textcolor{blue}{3}
&
\textcolor{teal}{
\{x[0..1]\mapsto \frac{1}{\sqrt{2}}(\ket{0}+\ket{1}) * y[0..n]\mapsto \ket{\overline{0}}\}
}
\\[0.2em]

\textcolor{blue}{4}
&
\textcolor{teal}{
\Rightarrow
\{\{x[0..1],y[0..n]\}\mapsto \scha{2}{}{j}{\ket{\overline{0}}}\}
}
\\[0.2em]

\textcolor{blue}{5}
&
\sifq{x[0]}{\texttt{ghz}(y)};
\\[0.2em]

\textcolor{blue}{6}
&
\{\{x[0..1],y[0..n]\}\mapsto \frac{1}{\sqrt{2}}\ket{\overline{0}}+\frac{1}{2}\ket{1.\overline{0}}+\frac{1}{2}\ket{\overline{1}} \}
\end{array}
\]
}
\end{minipage}
%
\begin{minipage}[t]{1\textwidth}
\subcaption{Detailed proof for conditional in line 5. $\kappa=\{x[0..1],y[0..n]\}$}
{\footnotesize
  \begin{mathpar}
\inferrule[]{
   \inferrule[]
   { 
  { \fivepule{\Omega}{\{y[0..n]:\tnort\}}{\mmode}
{\textcolor{teal}{
y[0..n]\mapsto {\ket{\overline{0}}}}
\textcolor{purple}{\ket{1}}
}{ \texttt{ghz}(y) }{
\textcolor{teal}{
y[0..n]\mapsto \schii{2}{\frac{1}{\sqrt{2}}}{\overline{i}}}
\textcolor{purple}{\ket{1}}
}
} }
   {
\fivepule{\Omega}{\{y[0..n]:\tcht\}}{\cmode}
{\textcolor{teal}{
\mathpzc{M}(x[0],y[0..n])\mapsto \scha{2}{}{j}{\ket{\overline{0}}}
}
}{ \texttt{ghz}(y) }{
\textcolor{teal}{
y[0..n]\mapsto \schii{2}{\frac{1}{\sqrt{2}}}{\overline{i}}}
\textcolor{purple}{\ket{1}}
}} } {
\inferrule[]
{\fivepule{\Omega}{\sigma}{\cmode}
{\textcolor{teal}{
\kappa\mapsto \scha{2}{}{j}{\ket{\overline{0}}}
}
}{ \sifq{x[0]}{\texttt{ghz}(y)} }{
\textcolor{teal}{
\mathpzc{U}(\neg x[0],\kappa)\mapsto \scha{2}{}{j}{\ket{\overline{0}}}
*
\mathpzc{U}(x[0],\kappa)\mapsto \schii{2}{\frac{1}{\sqrt{2}}}{\overline{i}}}
\textcolor{purple}{\ket{1}} }}
{\fivepule{\Omega}{\sigma}{\cmode}
{\textcolor{teal}{
\kappa\mapsto \scha{2}{}{j}{\ket{\overline{0}}}
}
}{ \sifq{x[0]}{\texttt{ghz}(y)} }{
\textcolor{teal}{
\kappa \mapsto \frac{1}{\sqrt{2}}\ket{\overline{0}}+\frac{1}{2}\ket{1.\overline{0}}+\frac{1}{2}\ket{\overline{1}}
} }}
}
  \end{mathpar}
}
\end{minipage}
}
\caption{Controlled GHZ circuit and proof. $\texttt{ghz}(y)$ is the GHZ algorithm in \Cref{fig:background-circuit-example}. Lines 3-4 are automatically inferred. In the \qafny implementation, Arrays $x$ and $y$ can be represented as a single variable through renaming techniques. Here, we split them for simplicity. The purple parts are the frozen bases. }
\label{fig:background-circuit-example-controlled}
\end{figure}

As a consequence, QNP also helps programmers in discovering new ways of utilizing quantum algorithms. The controlled GHZ algorithm does not typically appear in many quantum information books \cite{mike-and-ike}, but it is a nice usage of the GHZ algorithm to prepare different entanglement structures. The implementation and verification of the controlled GHZ algorithm finishes momentarily (\Cref{fig:circ-evaluation}).


\subsection{Controlled GHZ Case Study: Building Quantum Algorithms on Others}

One important criteria that an automated verification framework has is the essence of reusing existing verification proofs to synthesize new algorithm verification. However, in most quantum proof systems nowadays, this criteria is neglected. For example, QBricks did not utilize the quantum phase estimation (QPE) proof, which is the core part of Shor's algorithm, to construct their Shor's algorithm proof.
In VOQC \cite{VOQC}, the reuse of the QPE proof in the Shor's proof was done by proving many new theorems that were not originally required in the QPE proofs. QNP opens a windows towards the reusable proofs for verifying new algorithms based on existing verification.

\Cref{fig:background-circuit-example-controlled} provides a proof of the Controlled GHZ algorithm based on the GHZ proof in \Cref{fig:background-circuit-example-proof}. The focal point is at \Cref{fig:background-circuit-example-controlled} line 5, where the GHZ function requires input to be a $\tnort$ state of all $0$ qubits, but the given state, which is in line 4, is an entanglement $\scha{2}{}{j}{\ket{\overline{0}}}$. In \qafny, we automatically verify the proof by rule \rulelab{PIF} the equational relation to rewrite a singleton $\tcht$ state to a $\tnort$ state as: $\sch{1}{z_j}{c_j}\equiv z_0\ket{c_0}$. The detailed proofs for the conditional is given in \Cref{fig:background-circuit-example-controlled}(c). Once rule \rulelab{PIF} is applied on the second and third line, session $y[0..n]$'s state is actually a $\tnort$ type state ${\ket{\overline{0}}}\ket{1}$, where $\overline{0}$ is $n$ bits and $\ket{1}$ is in the frozen stack; thus, the state is exactly the GHZ input one, so that we can safely reuse the GHZ proof in \Cref{fig:background-circuit-example-proof} and reach the final conclusion. 

\begin{figure}[t]
{\centering
{\small
\[
\begin{array}{r l}
\textcolor{blue}{1}
&
\textcolor{teal}{
\{ x[0..n] \mapsto \shadi{2^n}{n}{} *
   y[0..m] \mapsto \ket{\overline{0}} *
   u[0..1] \mapsto \ket{0} *
   w[0..n] \mapsto \ket{\overline{0}} * m < n\}
}
\\[0.3em]
\textcolor{blue}{2}
&
\texttt{for}~{(\texttt{int}~j \in [0,m)~\&\&~x < 2^j \,@\, y[j])}
\\[0.3em]

\textcolor{blue}{3}
&
\;\;
\{ \{x[0..n],y[0..j],u[0..1],w[0..n]\} \mapsto q(j) \wedge \texttt{is\_steps}(j,q(j)) \}
\;\;\{
\\[0.3em]

\textcolor{blue}{4}
&
\quad
\ssassign{u}{}{\sdis};
\\[0.2em]

\textcolor{blue}{5}
&
\quad
\sifq{u[0]}{\texttt{left}(w)};
\\[0.2em]

\textcolor{blue}{6}
&
\quad
\sifq{\neg u[0]}{\texttt{right}(w)};
\\[0.2em]
\textcolor{blue}{7}
&
\}
\\[0.4em]

\textcolor{blue}{8}
&
\textcolor{teal}{
\{ \{x[0..n],y[0..m],u[0..1],w[0..n]\} \mapsto q(m) \wedge \texttt{is\_steps}(m,q(m)) \}
}
\end{array}
\]
}
{\small
\[
\begin{array}{l}
\lfloor i \rfloor = \snext{t} \;\;\texttt{where}\;\;2^t \le i < 2^{\snext{t}}
\qquad \lfloor 0 \rfloor = 0
\\[0.2em]
\texttt{pat}(c,t,j) = \ket{0}^{\otimes t}\ket{1}^{\otimes (j-t)}
\\[0.2em]
\texttt{gkey}(i,j) = \texttt{IF}\, i < 2^j\,\texttt{THEN}\,\texttt{key}(i)\,\texttt{ELSE}\,\overline{0}
\\[0.2em]
q(j)=\schai{2^j}{z_i}{i}{\ket{\texttt{pat}(c,\lfloor i \rfloor,j)}\ket{u_i}\ket{\texttt{gkey(i,j)}}}
\\[0.2em]
\texttt{is\_steps}(j,q(j))=
\forall i. \ket{i}\ket{\texttt{pat}(c,\lfloor i \rfloor,j)}\ket{u_i}\ket{\texttt{gkey(i,j)}} \in q(j) \wedge i < 2^j
\Rightarrow \texttt{is\_suc}(\lfloor i \rfloor,\texttt{key}(i))
\end{array}
\]
}
}
\caption{Quantum walk proof for a complete binary tree. In the circuit level, $\texttt{if}~(\neg u[0]) \,s$ is interpreted as $\texttt{X}(u[0]);\,\texttt{if}~(u[0])\,s$. $\texttt{left}$ and $\texttt{right}$ are to reach the left and right children in a tree. $q(j)$ is a quantum state with variable $j$. $\texttt{key}(i)$ accesses $i$-th node's key in a tree.
$\texttt{is\_suc}(t,i)$ judges if $i$ is a $t$-depth node.}
\label{fig:background-circuit-example-walk}
\end{figure}

The type of $y[0..n]:\tcht$ on the top of \Cref{fig:background-circuit-example-controlled} is actually turned to $\tnort$ because session $y[0..n]$ has a single basis state. Essentially, the \qafny type system is implemented as predicates in Dafny, and we utilize extra predicates to implement the $\tcht$ state to a $\tnort$ state rewrite above. In \Cref{sec:newtype}, we implement a new type system that tracks both sessions and basis states. In the new type system, the type rewrite can automatically happens without extra predicate axioms.

\subsection{Case Study: Understanding Quantum Walk}

Quantum walk \cite{Wong_2022,ChildsNAND,Venegas_Andraca_2012} is an quantum version of the classical random walk \cite{RayleighThePO}, and it is an important algorithmic protocol for writing quantum algorithms. However, most quantum walk analyses were based on Hamiltonian simulation evolving, which deters many computer scientists to invent quantum walk algorithms. Here, we show that discrete time quantum walk, at its very least, is a quantum version of breadth first search. 

\Cref{fig:background-circuit-example-walk} provides the core loop of a discrete time quantum walk algorithm on a complete binary search tree. In quantum walk, there are four quantum array pieces: $x$ (size $n$) is named the sources that provide enough basis states in superposition for the later calculation; $y$ (size $m$) stores the result of evaluating $x<2^j$ in every loop step; $u$ (size $1$) is the coin, $1$ for the left direction and $0$ for the right one, in a random walk that determines the next step ; and $w$ (size $n$) stores the node keys with $\overline{0}$ being the root node. The $j$-th loop step entangles all these four pieces together
as session $\{x[0..n],y[0..j],u[0..1],w[0..n]\}$. Before such loop, every basis states are divided into two sets based on the range $x[0..n]$ value, if a basis state has $\tov{x[0..n]}<2^{j-1}$, it is active, while the rest ones are inactive. In the loop, we first compare $x[0..n]$ with $2^j$ and turn all basis states having $x[0..n]$ values, as $2^{j-1} \le \tov{x[0..n]}<2^{j}$, to active set, insert $y[j]$ qubit into the session, and stores the Boolean result $\tov{x[0..n]}<2^{j}$ on $y[j]$.
Then, we apply a diffusion operation on the coin of all active set basis states. For every basis state, this step redistributes its amplitude to "copy" a new basis state with exactly the same content except that the coin is now in an opposite direction. 
The next two statements in \Cref{fig:background-circuit-example-walk} line 5-6 exchange active basis state's keys with its child's key depending on the coin directions \footnote{The tree representations and \texttt{left} and \texttt{right} functions can be implemented as data structures based on \oqasm.}.

If the for-loop executes $m$ steps, the result contains all possible tree $m$-depth nodes, which is stated as the post-condition in \Cref{fig:background-circuit-example-walk}. Remember that in a complete tree, there are $2^m$ number of $m$-depth nodes, and quantum walk creates a state contains all possible nodes. Apparently, the amplitudes, which represent the basis state likelihood, are low for each basis state. In quantum computing, there are amplification operations that serve the opposite of quantum diffusion to increase certain basis state amplitudes. In the full \qafny implementation, we have an amplifier operation $\ssassign{w}{}{\texttt{reduce}(\overline{0})}$ that reduces the root node amplitude while increases the other basis state amplitudes. We can insert the operation in \Cref{fig:background-circuit-example-walk} line 4, so that every time if the range $w$ of am active basis state is the root node, we reduce its amplitude. Notice that every new basis state that just becomes active in each loop step starts with the root node, which means that basis states having $\snext{j}$-th depth nodes have a higher amplitudes than basis states having $j$-th depth nodes, so that leaf nodes having the biggest amplitudes, which is ideal because most tree algorithms are likely to work on the leaves rather than the middle transition nodes. 













