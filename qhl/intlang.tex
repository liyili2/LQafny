\section{QWhile: A High-level Quantum Language}
\label{sec:vqir}

We introduce the language syntax and type system for QWhile and introduce the Q-Dafny Proof system.
As a running example, we specify Shor's algorithm and its proof in Q-Dafny in \Cref{fig:shorexample}.
The Q-Dafny to Dafny compiler is under construction, but the compiled version of the Shor's algorithm proof has been finalized
and can be found at \url{https://github.com/inQWIRE/VQO/blob/naturalproof/Q-Dafny/examples/Shor-compiled.dfy}.

\subsection{Sessions, Kinds, Types, and States}\label{sec:state}

\begin{figure}[t]
{
  \small
  \[\begin{array}{llcl} 
      \text{Bitstring} & c & \in & (0\mid 1)^{+}       \\
      \text{Indexed bitstring set} & \overline{c}(m) & ::= & \{c_0,c_1,...,c_{m-1}\}       \\
      \text{Nat. Num} & m, n & \in & \mathbb{N}       \\
      \text{Real} & r & \in & \mathbb{R}\\
      \text{Complex Number} & z & \in & \mathbb{C} \\
      \text{Phase} & \alpha(r) & ::= & e^{2\pi i r} \\
      \text{Program/Session Variable} & x,y \\
      \text{Mode} & g & ::= & \cmode  \mid \qmode\\
      \text{Classical Value} & v & ::= & n \mid (r,n)\\
      \text{Session} & \lambda & ::= & \overline{x[n..m]} \\
      \text{Full Mode (Kind)} & k & ::= & g \mid \lambda \\
      \text{Option} & p \in\; \topt{'a} & ::= & 'a \mid \infty \\
      \text{Uniform Distribution} & \bigcirc \\
      \text{Type} & \tau & ::= & \tnor{(\topt{c})}\mid \thad{(\topt{\bigcirc})}
                    \mid \tch{(\topt{\overline{c}(m)})} \\
      \text{Quantum States} & q & ::= & \ket{c}\mid \shad{2^n}{n}{\alpha(r_j)} \mid \sch{m}{z_j}{c_j} \\
    \end{array}
  \]
}
  \caption{\qafny element syntax. In $\overline{c}(m)$, $\overline{c}$ is a bitstring set and $m$ is the element number, and it can be abbreviated as $\overline{c}$. Each element $x[n..m]$ in a session $\overline{x[n..m]}$ represents the range $[n,m)$ in a qubit array $x$. }
  \label{fig:qafny-state}
\end{figure}

\begin{figure}
{\small
{\hspace*{-6em}
\begin{minipage}[t]{0.4\textwidth}
\begin{center}
 \[
  \begin{array}{l@{~}cl}
  \tnor{\infty} &\sqsubseteq_n& \tch{\infty}\\
  \tnor{c} &\sqsubseteq_n& \tch{\{c\}}\\
  \tch{\overline{c}(1)} &\sqsubseteq_n& \tnor{\overline{c}[0]}\\
  \thad{p} &\sqsubseteq_n& \tch{\{c(i)|i\in[0,2^n)\}(2^n)}\\
  \tch{\{0,1\}} &\sqsubseteq_1& \thad{\infty}\\
  \tch{p} &\sqsubseteq_n& \tch{\infty}
    \end{array}
  \]
\end{center}
\subcaption{Subtyping}
  \label{fig:qafny-subtype}
\end{minipage}
\qquad
\begin{minipage}[t]{0.45\textwidth}
\begin{center}
   \[
   \begin{array}{l@{~}cl}
  \ket{c} &\equiv_n& \sch{1}{ }{c}\\
  \sch{1}{z_j}{c_j} &\equiv_n& \ket{c_0}\\
  \shad{2^n}{n}{\alpha(r_j)} &\equiv_n& \sch{2^n}{\frac{\alpha(\sum_{k=0}^{n} r_k \cdot \tos{j}[k])}{\sqrt{2^n}}}{j}\\
  \sch{2}{z_j}{c_j} &\equiv_1& \shad{2}{1}{\frac{\sqrt{2}z_1}{z_0}}\\
   &&\qquad\texttt{when }c_0=0\;\;c_1=1
    \end{array}
 \]
\end{center}
\subcaption{State Equivalence}
  \label{fig:qafny-sequiv}
\end{minipage}
  \caption{\qafny type/state relations. $\overline{c}[n]$ produces the $n$-th element in set $\overline{c}$. $\{c(i)|i\in[0,2^n)\}(2^n)$ defines a set $\{c(i)|i\in[0,2^n)\}$ with the emphasis that it has $2^n$ elements. $\{0,1\}$ is a set of two single element bitstrings $0$ and $1$. $\cdot$ is the multiplication operation, $\tos{j}$ turns a number $j$ to a bitstring, $\tos{j}[k]$ takes the $k$-th element in the bitstring $\tos{j}$, and $\ket{j}$ is an abbreviation of $\ket{\tos{j}}$.}
  \label{fig:qafny-eq}
}
}
\end{figure}

The \qafny element component syntax is represented according to the grammar in \Cref{fig:qafny-state}. 
In \qafny, there are three kinds of values, two of which are classical ones represented by the two modes: $\cmode$ and $\qmode$.
The former represents classical values, represented as a natural number $n$, that do not intervene with quantum measurements and are evaluated in the compilation time, the latter represents values, represented as a pair $(r,n)$, produced from a quantum measurement. The real number $r$ is a characteristic representing the theoretical probability of the measurement resulting in the value $n$.
Any classical arithmetic operation does not change $r$, i.e., $(r,n)+m=(r,n+m)$. 

Quantum values are defined in terms of sessions ($\lambda$), which can be viewed as clusters of possibly entangled qubits, where the number of qubits is exactly the session length, i.e., $\slen{\overline{x[n..m]}}$.
Each session consists of different disjoint ranges represented as $x[n..m]$ that refers the range $[n,m)$ in a quantum array named $x$.
For simplicity, we assume that different variable names referring to different quantum arrays without aliasing.
Each length-$n$ session is associated to a quantum state that can be one of the three forms ($q$ in \Cref{fig:qafny-state}) that are corresponding to three different types ($\tau$ in \Cref{fig:qafny-state}). The first kind of state is of \texttt{Nor} type ($\tnor{(\topt{c})}$), having the state form $\ket{c}$, which is a computational basis value. $c$ is of length $n$ and represents a tensor product of qubits, all being $0$ or $1$. The second kind of state is of \texttt{Had} type ($\thad{(\topt{\bigcirc})}$),  meaning that qubits in such session are in superposition but not entangled.
The state form is $\shad{2^n}{n}{\alpha(r_j)}$, where $\alpha(r_j)$ is a local phase for the $j$-th qubit in the session. If $r_j=0$ for all $j$, the state can be represented by  type $\thad{\bigcirc}$ representing a uniformly distributed superposition; otherwise, we represent the type as $\thad{\infty}$. The third kind of state is of $\texttt{CH}$ type ($\tch{(\topt{\overline{c}(m)})}$), having the state form $\sch{m}{z_j}{c_j}$, referring to that qubits in such session are possibly entangled. The state $\sch{m}{z_j}{c_j}$ can be viewed as an $m$ element set of pairs $z_j\ket{c_j}$, where $z_j$ and $c_j$ are the $j$-th amplitude and basis.
The well-formed restrictions for the state are three: 1) $\sum_{j=0}^{m}|z_j|^2=1$ ($z_j$ is a complex number); 2) length of $c_j$ is $n$ for all $j$ and $m \le 2^n$; 3) any two bases $c_j$ and $c_k$ are distinct.

In \qafny, the quantum types and states are associated through bases and equational properties.
For each quantum state $q$, especially for \texttt{Nor} type state $\ket{c}$ and \texttt{CH} type state $\sch{m}{z_j}{c_j}$, the type factors are either $\infty$ meaning no bases can be tracked, or having the form $c$ and $\overline{c}(m)$ that track the bases of the state $\ket{c}$ and $\sch{m}{z_j}{c_j}$, respectively. For \texttt{Nor} type, this means that the type factor $c$ (in $\tnor{c}$) and the state qubit format $\ket{c}$ must be equal; for \texttt{CH} type ($\tch{\overline{c}(m)}$), if the state is $\sch{m}{z_j}{c_j}$, the $j$-th element $\overline{c}[j]$ is equal to $c_j$.
Additionally, \qafny types permit subtyping relations that correspond to state equivalent relations in \Cref{fig:qafny-eq}. 
Both subtype relation $\sqsubseteq_n$ and state equivalence relation $\equiv_n$ are parameterized by a session length number $n$, such that they establish relations between two quantum states describing a session of length $n$.
$\sqsubseteq_n$ in \Cref{fig:qafny-subtype} describes a type term on the left can be used as a type on the right. For example, a \texttt{Nor} type qubit array $\tnor{c}$ can be used as a single element entanglement type term $\tch{\{c\}}$ \footnote{If a qubit array only consists of $0$ and $1$, it can be viewed as an entanglement of unique possibility. }. 
Correspondingly, state equivalence relation $\equiv_n$ describes the two state forms to be equivalent; specifically, the left state term can be used as the right one, e.g., a single element entanglement state $\sch{1}{z_j}{c_j}$ can be used as a \texttt{Nor} type state $\ket{c_0}$ with the fact that $z_0$ is now a global phase that can be neglected.

\subsection{Syntax}
\sloppy
QWhile is a high-level language for describing quantum programs,
which permits quantum control and for-loop statements.
\Cref{fig:vqimp} introduces the QWhile syntax. 

\begin{figure}[t]
{
  \small
  \[\begin{array}{llcl} 
      \text{Nat. Num} & m, n & \in & \mathbb{N}       \\
      \text{Real} & r & \in & \mathbb{R}\\
      \text{Variable} & x,y \\
      \text{\cmode-Mode Value} & n\\
      \text{\qmode-Mode Value} & (r,n)\\
      \text{\oqasm Expr} & \mu\\
      \text{Session} & \zeta & ::= & \overline{(x,n,m)} \\
      \text{Type Predicate} & T & ::= & x:\tau  \mid x:\{\zeta:\tau\} \mid ...\\
      \text{State Predicate} & P,Q & ::= & x=n\mid x=(r,n)  \mid \zeta=\rho \mid ...\\
      \text{Mode} & g & ::= & \cmode  \mid \qmode\\
      \text{Mode Check Result} & q & ::= & g  \mid \zeta\\
      \text{Factor} & l & ::= & x \mid x[a] \\
      \text{Arith Expr} & p,a & ::= & l \mid a + a \mid a * a \mid ... \\
      \text{Bool Expr} & b & ::= & x[a] \mid (a = a) @ x[a] \mid (a < a) @ x[a] \mid \neg b  ... \\
      \text{Gate Expr} & op & ::= & \texttt{H} \mid \iqft[\lbrack -1 \rbrack]{}{} \\
      \text{C/M Moded Expr}& e & ::= & a \mid \smea{y}  \\
      \text{Statement} & s & ::= & \sskip \mid \sexp{x}{e}{s} \mid  \ssassign{l}{}{op} \mid \ssassign{\overline{l}}{}{a(\mu)} 
                                 \\ & & \mid & \sseq{s}{s} \mid \sifq{b}{s} \mid
                                     \sqwhile{\sinit{i}{a_1}}{i<a_2}{b(i)}{f(i)}{T(i)}{P(i)}{s}
                     \\&&\mid & \samplify{\ssassign{x}{}{a}}
                      \mid \sdistr{l}
    \end{array}
  \]
}
{\footnotesize
\[
\begin{array}{l}
\rho \text{: Quantum States see \Cref{fig:vqir-state}}
\end{array}
\]
}
  \caption{Core QWhile Syntax, \oqasm Syntax is in \Cref{fig:vqir}}
  \label{fig:vqimp}
\end{figure}

\begin{figure}[t]
  \small
  \[\hspace*{-0.5em}
\begin{array}{l>{$} p{1.2cm} <{$} c l}
      \text{Bit} & d & ::= & 0 \mid 1 \\
      \text{BitString} & \overline{d} & ::= & \mathbb{N} \to d \\
      \text{BitString Indexed Set} & \beta & ::= & \{\overline{d} \} \mid \infty \\
      \text{Phase Type} & w & ::= & \bigcirc \mid \infty \\
      \text{Type Element} & t & ::= & \tnor{\overline{d}} \mid \thad{w} \mid \tch{n}{\beta}\\
      \text{Type} & \tau & ::= & \ttype{n}{t}\\
      \text{Phase} & \alpha(n) & := & e^{2\pi i \frac{1}{n}} \\
      \text{Amplitude} & \theta & := & r \\
      \text{Phi State} & \qket{n} & := & \frac{1}{\sqrt{2}} (\ket{0}+\alpha(n)\ket{1}) \\
      \text{Quantum State} & \rho & ::= & \alpha\ket{\overline{d}}\mid \Motimes_{k=0}^{m}\ket{\Phi(n_k)}
                                         \mid \sum_{k=0}^{m}\theta_k\ket{\overline{d_k}}
    \end{array}
  \]
  \caption{QWhile Sessions and Types and Quantum States}
  \label{fig:vqir-state}
\end{figure}


\begin{figure}[t]
{\Small
  \begin{mathpar}
    \inferrule[ ]{ }{\Omega \vdash x : \Omega(x)}

    \inferrule[ ]{\Omega(x)=(x,0,\Sigma(x)) }{\Omega \vdash x[n] : [(x,n,n+1)]}

    \inferrule[ ]{ \Omega \vdash a_1 : q_1 \\ \Omega \vdash a_2 : q_2 }{\Omega \vdash a_1 + a_2 : q_1 \sqcup q_2}   

    \inferrule[ ]{ \Omega \vdash a_1 : q_1 \\ \Omega \vdash a_2 : q_2 }{\Omega \vdash a_1 * a_2 : q_1 \sqcup q_2}   
 

    \inferrule[ ]{ \Omega \vdash a_1 : q_1 \\ \Omega \vdash a_2 : q_2 \Omega \vdash a_3 : q_3  }{\Omega \vdash (a_1 = a_2)@x[n] : q_1 \sqcup q_2\sqcup q_3}   

    \inferrule[ ]{ \Omega \vdash a_1 : q_1 \\ \Omega \vdash a_2 : q_2 \Omega \vdash a_3 : q_3  }{\Omega \vdash (a_1 < a_2)@x[n] : q_1 \sqcup q_2\sqcup q_3}

    \inferrule[ ]{ \Omega \vdash b : q}{\Omega \vdash \neg b : q}  

    \inferrule[ ]{ \Omega \vdash e : \zeta_2 \sqcup \zeta_1 }{\Omega \vdash e : \zeta_1 \sqcup \zeta_2}   

  \end{mathpar}
}
{\footnotesize
\[
\begin{array}{l}
\zeta_1 \sqcup \zeta_2 = \zeta_1 \uplus \zeta_2
\zeta \sqcup g = \zeta
\qquad 
g \sqcup \zeta = \zeta
\qquad
\cmode \sqcup \cmode = \cmode
\qquad
\qmode \sqcup \cmode = \qmode
\qquad
\cmode \sqcup \qmode = \qmode
\qquad
\cmode \le \qmode \le \zeta
\\[0.2em]
\bot \uplus l = l
\qquad 
l \uplus \bot = l

\qquad

[(x,v_1,v_2)] \uplus [(y,v_3,v_4)] = [(x,v_1,v_2), (y,v_3,v_4)]

\\

[v_2,v_2] \cap [v_3,v_4] \neq \emptyset \Rightarrow [(x,v_1,v_2)] \uplus [(x,v_3,v_4)] = [(x,\texttt{min}(v_1,v_3),\texttt{max}(v_2,v_4))]

\end{array}
\]
}
  \caption{Arith, Bool, Gate Mode Checking}
  \label{fig:exp-well-typed}
\end{figure}

A QWhile program consists of a sequence of C-like statements $s$.
Values and variables (ranged by $x$ and $y$) in a statement
are classified as three different categories: compilation time classical values, 
classical values generated from quantum measurement, and quantum state registers.
We use variable \textit{modes} to classify the first two kinds as \cmode and \qmode modes.
We represent \cmode-mode values as natural numbers, while $M$-mode values are represented as pairs of reals and natural numbers.
The reals represent the conceptual occurrence probability of the result measurement,
and the natural numbers are the measurement results.
Any further arithmetic operations on $M$-mode values are applied on the measurement results,
such as $(r,n_1)+n_2=(r,n_1+n_2)$.

Quantum registers refer to quantum qubit arrays in QWhile.
They are always associated with disjoint sets of qubit array fragments, named \textit{sessions}.
We represent a qubit array fragment as $(x,n,m)$, where $x$ is a variable representing a qubit array, $n$ is the start position in $x$ for the array fragment and $m$ is the exclusive ending point.
In \Cref{fig:shorexample}, an example array fragment for \code{x} is \code{x[0..i]}.
\code{y} is an abbreviation of array fragment \code{y[0..n]} where \code{n} is the ending point of array \code{y}.
\code{(y,x[0..i])} is a session containing two array fragments.
It is worth noting that the ordering of fragments in a session only 
serves for recording the qubit positions in a quantum register.
The swapping of fragment ordering does not affect the register state.
In Q-Dafny, the fragment ordering might affect the property proof automation.
In \Cref{fig:shorexample}, we fix fragment order as \code{(y,x[0..i])}
to enhance the Shor's algorithm proof automation. 

We use $x[a]$ to represent the $a$-th position qubit in $x$.
It is worth noting that the variable $x$ in $x[a]$ must represent quantum registers. 
We name a variable $x$ or an array index $x[a]$ as a factor.
In a QWhile program, \cmode and \qmode mode variables act like stack variables
and they must be bounded by variables introduced by \texttt{let} statements;
while quantum registers represent arrays in a "quantum heap" and are bounded by $\Sigma$.

The statements $s$ in the first row in \Cref{fig:vqimp} are \sskip (SKIP) and assignment operations.
Classic assignment (\sexp{x}{e}{s}) evaluates $e$ and assigns the value to \cmode or \qmode mode variable $x$ that is used in $s$.
Expressions $e$ can be an arithmetic or a measurement operation.
$\sexp{x}{\smea{y}}{...}$ assigns the measurement result of qubit array $y$ to $x$.
$\ssassign{l}{}{op}$ and $\ssassign{\overline{l}}{}{a(\mu)}$ are quantum assignments.
The former applies a simple quantum gate ($\texttt{H}$ or $\texttt{QFT}$)
to a single qubit ($x[a]$) or a qubit array ($x$) \footnote{$\texttt{QFT}$ gate must apply to a variable $x$}.
$\ssassign{\overline{l}}{}{a(\mu)}$ is a generalized quantum assignment that implements quantum oracle circuits $a$ and applies an \oqasm/\sourcelang operation on a list of qubit array $\overline{l}$.
We assume all arithmetic ($a$) and Boolean ($b$) expressions are reversible.
For example, the operation $(a_1 < a_2) @ x[a]$ compares $a_1$ and $a_2$ and stores the value in $x[a]$.
$\mu$ is the circuit implementation of the expression $a$ in \oqasm, whose syntax is given in \Cref{sec:vqir}.
One can utilize \oqasm expressions ($\mu$) to implement singleton $\texttt{X}$ and $\irz[\lbrack -1 \rbrack]{n}{}$ gates,
thus, the QWhile syntax is universal with respect to quantum gates.
In addition, \sourcelang is a C-like reversible arithmetic language built on \oqasm.
The reversible expression $a$ in \Cref{fig:vqimp} is based on \sourcelang operations.
For simplicity, we write $\ssassign{\overline{l}}{}{a}$ in examples here to
mean that it applies a \sourcelang circuit that computes $a$ to $\overline{l}$.

The second row of statements in \Cref{fig:vqimp} are control-flow operations.
$\sseq{s_1}{s_2}$ is a sequential operation.
$\sifq{b}{s}$ is a conditional and $b$ might contain quantum factors.
Every quantum factor $l$ appearing in $b$ must not appear in $s$.
In QWhile, we define a \texttt{well\_formed} predicate to check such property.
$\sqwhile{\sinit{i}{a_1}}{i<a_2}{b(i)}{f(i)}{T(i)}{P(i)}{s}$ is a possibly quantum for-loop depending on if the Boolean guard $b(i)$ ($b(i)$ is a Boolean expression that contains variable $i$) contains quantum factors (also needing to be \texttt{well\_formed}).
A classical variable $i$ is introduced and it is initialized as the lower bound $a_1$, increments in each loop step by the monotonic increment function $f(i)$, and ends at the upper bound $a_2$.
$T(i)$ is the type predicate (type predicate syntax in \cref{fig:vqimp}) where for $i$-th loop step,
$T(i)$ is true in the beginning and $T(f(i))$ is maintained after the execution.
Similarly, $P(i)$ is the loop-invariant (state predicate in \cref{fig:vqimp}) for the for-loop structure, where for $i$-th loop step,
$P(i)$ is true in the beginning and $P(f(i))$ is maintained after the execution. 

The last row contains quantum reflection operations,
which are used to adjust the occurrence probability of
some quantum states in a quantum qubit array.
For example, in Grover's search algorithm \cite{grover1996},
the Grover's diffusion operation is a quantum reflection
that increases the occurrence probability of a target quantum state in a qubit array being in superposition.
We identify two kinds of quantum reflections that previous works tent to combine together.
The first one is an amplifier ($\samplify{\ssassign{x}{}{a}}$)
that amplifies the occurrence probability of the target state,
which is represented by a classical value $a$,
in a quantum qubit array $x$.
The second one is a diffusion operator ($\sdistr{x}$)
that diffuses the state of a qubit array $x$ to a superposition of 
all possible bases in $x$ with possibly different amplitudes \footnote{The possible bases do not depend on $x$'s state, and it is only related to the qubit size of $x$; i.e., if $x$ is a two qubit array, then the operation reflects the superposition of all possible two qubit states as: $\frac{1}{2}(\ket{00}+\ket{01}+\ket{10}+\ket{11})$.  }.
For example, applying the diffusion operator on a two-qubit array $x$ having state $\ket{00}$
results in a superposition of $-\frac{1}{2}\ket{00}+\frac{1}{2}\ket{01}+\frac{1}{2}\ket{10}+\frac{1}{2}\ket{11}$.
In general, if an $n$-qubit array $x$ has the state $\sum_{j=0}\alpha_j\ket{x_j}$,
the result of applying a diffusion operator is $\frac{1}{2^{n}}(2\sum_{i=0}^{2^n}(\sum_{j=0}\alpha_j)\ket{i} - \sum_{j=0}\alpha_j\ket{x_j})$.

\subsection{Type Checking: A Quantum Session Type System}\label{sec:typesystem}

The QWhile type system can be viewed as a mapping from lists of factors ($x$ or $x[n]$) to QWhile types in \Cref{fig:vqir-state}.
Generally, factors represent a range of locations in a "quantum heap".
Variable $x$ can be viewed as a range $(x,0,\Sigma(x))$, meaning the heap range starting at $x$ and ending at $x+n$.
Index $x[n]$ can be viewed as a range $(x,n,n+1)$.
Thus, a list of \textbf{quantum} factors is essentially a list of disjoint fragments, which it is called a \textit{session}.

A type is written as $\ttype{n}{t}$, where $n$ refers to the total number of qubits in a session,
and $t$ describes the qubit state form. 
A session being type $\ttype{n}{\tnor{\overline{d}}}$
means that every qubit is in normal basis (either $\ket{0}$ or $\ket{1}$),
and $\overline{d}$ describes basis states for the qubits.
The type corresponds to a single qubit basis state $\alpha(n)\ket{\overline{d}}$,
where the global phase $\alpha(n)$ has the form $e^{2 \pi i \frac{1}{n}}$ and $\overline{d}$ is a list of bit values.
Global phases for \texttt{Nor} type are usually ignored in many semantic definitions.
In QWhile, we record it because in quantum conditionals, such global phases might be turned to local phases.

$\ttype{n}{\thad{w}}$ means that every qubit in the session has the state: $(\alpha_1\ket{0} + \alpha_2\ket{1})$;
the qubits are in superposition but they are not entangled.
$\bigcirc$ represents the state is a uniform superposition,
while $\infty$ means the phase amplitude for each qubit is unknown.
If a session has such type, it then has the value form $\Motimes_{k=0}^{m}\ket{\Phi(n_k)}$,
where $\ket{\Phi(n_k)}=\frac{1}{\sqrt{2}}(\ket{0}+\alpha(n_k)\ket{1})$.

All qubits in a session that has type $\ttype{n}{\tch{m}{\beta}}$ are supposedly entangled (eventual entanglement below).
$m$ refers to the number of possible different entangled states in the session,
and the bitstring indexed set $\beta$ describes each of these states, while every element in $\beta$ is indexed by $i\in [0,m)$.
$\beta$ can also be $\infty$ meaning that the entanglement structure is unknown.
For example, in quantum phase estimation, after applying the $\texttt{QFT}^{-1}$ operation, the state has type $\ttype{n}{\tch{m}{\infty}}$. In such case, the only quantum operation to apply is a measurement.
If a session has type $\ttype{n}{\tch{m}{\beta}}$ and the entanglement is a uniform superposition,
we can describe its state as $\sum_{i=0}^{m}{\frac{1}{\sqrt{m}}\beta(i)}$, and the length of bitstring $\beta(i)$ is $n$.
For example, in a $n$-length GHZ application, the final state is: $\ket{0}^{\otimes n}+\ket{1}^{\otimes n}$. 
Thus, its type is $\ttype{n}{\tch{2}{\{\overline{0}^n,\overline{1}^n\}}}$, where $\overline{d}^n$ is a $n$-bit string having bit $d$.

The type $\ttype{n}{\tch{m}{\beta}}$ corresponds to the value form $\sum_{k=0}^{m}\theta_k\ket{\overline{d_k}}$.
$\theta_k$ is an amplitude real number, and $\overline{d_k}$ is the basis.
Basically, $\sum_{k=0}^{m}\theta_k\ket{\overline{d_k}}$ represents a size $m$ array of basis states
that are pairs of $\theta_k$ and $\overline{d_k}$. For a session $\zeta$ of type $\texttt{CH}$,
one can use $\zeta[i]$ to access the $i$-th basis state in the above summation, and the length is $m$.
In the Q-Dafny implementation section, we show how we can represent $\theta_k$ for effective automatic theorem proving.

The QWhile type system has the type judgment: $\Omega,\itau\vdash_g s : \zeta\triangleright \tau$, where $g$ is the context mode, mode environment $\Omega$ maps variables to modes or sessions ($q$ in \Cref{fig:vqimp}), type environment $\itau$ maps a session to its type, $s$ is the statement being typed, $\zeta$ is the session of $s$, and $\tau$ is $\zeta$'s type. 
The QWhile type system in \Cref{fig:exp-sessiontype} has several tasks. First, it enforces context mode restrictions.
Context mode $g$ is either \cmode or \qmode.
$Q$ represents the current expression lives inside a quantum conditional or loop, while \cmode refers to other cases.
In a $Q$ context, one cannot perform $M$-mode operations, i.e., no measurement is allowed.
There are other well-formedness enforcement. For example,
the session of the Boolean guard $b$ in a conditional/loop is disjoint with the session in the conditional/loop body,
i.e., qubits used in a Boolean guard cannot appear in its conditional/loop body.

Second, the type system enforces mode checking for variables and expressions in \Cref{fig:exp-well-typed}.
In QWhile, \cmode-mode variables are evaluated to values during type checking.
In a \texttt{let} statement (\Cref{fig:exp-sessiontype}),
\cmode-mode expression is evaluated to a value $n$, and the variable $x$ is replaced by $n$ in $s$.
The expression mode checking (\Cref{fig:exp-well-typed}) has the judgment: $\Omega \vdash (a\mid b) : q$. It takes a mode environment $\Omega$, and an expression ($a$, $b$), and judges if the expression has the mode $g$ if it contains only classical values, or a quantum session $\zeta$ if it contains some quantum values. 
All the supposedly \cmode-mode locations in an expression are assumed
to be evaluated to values in the type checking step,
such as the index value $x[n]$ in difference expressions in \Cref{fig:exp-well-typed}.
It is worth noting that the session computation ($\uplus$)
is also commutative as the last rule in \Cref{fig:exp-well-typed}.

Third, by generating the session of an expression, the QWhile type system assigns a type $\tau$ for the session indicating its state format, which will be discussed shortly below. Recall that a session is a list of quantum qubit fragments.
In quantum computation, qubits can entangled with each other.
We utilize type $\tau$ (\Cref{fig:vqir-state}) to state entanglement properties appearing in a group of qubits.
It is worth noting that the entanglement property refers to \textit{eventual entanglement}, .i.e. a group of qubits that are eventually entangled. Entanglement classification is tough and might not be necessary. In most near term quantum algorithms, such as Shor's algorithm \cite{shors} and Childs' Boolean equation algorithm (BEA) \cite{ChildsNAND}, programmers care about if qubits eventually become entangled during a quantum loop execution. This is why the normal basis type ($\ttype{n}{\tnor{\overline{d}}}$) can also be a subtype of a entanglement type ($\ttype{n}{\tch{1}{\{\overline{d}\}}}$) in our system (\Cref{fig:exp-subtyping}).

\myparagraph{Entanglement Types}
We first investigate the relationship between the types and entanglement states.
It is well-known that every single quantum gate application
does not create entanglement ($\texttt{X}$, $\texttt{H}$, and $\texttt{RZ}$).
It is enough to classify entanglement effects through a control gate application, i.e., 
$\sifq{x[i]}{e(y)}$, where the control node is $x[i]$ and $e$ is an operation applying on $y$.

A qubit can be described as $\alpha_1\ket{b_1}+\alpha_2\ket{b_2}$,
where $\alpha_1$/$\alpha_2$ are phase amplitudes, and $b_1$/$b_2$ are bases.
For simplicity, we assume that
when we applying a quantum operation on a qubit array $y$, we either solely change the qubit amplitudes or bases.
We identify the former one as $\mathpzc{R}$ kind, referring to its similarity of applying an \texttt{RZ} gate;
and the latter as $\mathpzc{X}$ kind, referring to its similarity of applying an \texttt{X} gate.
The entanglement situation between $x[i]$ and $y$ after applying a control statement $\sifq{x[i]}{e(y)}$ is described in \Cref{fig:control-entanglement}.

\begin{figure*}[t]
{\footnotesize
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
\hline                           
&  Case 1 & Case 2 & Case 3 & Case 4 & Case 5 & Case 6 & Case 7 & Case 8 & Case 9 \\
\hline
$x[i]$ & \texttt{Nor} & \texttt{Had} & \texttt{Had} & \texttt{Had} & \texttt{Had} & \texttt{Had} & \texttt{Had} & \texttt{CH} & \texttt{CH} \\
$y$  & any & \texttt{Nor} & \texttt{Nor} & \texttt{Had} & \texttt{Had} & \texttt{CH} & \texttt{CH} & \texttt{CH} & \texttt{CH}   \\\hline
$y$'s operation type  & any & $\mathpzc{X}$ & $\mathpzc{R}$ & $\mathpzc{X}$ & $\mathpzc{R}$ & $\mathpzc{X}$ & $\mathpzc{R}$ &  $\mathpzc{X}$ & $\mathpzc{R}$ \\\hline
Output Type Entangled?  & N & Y & N & N & Y & Y & Y & Y & Y  \\
\hline                           
\end{tabular}
  \caption{Control Gate Entanglement Situation}
  \label{fig:control-entanglement}
}
\end{figure*}

If $x[i]$ has input type \texttt{Nor}, the control operation acts as a classical conditional, i.e., no entanglement is possible.
In most quantum algorithms, $x[i]$ will be in superposition (type \texttt{Had}) to enable entanglement creation.
When $y$ has type $\texttt{Nor}$, if $y$'s operation is of $\mathpzc{X}$ kind, an entanglement between $x[i]$ and $y$ is created, such as the GHZ algorithm; 
if the operation is of $\mathpzc{R}$ kind, there is not entanglement after the control application, such as the Quantum Phase Estimation (QPE) algorithm.

When $x[i]$ and $y$ are both of type \texttt{Had}, if we apply an $\mathpzc{X}$ kind operation on $y$,
it does not create entanglement. An example application is the phase kickback pattern.
If we apply a $\mathpzc{R}$ operation on $y$, this does create entanglement.
This kind of operations appears in state preparations, such as preparing a register $x$ to have state $\sum_{t=0}^N i^{-t}\ket{t}$ in Childs' Boolean equation algorithm \cite{ChildsNAND}. 
The main goal for preparing such state is not to entanglement qubits, but to prepare a state with phases related to its bases.

\begin{figure}[t]
{\small
$
\begin{array}{l}
\ttype{n}{\tnor{\overline{d}}} \sqsubseteq \ttype{n}{\tch{1}{\{\overline{d}\}}}
\qquad 
\ttype{n}{\tch{2^n}{\beta}} \sqsubseteq \ttype{n}{\tch{2^n}{\infty}}
\qquad 
\ttype{n}{\thad{\bigcirc}} \sqsubseteq \ttype{n}{\tch{2^n}{\tpower{n}}}
\end{array}
$
}
  \caption{Session Type Subtyping}
  \label{fig:exp-subtyping}
\end{figure}

The case when $x[i]$ and $y$ has type \texttt{Had} and \texttt{CH}, respectively,
happens in the middle of executing a quantum loop, such as in the Shor's algorithm and BEA.
Applying both $\mathpzc{X}$ and $\mathpzc{R}$ kind operations result in entanglement.
In this narrative, algorithm designers intend to
merge an additional qubit $x[i]$ into an existing entanglement session $y$.
$x[i]$ is commonly in uniform superposition,
but there can be some additional local phases attached with some bases,
which we named this situation as saturation, i.e.,
In an entanglement session written as $\sum_{i=0}^n \ket{x_l,y,x_r}$,
for any fixing $x_l$ and $x_r$ bases, if $y$ covers all possible bases,
we then say that the part $y$ in the entanglement is in saturation.
This concept is important for generating auto-proof, which will be discussed in \Cref{sec:logical}.

\begin{figure}[t]
{
{\Small
  \begin{mathpar}

    \inferrule[TA-NOR]{ \Omega \vdash \overline{l}:\zeta
                  \\ \llbracket a \rrbracket\ket{\overline{d}}=\alpha\ket{\overline{d'}}}{\Omega,\itau[\zeta \mapsto \ttype{n}{\tnor{\overline{d}}}] \vdash_g \ssassign{\overline{l}}{}{a} : \zeta \triangleright_g \ttype{n}{\tnor{\overline{d'}}} }


    \inferrule[TA-HAD]{ \Omega \vdash \overline{l}:\zeta\\ \zeta \subseteq \zeta'
                  \\ (\forall \overline{d}\;.\;\llbracket a \rrbracket\ket{\overline{d}}=\ket{\overline{d'}}) \\ }{\Omega,\itau[\zeta'\mapsto \ttype{n}{\thad{\bigcirc}}] \vdash_g \ssassign{\overline{l}}{}{a} : \zeta' \triangleright \ttype{n}{\thad{\bigcirc}}}

    \inferrule[TEXP]{\Omega[x\mapsto \cmode],\itau\vdash_g s[v/x] :\zeta \triangleright \tau}{\Omega,\itau \vdash_g \sexp{x}{v}{s} :\zeta\triangleright \tau }

    \inferrule[TMEA]{ \Omega \vdash y:\zeta \\ n'=\size{\zeta'}
     \\ m' = \texttt{size}(\{\overline{c'}|\overline{c}\cdot\overline{c'}\in\beta\cdot\beta'\wedge \overline{c}=\texttt{val}(x)\})
\\\\
           \Omega[x\mapsto \qmode],\itau[\zeta' \mapsto \ttype{n'}{\tch{m'}{\{\overline{c'}|\overline{c}\cdot\overline{c'}\in\beta\cdot\beta'\wedge \overline{c}=\texttt{val}(x)\}}}]\vdash_{\cmode} s : \zeta''\triangleright  \tau}{\Omega,\itau[\zeta\uplus \zeta'\mapsto \ttype{n}{\tch{m}{(\beta\cdot\beta')}} ] \vdash_{\cmode} \sexp{x}{\smea{y}}{s} : \zeta'' \triangleright \tau }

    \inferrule[TA-CH]{ \Omega \vdash \overline{l}:\zeta \\ \zeta' = \zeta\uplus\zeta_r \\ }{\Omega,\itau[\zeta' \mapsto \ttype{n}{\tch{k}{\beta}}] \vdash_g \ssassign{\overline{l}}{}{a} :\zeta' \triangleright \ttype{n}{\tch{k}{\{\overline{d'}\cdot\overline{d_r} \;|\;\overline{d}\cdot\overline{d_r}\in \beta(\downarrow\zeta)\cdot \beta(\downarrow\zeta_r)
\wedge \llbracket a \rrbracket\ket{\overline{d}}=\alpha\ket{\overline{d'}} \}}} }

    \inferrule[TA-Mu]{ \Omega,\itau[\zeta_1\uplus\zeta_3\uplus\zeta_2\uplus \zeta_4 \mapsto \ttype{n}{\tch{k}{\beta_1\cdot\beta_3 \cdot \beta_2 \cdot \beta_4}}] \vdash_g s :\zeta_1\uplus\zeta_3\uplus\zeta_2\uplus \zeta_4 
       \triangleright \ttype{n}{\tch{k}{\beta_1\cdot\beta'_3 \cdot \beta'_2 \cdot \beta_4}}}{\Omega,\itau[\zeta_1\uplus\zeta_2\uplus\zeta_3\uplus \zeta_4 \mapsto \ttype{n}{\tch{k}{\beta_1\cdot\beta_2 \cdot \beta_3 \cdot \beta_4}}] 
   \vdash_g s :\zeta_1\uplus\zeta_2\uplus\zeta_3\uplus \zeta_4 
       \triangleright \ttype{n}{\tch{k}{\beta_1\cdot\beta'_2 \cdot \beta'_3 \cdot \beta_4}} }

    \inferrule[TSEQ-1]{ \Omega,\itau \vdash_g s_1 :\zeta\triangleright \ttype{n}{\tnor{\overline{d}}} \\ \\ \zeta \cupdot \zeta'
\\\\ \Omega,\itau[\zeta \mapsto \ttype{n}{\tnor{\overline{d}}}] \vdash_g s_2 :\zeta'\triangleright \ttype{n'}{\tnor{\overline{d'}}} }{\Omega,\itau \vdash_g \sseq{s_1}{s_2} :\zeta \uplus \zeta'\triangleright \ttype{n+n'}{\tnor{\overline{d}\cdot\overline{d'}}} }

    \inferrule[TSEQ-2]{ \Omega,\itau \vdash_g s_1 :\zeta\triangleright \ttype{n}{\tch{k}{\beta}}
     \\\\ \Omega,\itau[\zeta \mapsto \ttype{n}{\tch{k}{\beta}}] \vdash_g s_2 :\zeta'\triangleright \tau }{\Omega,\itau \vdash_g \sseq{s_1}{s_2} :\zeta' \triangleright \tau }

    \inferrule[TIF]{ \Omega\vdash b(@x[v]) : \zeta \\ \itau(\zeta)=\ttype{n}{\tch{k}{(\beta_1\cdot 0 \cup \beta_2\cdot 1)}} 
   \\\\ \zeta \cupdot \zeta' \\ \texttt{last}(\zeta)=(x,v,v+1)
     \\ \Omega,\itau \vdash_{\qmode} s :\zeta' \triangleright \ttype{n'}{\tch{k'}{\beta'}} }{\Omega,\itau[\zeta\mapsto \ttype{n}{\tch{k}{\beta}}] \vdash_g \sifq{x[v]}{s} : \zeta\uplus\zeta' \triangleright \ttype{n+n'}{\tch{(k\times k')}{
(\beta_1\cdot 0 \cdot \beta' \cup \beta_2\cdot 1 \cdot \beta')}} }

    \inferrule[TLOOP]{ v_1 \le v < v_2 \\ \Omega \vdash f(v):\cmode \\ \Omega\vdash b(@x[v]) : \zeta(v) \\ \zeta(v) \cupdot \zeta'(v) \\ \texttt{last}(\zeta)=(x,v,v+1)
\\ \Omega,\itau \vdash_g \sifq{b(@x[v])}{s}: \zeta(v) \uplus \zeta'(v) \triangleright\tau(v) }
                  {\Omega,\itau \vdash_g \sqwhile{\sinit{i}{v_1}}{i<v_2}{b(@x[i])}{f(i)}{T(i)}{P(i)}{s} : \zeta(v_2) \uplus \zeta'(v_2) \triangleright\tau(v_2) }

    \inferrule[TDIS]{ \Omega \vdash x : \zeta \\\zeta' = \zeta\uplus \zeta_r \\ n'=\size{\zeta} 
     \\ m' = \texttt{size}(\{\tpower{n'}\cdot\overline{d_r} \;|\;\overline{d}\cdot\overline{d_r}\in \beta(\downarrow\zeta)\cdot \beta(\downarrow\zeta_r) \})}{\Omega,\itau[\zeta'\mapsto \ttype{n}{\tch{m}{\beta}} ] \vdash_g \sdistr{x} :\zeta' \triangleright 
\ttype{n}{\tch{m'}{\{\tpower{n'}\cdot\overline{d_r} \;|\;\overline{d}\cdot\overline{d_r}\in \beta(\downarrow\zeta)\cdot \beta(\downarrow\zeta_r) \}}}}
  \end{mathpar}
}
{\footnotesize
\[
\begin{array}{l}
\overline{d}\cdot\overline{d'} : \text{list concatenation.}
\qquad
\zeta\cupdot \zeta': \text{The two sessions are disjoint.}
\\
\beta(\downarrow\zeta) : \text{Get the position range of }\zeta
\text{ in the session and form a new set}
\\
\qquad\qquad\text{of bitstrings containing only the positions in the range.}
\\
\llbracket a \rrbracket\ket{\overline{d}}:
\text{\oqasm semantics of interpreting reversible expression }a\text{ in \Cref{fig:deno-sem}.}
\end{array}
\]
}
}
  \caption{Session Type System}
  \label{fig:exp-sessiontype}
\end{figure}

When $x[i]$ and $y$ are both of type \texttt{CH}, there are two situations.
When the two parties belong to the same entanglement session,
it is possible that an $\mathpzc{X}$ or $\mathpzc{R}$ operation de-entangles the session.
Since QWhile tracks eventual entanglement.
In many cases, \texttt{HAD} type can be viewed as a kind of entanglement.
In addition, the QWhile type system make sure that most de-entanglements happen
at the end of the algorithm by turning the qubit type to $\tch{m}{\infty}$,
so that after the possible de-entanglement, the only possible application is a measurement.

If $x[i]$ and $y$ are in different entanglement sessions,
the situation is similar to when $x[i]$ having \texttt{Had} and $y$ having \texttt{CH} type.
It merges the two sessions together through the saturation $x[i]$.
For example, in BEA, The quantum Boolean guard computes the following operation $(z < i) @ x[i]$
on a \texttt{Had} type variable $z$ (state: $\sum_{k=0}^{2^n}\ket{k}$)
and a $\texttt{Nor}$ type factor $x[i]$ (state: $\ket{0}$).
The result is an entanglement $\sum_{k=0}^{2^n}\ket{k,k < i}$,
where the $x[i]$ position stores the Boolean bit result $k < i$. \footnote{When $k<i$, $x[i]=1$ while $\neg (k<i)$, $x[i]=0$.}
The algorithm further merges the $\ket{z,x[i]}$ session with a loop body entanglement session $y$. 
In this cases, both $\ket{z,x[i]}$ and $y$ are of \texttt{CH} type. 


\ignore{
\begin{definition}\label{def:type-saturation}\rm[Saturation]
For any qubit array $y$, if applying $\mathpzc{X}$ kind operations does not change its state, we call $y$ is in saturation.
\end{definition}
}


\myparagraph{Session Type System}
Selected type rules are given in \Cref{fig:exp-sessiontype}.
As we have mentioned above, the type system tracks 
possible eventual entanglement for a group of qubits, which we named a session.
The type judgment is given as $\Omega,\itau\vdash_g s : \zeta\triangleright \tau$.

Rule \text{TEXP} is the type rule for \cmode-mode expressions.
The expression $a$ is evaluated and variable $x$ is substituted with the value $v$ in $s$.
\text{TMEA} is a similar rule as \text{TEXP}, but for $M$-mode variable.
We allow partial measurements in QWhile.
Thus, we need to find out a possible entanglement session $\zeta\uplus \zeta'$ that contains $y$'s session ($\zeta$), that is going to disappear because of measurement.
Then, we re-calculate the entanglement type information for $\zeta'$.

\text{TA-NOR}, \text{TA-HAD} and \text{TA-CH} are rules for quantum assignments with different input types.
$\llbracket a \rrbracket$ appearing in these rules is a semantic function for interpreting the expressions $a$.
The semantic function takes an expression in \texttt{Nor} type and output a \texttt{Nor} value,
i.e., inputting classical values and output classical results.
The semantics of \oqasm (\Cref{fig:deno-sem}) and the arithmetic language \sourcelang
is the role model of such semantic function.
In \text{TA-HAD}, when $\overline{l}$ is in uniform superposition ($\thad{\bigcirc}$),
for every bit in $\overline{l}$, if the semantic function judges that its global phase keeps in uniformity, .i.e, $1$,
the output type is still a uniform superposition without entanglement.
In \text{TA-CH}, the factor $\overline{l}$ that is assigning
might be a sub-session $\zeta$ of the whole entanglement session $\zeta'$,
such that $\zeta'= \zeta\cdot \zeta_r$.
Here, for every element $\overline{d}\cdot\overline{d_r}\in\beta$,
we find out the corresponding part $\overline{d}$ belonging to the session
$\zeta$ ($\overline{d}\cdot\overline{d_r}\in\beta(\downarrow\zeta)\cdot\beta(\downarrow\zeta_r)$),
and updates the $\overline{d}$ in the result type.

Rules \text{TSeq-1} and \text{TSeq-2} describe the type for a sequence operation.
If $s_1$ and $s_2$ are of type \texttt{Nor} or \texttt{Had} (rule \text{TSeq-1}),
the output session order can be mutated as long as the two sessions are disjoint.
If the two sessions are not disjoint, we only need to keep the type for $\zeta'$,
since it is obvious that $\zeta \subseteq \zeta'$. 
If $s_1$ and $s_2$ are of type \texttt{CH} (rule \text{TSeq-2}),
we only permit the case when  $\zeta \subseteq \zeta'$ for simplicity.
It has no technical difficulty to allow $\tau$ to be a list
and two entanglement sessions to bind together,
but it makes the type system a lot messier,
and there is no current algorithms that require the modification of 
two distinct entanglement sessions inside a conditional block.
On the other hand, if two distinct entanglement sessions live in a conditional block,
the block can always be split into two different conditionals with the same Boolean guard.

Rule \texttt{TIF} describes the type for conditionals when the Boolean guard $b(@x[v])$ having type \texttt{CH},
and $x[v]$ is the result bit storing the Boolean evaluation result.
The result type of such conditionals is an \texttt{CH} type
by merging the session of $b(@x[v])$ into the entanglement session.
Assume that the \texttt{CH} bases for $b(@x[v])$ are $\beta_1\cdot 0$ and $\beta_2\cdot 1$, meaning
that we can split nicely for all possible bases of a quantum state to two different sets where the last bit, 
which represents the $x[v]$ position, is $0$ and $1$.
For the $0$ set, we extend $\beta_1\cdot 0$ to $\beta_1\cdot 0\cdot \beta$ 
by doing a cross product of the elements in set $\beta_1\cdot 0$ and set $\beta$.
For the $1$ set, the cross product is applied on set $\beta_1\cdot 0$ and set $\beta'$, 
where $\beta'$ is the result type bases of the body statement $s$.
It is worth noting that by the subtyping relation in \Cref{fig:exp-subtyping}, any type can be turned to a \texttt{CH} type.
When the Boolean guard has type \texttt{Nor}, it is no more than a classical conditional.
When the Boolean guard has type \texttt{Had}, its behavior is similar to the \texttt{CH} case.

Rule \texttt{TLOOP} describes the type for a \texttt{for}-loop.
It is a generalization of the conditional case when the Boolean guard $b(@x[i])$ having type \texttt{CH}.
In the type rule, we pick a number $v$ to represent variable $i$, 
and check if a single loop step $\sifq{b(@x[v])}{s}$ is well typed.
If so, we can conclude that when we replace $v$ by $v_2$, the \texttt{for}-loop is type checked.

Rule \texttt{TDIS} types a diffusion operator.
The rule finds the right part of $x$ in the session $\zeta'$.
For every right session bitstring $\overline{d}$ in $\overline{d_l}\cdot\overline{d}\cdot\overline{d_r}$,
it generates a set of new type sequence by replacing $\overline{d}$ with elements in the power set $\tpower{n'}$, 
where $n'$ is the bit length of $\overline{d}$.
Here, we need to compute the $\texttt{size}$ of the new bitstring set as $m'$.
Sometimes, this computation can be hard, but for most quantum algorithms,
depending on the session data structures, the $\texttt{size}$ can be computed effectively.


\begin{figure*}[t]
{\footnotesize
  \begin{mathpar}

    \inferrule[PA-NOR ]{(\itau ,\itau')\models_g (T,\ssassign{\overline{l}}{}{a},T'):\zeta\triangleright\ttype{n}{\tnor{\overline{d}}}}
                {\Omega\vdash_g\fivepule{T}{P[\llbracket a \rrbracket \zeta /\zeta] } {\ssassign{\overline{l}}{}{a}} {T'}{P}}


    \inferrule[PA-CH ]{(\itau,\itau')\models_g (T,\ssassign{\overline{l}}{}{a},T'):\zeta\uplus\zeta'\triangleright \ttype{n}{\tch{m}{\beta}}
                 \\ \itau(\overline{l})=\zeta}
       {\Omega\vdash_g\fivepule{T}{P[\forall k < m.\;\llbracket a \rrbracket(\zeta[k]) / \zeta[k]] } {\ssassign{\overline{l}}{}{a}}{T'}{P}}


    \inferrule[P-MEA ]{ (\itau[\forall \zeta'\;.\;\zeta\uplus\zeta' \mapsto \ttype{n+n'}{\tch{(m\times m')}{(\beta\cdot\beta')}}],\itau'[\forall \zeta'\;.\;\zeta' \mapsto \ttype{n'}{\tch{m'}{\beta'}}])\models_{\cmode} (T,y,T''):\zeta\triangleright \ttype{n}{\tch{m}{\beta}}
  \\ v < m \\
   \Omega[x\mapsto M,y\mapsto \bot]\vdash_{\cmode} \fivepule{T''}{P[(\iasa{2}{\zeta[v]},\ibs{\zeta[v]}) /x, \bot / \zeta] } {s} {T'}{Q} } {\Omega\vdash_{\cmode}\fivepule{T}{P}{\sexp{x}{\smea{y}}{s}}{T'}{Q}}

    \inferrule[P-IF ]{(\itau,\itau')\models_{\qmode} (T,s,T'):\zeta'\triangleright \ttype{n'}{\tch{m'}{\beta'}}
      \\\Omega\vdash b(@x[v]): \zeta\uplus[(x,v,v+1)] \\ \itau(\zeta\uplus[(x,v,v+1)])= \ttype{n}{\tch{2m}{(\beta_1\cdot 0 \cup \beta_2\cdot 1)}}
       }{\Omega\vdash_{g}\fivepule{T}{P[(\zeta\uplus 0 \uplus \zeta')\texttt{++}(\zeta\uplus 1 \uplus \llbracket s \rrbracket\zeta') /\zeta\uplus[(x,v,v+1)]\uplus\zeta'] }
      {\sifq{b(@x[v])}{s}}{T'}{P}}

    \inferrule[P-LOOP ]{(\itau,\itau')\models_g (T(i),\sifq{b(@x[i])}{s},T(f(i))):\zeta\triangleright \tau 
            \\ \Omega\vdash_g\fivepule{T(i)}{P(i)}{\sifq{x[i]}{s}}{T(f(i))}{P(f(i))} }
     {\Omega\vdash_g\fivepule{T(a_1)}{P(a_1) }{\sqwhile{\sinit{i}{a_1}}{i<a_2}{x[i]}{f(i)}{T(i)}{P(i)}{s}}{T(a_2)}{P(a_2)}}
    
    \inferrule[P-DIS ]{(\itau,\itau')\models_g (T,\sdistr{x},T'):\zeta\triangleright \ttype{n'}{\tch{m'}{\beta'}}
             \\ \itau(x)=\{\zeta:\ttype{n'}{\tch{m}{\beta}}\}
    \\\zeta = \zeta' \uplus (x,0,\Sigma(x))
    \\ \beta_1 \cdot \beta_2=\beta(\downarrow (x,0,\Sigma(x)))\cdot \beta(\downarrow \zeta') } 
           {\Omega\vdash_g\fivepule{T}{P[\texttt{dis}(n',\zeta,\beta,\beta_1,\beta_2) /\zeta] }
      {\sdistr{x}}{T'}{P}}


  \end{mathpar}
}
{\footnotesize
\[
\begin{array}{l}
\texttt{ln}(\zeta)\text{: length of }\zeta
\qquad
\texttt{as}(\zeta[v])\text{: the amplitude of }\zeta[v]
\qquad
\texttt{bs}(\zeta[v])\text{: the base of }\zeta[v]
\qquad
\texttt{++}\text{: array concatenation.}
\\
\texttt{dis}(n,\zeta,\beta,\beta_1,\beta_2)\equiv \{\frac{1}{2^{n-1}}(\sum_k \texttt{as}(\zeta[k])-\texttt{as}(\zeta[j]))\beta_1[j]
                           \;|\; \beta_1[j]\in \tpower{n} \}
\\
\qquad\qquad\qquad\qquad\qquad
\cup  \bigcup_{j\in \beta_2}\{\frac{1}{2^{n}}\sum_k \texttt{as}(\zeta[k])z
                           \;|\; z\in \tpower{n} \wedge (\forall k.\;z \cdot \beta_2[j] \neq \beta[k]) \}
\end{array}
\]
}
\caption{Selected Proof System Rules}
\label{fig:exp-proofsystem}
\end{figure*}

\subsection{Logic Proof System}\label{sec:logical}


The reason of having the session type system in \Cref{fig:exp-sessiontype}
is to enable the proof system given in \Cref{fig:exp-proofsystem}.
Every proof rule is a structure as $\Omega\vdash_g \fivepule{T}{P}{s}{T'}{Q}$,
where $g$ and $\Omega$ are the type entities mentioned in \Cref{sec:typesystem}.
$T$ and $T'$ are the pre- and post- type predicates for the statement $s$, 
meaning that there is type environments $\itau$ and $\itau'$, such that $\itau\models T$,
$\itau'\models T'$, $g,\Omega,\itau \vdash s : \zeta\triangleright \tau$, and $(\zeta\mapsto \tau) \in \itau'$.
We denote $(\itau,\itau')\models (T,s,T'):\zeta\triangleright\tau$ as the property described above.
$P$ and $Q$ are the pre- and post- Hoare conditions for statement $s$.

The proof system is an imitation of the classical Hoare Logic array theory.
We view the three different quantum state forms in \Cref{fig:vqir-state} as arrays with elements in different forms,
and use the session types to guide the occurrence of a specific form at a time.
Sessions, like the array variables in the classical Hoare Logic theory,
represent the stores of quantum states.
The state changes are implemented by the substitutions of sessions
with expressions containing operation's semantic transitions.
The substitutions can happen for a single index session element or the whole session.

Rule \text{PA-NOR} and \text{PA-CH} specify the assignment rules.
If a session $\zeta$ has type \texttt{Nor}, it is a singleton array,
so the substitution $\llbracket a \rrbracket \zeta /\zeta$ means
that we substitute the singleton array by a term with the $a$'s application.
When $\zeta$ has type \texttt{CH}, term $\zeta[k]$ refers to each basis state in the entanglement.
The assignment is an array map operation that applies $a$ to every element in the array.
For example, in \Cref{fig:shorexample} line 12,
we apply a series of \code{H} gates to array $x$.
Its post-condition is $[(x,0,n)]=\Motimes_{k=0}^{n}\ket{\Phi(0)}$,
where $[(x,0,n)]$ is the session representing register variable $x$.
Thus, replacing the session $[(x,0,n)]$ with the \code{H} application
results in a pre-condition as $\code{H}[(x,0,n)]=\Motimes_{k=0}^{n}\ket{\Phi(0)}$,
which means that $[(x,0,n)]$ has the state $\ket{0}^n$.

Rule \text{P-MEA} is the rule for partial/complete measurement.
$y$'s session is $\zeta$, but it might be a part of an entangled session $\zeta\uplus\zeta'$.
After the measurement, $M$-mode $x$ has the measurement result $(\ias{\zeta[v]}^2,\ibs{\zeta[v]})$ coming
from one possible basis state of $y$ (picking a random index $v$ in $\zeta$), 
$\ias{\zeta[v]}$ is the amplitude and $\ibs{\zeta[v]}$ is the base.
We also remove $y$ and its session $\zeta$ ($\bot/\zeta$) in the new pre-condition because it is measured away.
The removal means that the entangled session $\zeta\uplus\zeta'$ is replaced by $\zeta'$ 
with the re-computation of the amplitudes and bases for each term.

Rule \text{P-IF} deals with a quantum conditional where the Boolean guard $b(@x[v])$ is of type $\ttype{n}{\tch{2m}{(\beta_1\cdot 0 \cup \beta_2\cdot 1)}}$. The bases are split into two sets $\beta_1\cdot 0$ and $\beta_2\cdot 1$, where the last bit represents the base state for the $x[v]$ position.
In quantum computing, a conditional is more similar to an assignment, where we create a new array to substitute 
the current state represented by the session $\zeta\uplus[(x,v,v+1)]\uplus\zeta'$.
Here, the new array is given as $(\zeta\uplus 0 \uplus \zeta')\texttt{++}(\zeta\uplus 1 \uplus \llbracket s \rrbracket\zeta')$,
where we double the array: if the $x[v]$ position is $0$, we concatenate the current session $\zeta'$ for the conditional body,
if $x[v]=1$, we apply $\llbracket s \rrbracket$ on the array $\zeta'$ and concatenate it to $(\zeta\uplus 1)$.

Rule \text{P-Loop} is an initiation of the classical while rule in Hoare Logic with the loop guard possibly having quantum variables.
In QWhile, we only has \texttt{for-loop} structure and we believe it is enough to specify any current quantum algorithms.
For any $i$, if we can maintain the loop invariant $P(i)$ and $T(i)$ with the post-state $P(f(i))$ and $T(f(i))$
for a single conditional $\sifq{x[i]}{s}$, the invariant is maintained for multiple steps
for $i$ from the lower-bound $a_1$ to the upper bound $a_2$.

Rule \text{P-DIS} proves a diffusion operator $\sdistr{x}$.
The quantum semantics for $\sdistr{x}$ is $\frac{1}{2^{n}}(2\sum_{i=0}^{2^n}(\sum_{j=0}\alpha_j)\ket{i} - \sum_{j=0}\alpha_j\ket{x_j})$.
As an array operation, $\sdistr{x}$ with the session $\zeta$ is an array operation as follows:
assume that $\zeta=(x,0,\Sigma(x))\uplus\zeta_1$, for every $k$,
if $\zeta[k]$'s value is $\theta_k(\overline{d_x}\cdot \overline{d_1})$,
for any bitstring $z$ in $\tpower{\Sigma(x)}$, if $z\cdot \overline{d_1}$
is not a base for $\zeta[j]$ for any $j$, then the state is
$\frac{1}{2^{n-1}}\sum_{k=0}\theta_k(z\cdot \overline{d_1})$;
if the base of $\zeta[j]$ is $z\cdot \overline{d_1}$,
then the state for $\zeta[j]$ is $\frac{1}{2^{n-1}}(\sum_{k=0}\theta_k)-\theta_j(z\cdot \overline{d_1})$.







