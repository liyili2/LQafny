\section{QWhile: A High-level Quantum Language}
\label{sec:vqir}

We introduce the language syntax and type system for QWhile and introduce the Q-Dafny Proof system.
As a running example, we specify Shor's algorithm and its proof in Q-Dafny in \Cref{fig:shorexample}.
The Q-Dafny to Dafny compiler is under construction, but the compiled version of the Shor's algorithm proof has been finalized
and can be found at \url{https://github.com/inQWIRE/VQO/blob/naturalproof/Q-Dafny/examples/Shor-compiled.dfy}.

\subsection{Sessions, Kinds, Types, and States}\label{sec:state}

\begin{figure}[t]
{
  \small
  \[\begin{array}{llcl} 
      \text{Bit} & d & ::= & 0\mid 1       \\
      \text{Bitstring} & c & \in & d^{+}       \\
      \text{Indexed bitstring set} & \overline{c}(m) & ::= & \{c_0,c_1,...,c_{m-1}\}       \\
      \text{Nat. Num} & m, n & \in & \mathbb{N}       \\
      \text{Real} & r & \in & \mathbb{R}\\
      \text{Complex Number} & z & \in & \mathbb{C} \\
      \text{Phase} & \alpha(r) & ::= & e^{2\pi i r} \\
      \text{Program/Session Variable} & x,y \\
      \text{Mode} & g & ::= & \cmode  \mid \mmode\\
      \text{Classical Value} & v & ::= & n \mid (r,n)\\
      \text{Range} & l & ::= & x[n..m] \\
      \text{Session} & \lambda & ::= & \overline{x[n..m]} \\
      \text{Full Mode (Kind)} & fg & ::= & g \mid \qmode{n} \\
      \text{Option} & p \in\; \topt{'a} & ::= & 'a \mid \infty \\
      \text{Uniform Distribution} & \bigcirc \\
      \text{Type} & \tau & ::= & \tnor{(\topt{c})}\mid \thad{(\topt{\bigcirc})}
                    \mid \tch{(\topt{\overline{c}(m)})} \\
      \text{Quantum States} & q & ::= & \ket{c}\mid \shad{2^n}{n}{\alpha(r_j)} \mid \sch{m}{z_j}{c_j} \\
    \end{array}
  \]
}
  \caption{\qafny element syntax. In $\overline{c}(m)$, $\overline{c}$ is a bitstring set and $m$ is the element number, and it can be abbreviated as $\overline{c}$. Each element $x[n..m]$ in a session $\overline{x[n..m]}$ represents the number range $[n,m)$ in a qubit array $x$. }
  \label{fig:qafny-state}
\end{figure}

\begin{figure}
{\small
{\hspace*{-6em}
\begin{minipage}[t]{0.4\textwidth}
\begin{center}
 \[
  \begin{array}{l@{~}cl}
  \tnor{\infty} &\sqsubseteq_n& \tch{\infty}\\
  \tnor{c} &\sqsubseteq_n& \tch{\{c\}}\\
  \tch{\overline{c}(1)} &\sqsubseteq_n& \tnor{\overline{c}[0]}\\
  \thad{p} &\sqsubseteq_n& \tch{\{\tos{j}|j\in[0,2^n)\}(2^n)}\\
  \tch{\{0,1\}} &\sqsubseteq_1& \thad{\infty}\\
  \tch{p} &\sqsubseteq_n& \tch{\infty}
    \end{array}
  \]
\end{center}
\subcaption{Subtyping}
  \label{fig:qafny-subtype}
\end{minipage}
\qquad
\begin{minipage}[t]{0.45\textwidth}
\begin{center}
   \[
   \begin{array}{l@{~}cl}
  \ket{c} &\equiv_n& \sch{1}{ }{c}\\
  \sch{1}{z_j}{c_j} &\equiv_n& \ket{c_0}\\
  \shad{2^n}{n}{\alpha(r_j)} &\equiv_n& \sch{2^n}{\frac{\alpha(\sum_{k=0}^{n} r_k \cdot \tos{j}[k])}{\sqrt{2^n}}}{j}\\
  \sch{2}{z_j}{c_j} &\equiv_1& \shad{2}{1}{\frac{\sqrt{2}z_1}{z_0}}\\
   &&\qquad\texttt{when }c_0=0\;\;c_1=1
    \end{array}
 \]
\end{center}
\subcaption{State Equivalence}
  \label{fig:qafny-sequiv}
\end{minipage}
  \caption{\qafny type/state relations. $\overline{c}[n]$ produces the $n$-th element in set $\overline{c}$. $\{\tos{j}|j\in[0,2^n)\}(2^n)$ defines a set $\{\tos{j}|j\in[0,2^n)\}$ with the emphasis that it has $2^n$ elements. $\{0,1\}$ is a set of two single element bitstrings $0$ and $1$. $\cdot$ is the multiplication operation, $\tos{j}$ turns a number $j$ to a bitstring, $\tos{j}[k]$ takes the $k$-th element in the bitstring $\tos{j}$, and $\ket{j}$ is an abbreviation of $\ket{\tos{j}}$.}
  \label{fig:qafny-eq}
}
}
\end{figure}

The \qafny element component syntax is represented according to the grammar in \Cref{fig:qafny-state}. 
In \qafny, there are three kinds of values, two of which are classical ones represented by the two modes: $\cmode$ and $\mmode$.
The former represents classical values, represented as a natural number $n$, that do not intervene with quantum measurements and are evaluated in the compilation time, the latter represents values, represented as a pair $(r,n)$, produced from a quantum measurement. The real number $r$ is a characteristic representing the theoretical probability of the measurement resulting in the value $n$.
Any classical arithmetic operation does not change $r$, i.e., $(r,n)+m=(r,n+m)$. 

Quantum variables are defined as kind $\qmode{n}$, where $n$ is the number of qubits in a variable representing as a qubit array. Quantum values are more often to be described as sessions ($\lambda$) that can be viewed as clusters of possibly entangled qubits, where the number of qubits is exactly the session length, i.e., $\slen{\overline{x[n..m]}}$.
Each session consists of different disjoint ranges, connected by the $\uplus$ operation (meaning that different ranges are disjoint), represented as $x[n..m]$ that refers the number range $[n,m)$ in a quantum array named $x$. For simplicity, we assume that different variable names referring to different quantum arrays without aliasing. Sessions have associated equational properties. They are associative and identitive with the identity operation as $\bot$. There are another two equational properties for sessions below:

{\small
\[n \le j < m \Rightarrow x[n,m]\uplus\lambda \equiv_{\lambda} x[n,j]\uplus x[j,m] \uplus\lambda
\qquad 
x[n,n] \equiv_{\lambda} \bot
\]
}

Each length-$n$ session is associated to a quantum state that can be one of the three forms ($q$ in \Cref{fig:qafny-state}) that are corresponding to three different types ($\tau$ in \Cref{fig:qafny-state}). The first kind of state is of \texttt{Nor} type ($\tnor{(\topt{c})}$), having the state form $\ket{c}$, which is a computational basis value. $c$ is of length $n$ and represents a tensor product of qubits, all being $0$ or $1$. The second kind of state is of \texttt{Had} type ($\thad{(\topt{\bigcirc})}$),  meaning that qubits in such session are in superposition but not entangled.
The state form is $\shad{2^n}{n}{\alpha(r_j)}$, where $\alpha(r_j)$ is a local phase for the $j$-th qubit in the session. If $r_j=0$ for all $j$, the state can be represented by  type $\thad{\bigcirc}$ representing a uniformly distributed superposition; otherwise, we represent the type as $\thad{\infty}$. The third kind of state is of $\texttt{CH}$ type ($\tch{(\topt{\overline{c}(m)})}$), having the state form $\sch{m}{z_j}{c_j}$, referring to that qubits in such session are possibly entangled. The state $\sch{m}{z_j}{c_j}$ can be viewed as an $m$ element set of pairs $z_j\ket{c_j}$, where $z_j$ and $c_j$ are the $j$-th amplitude and basis.
The well-formed restrictions for the state are three: 1) $\sum_{j=0}^{m}|z_j|^2=1$ ($z_j$ is a complex number); 2) length of $c_j$ is $n$ for all $j$ and $m \le 2^n$; 3) any two bases $c_j$ and $c_k$ are distinct if $j \neq k$.

In \qafny, the quantum types and states are associated through bases and equational properties.
For each quantum state $q$, especially for \texttt{Nor} type state $\ket{c}$ and \texttt{CH} type state $\sch{m}{z_j}{c_j}$, the type factors are either $\infty$ meaning no bases can be tracked, or having the form $c$ and $\overline{c}(m)$ that track the bases of the state $\ket{c}$ and $\sch{m}{z_j}{c_j}$, respectively. For \texttt{Nor} type, this means that the type factor $c$ (in $\tnor{c}$) and the state qubit format $\ket{c}$ must be equal; for \texttt{CH} type ($\tch{\overline{c}(m)}$), if the state is $\sch{m}{z_j}{c_j}$, the $j$-th element $\overline{c}[j]$ is equal to $c_j$.
Additionally, \qafny types permit subtyping relations that correspond to state equivalent relations in \Cref{fig:qafny-eq}. 
Both subtype relation $\sqsubseteq_n$ and state equivalence relation $\equiv_n$ are parameterized by a session length number $n$, such that they establish relations between two quantum states describing a session of length $n$.
$\sqsubseteq_n$ in \Cref{fig:qafny-subtype} describes a type term on the left can be used as a type on the right. For example, a \texttt{Nor} type qubit array $\tnor{c}$ can be used as a single element entanglement type term $\tch{\{c\}}$ \footnote{If a qubit array only consists of $0$ and $1$, it can be viewed as an entanglement of unique possibility. }. 
Correspondingly, state equivalence relation $\equiv_n$ describes the two state forms to be equivalent; specifically, the left state term can be used as the right one, e.g., a single element entanglement state $\sch{1}{z_j}{c_j}$ can be used as a \texttt{Nor} type state $\ket{c_0}$ with the fact that $z_0$ is now a global phase that can be neglected.

\subsection{Syntax}

\begin{figure}[t]
{
  \small
  \[\begin{array}{llcl} 
      \text{\oqasm Expr} & \mu\\
      \text{Parameter} & l & ::= & x \mid x[a] \\
      \text{Arith Expr} & a & ::= & x \mid n \mid (r,n) \mid a + a \mid a * a \mid ... \\
      \text{Bool Expr} & b & ::= & x[a] \mid (a = a) @ x[a] \mid (a < a) @ x[a] \mid ... \\
      \text{Gate Expr} & op & ::= & \texttt{H} \mid \iqft[\lbrack -1 \rbrack]{}{} \\
      \text{C/M Moded Expr}& e & ::= & a \mid \sinit{a} \mid \smea{y}  \\
                           && \mid & \textcolor{red}{\sret{y,(r,n)}} \\
      \text{Statement} & s & ::= & \sskip \mid \sexp{x}{e}{s} \mid  \ssassign{l}{}{op} \mid \ssassign{\lambda}{}{\mu} 
                                 \\ & & \mid & \sseq{s}{s} \mid \sifq{b}{s} \mid
                                     \sqwhile{\sint{x}{a_1}}{x<a_2}{b}{\dplus{x}}{s}
                     \\&&\mid & \ssassign{x}{}{\samp{a}}
                      \mid \ssassign{l}{}{\sdis}
    \end{array}
  \]
}
  \caption{Core \qafny syntax. \oqasm is in \Cref{sec:vqir}. For an operator \texttt{OP}, $\texttt{OP}^{\lbrack -1 \rbrack}$ indicates that the operator has a built-in inverse available. Arithmetic expressions are only used for classical operations, while Boolean expressions are used for both classical and quantum operations. $x[a]$ represents the $a$-th element in the qubit array $x$, while a quantum variable $x$ represents the whole qubit array. }
  \label{fig:vqimp}
\end{figure}

The \qafny program operations in \Cref{fig:vqimp} are designed based on separations of different functionality instead of quantum gates in many other languages. A program consists of a sequence of C-like statements $s$.
The first row in \Cref{fig:vqimp} are the classical and quantum data-flow operations.
$\sskip$ is a SKIP operation. The let operation ($\sexp{x}{e}{s}$) introduces a new variable $x$ with its initial value defined $e$ and used in $s$. If $e$ is an arithmetic expression ($a$), it introduces a $\cmode$ or $\mmode$ classical variable. For simplicity, we assume that we only interacts a $\mmode$ value with a $\cmode$ one in a binary arithmetic operation, i.e., the $(r_1,n_1)+(r_2,n_2)$ is disallowed in \qafny. $\sexp{x}{\sinit{a}}{s}$ initializes an $a$-length qubit array named $x$ with the value $\ket{0}^{\otimes a}$ \footnote{$\ket{0}^{\otimes n}$ means $\ket{\underbrace{00...0}_\text{n}}$.}, and is used in statement $s$, while
$\sexp{x}{\smea{y}}{s}$ measures quantum qubit array $y$, stores the result in $x$ an $a$-length qubit array named $x$ and is used in $s$.
The measurement turns the expression $\smea{y}$ to a ghost expression $\sret{y,(r,n)}$, which does not appear in a \qafny source program but appears during semantic evaluation, and it records the intermediate measurement result of qubit array $y$ as $(r,n)$.
$\ssassign{l}{}{op}$ is a quantum state preparation operation that prepares superposition of quantum qubits $l$ through Hadamard gates $\texttt{H}$ or $\texttt{QFT}$ gates. It is also used to transform quantum qubit states by a $\texttt{QFT}^{-1}$ gate in the end of the quantum phase estimation algorithm. 
We only permit $op$ to be \texttt{H} and $\iqft[\lbrack -1 \rbrack]{}{}$ gates.
The other gate applications are done through $\ssassign{\lambda}{}{\mu}$ that performs quantum oracle computation, such as quantum arithmetic operation. While let operation only performs classical arithmetic computation, quantum oracle arithmetic operation is performed through \oqasm expressions \cite{oracleoopsla}, which can be used to define most reversible arithmetic operations such as the ones in \Cref{fig:vqimp}. 
For example, the Shor's algorithm implementation in \Cref{fig:shorexample} utilizes the modulo multiplication operation $a^(2^i) * y mod N$ on qubit array $y$, which can be expressed as an \oqasm circuit.
A syntactic restriction is placed on $\ssassign{\lambda}{}{\mu}$, such that the session $\lambda$ represents the exact quantum qubits mentioned in expression $\mu$. 

The second row of statements in \Cref{fig:vqimp} are control-flow operations.
$\sseq{s_1}{s_2}$ is a sequential operation.
$\sifq{b}{s}$ is a conditional and $b$ might contain quantum parameter.
Every quantum parameter $l$ appearing in $b$ must not appear in $s$.
In the \qafny type system, we define a \texttt{well\_formed} predicate to check such property.
Apparently, quantum gate applications are essentially reversible. The reversibility requires that a Boolean equality and inequality expression to be written as $(a_1 = a_2) @ x[a]$ and $(a_1 < a_2) @ x[a]$, respectively; where we have an additional bit $x[a]$ to hold the result of computing $a_1=a_2$ or $a_1<a_2$.
$\sqwhile{\sint{x}{a_1}}{x<a_2}{b}{\dplus{x}}{s}$ is a possibly quantum for-loop depending on if the Boolean guard $b$ contains quantum parameters.
A classical variable $x$ is introduced and it is initialized as the lower bound $a_1$, increments in each loop step defined by $\dplus{x}$, and ends at the upper bound $a_2$.
In \qafny implementation, $\dplus{x}$ and $x<a_2$ can be arbitrary monotonic increment and comparison functions.
For simplicity, we restrict the two to be $\dplus{x}$ and $x<a_2$.

The last row contains quantum reflection operations, including quantum amplifier ($\ssassign{x}{}{\samp{a}}$) and diffusion operation ($\ssassign{l}{}{\sdis}$), which are used to increase and average the occurrence likelihood of some quantum bases in a quantum state, respectively. For example, if a session $x[0,n]\uplus \lambda$ has a \texttt{CH} type state $\sch{m}{z_j}{c_j}$, $c_k=\tos{a}\uplus c$, and $\slen{\tos{a}}=n$; then, $\ssassign{x}{}{\samp{a}}$ increases the amplitude $z_k$ for $c_k$.
%For example, in Grover's search algorithm \cite{grover1996},
%the Grover's diffusion operation is a quantum reflection
%that increases the occurrence probability of a target quantum state in a qubit array being in superposition.
%We identify two kinds of quantum reflections that previous works tent to combine together.
%The first one is an amplifier ($\samplify{\ssassign{x}{}{a}}$)
%that amplifies the occurrence probability of the target state,
%which is represented by a classical value $a$,
%in a quantum qubit array $x$.
%The second one is a diffusion operator ($\sdistr{x}$)
%that diffuses the state of a qubit array $x$ to a superposition of 
%all possible bases in $x$ with possibly different amplitudes \footnote{The possible bases do not depend on $x$'s state, and it is only related to the qubit size of $x$; i.e., if $x$ is a two qubit array, then the operation reflects the superposition of all possible two qubit states as: $\frac{1}{2}(\ket{00}+\ket{01}+\ket{10}+\ket{11})$.  }.
%For example, applying the diffusion operator on a two-qubit array $x$ having state $\ket{00}$
%results in a superposition of $-\frac{1}{2}\ket{00}+\frac{1}{2}\ket{01}+\frac{1}{2}\ket{10}+\frac{1}{2}\ket{11}$.
%In general, if an $n$-qubit array $x$ has the state $\sum_{j=0}\alpha_j\ket{x_j}$,
%the result of applying a diffusion operator is $\frac{1}{2^{n}}(2\sum_{i=0}^{2^n}(\sum_{j=0}\alpha_j)\ket{i} - %\sum_{j=0}\alpha_j\ket{x_j})$.


\subsection{Type Checking: A Quantum Session Type System}\label{sec:typesystem}

\begin{figure}
{\small
\begin{center}
 \[
  \begin{array}{r@{~}c@{~}l@{~}cl}
  &&\{\bot:\tau\} \cup \sigma &\preceq& \sigma\\
  \tau\sqsubseteq_{\slen{\lambda}}\tau' &\Rightarrow& \{\lambda:\tau\} \cup \sigma &\preceq& \{\lambda:\tau'\} \cup \sigma\\
  &&\{\lambda_1\uplus l_1 \uplus l_2 \uplus \lambda_2 :\tau\} \cup \sigma &\preceq& \{\lambda_1\uplus l_2 \uplus l_1 \uplus \lambda_2 : \texttt{mut}(\tau,\slen{\lambda_1})\} \cup \sigma\\
  &&\{\lambda_1 :\tau_1\} \cup \{\lambda_2 :\tau_2\} \cup \sigma &\preceq& \{\lambda_1 \uplus \lambda_2 :\texttt{mer}(\tau_1,\tau_2)\} \cup \sigma \\
  \texttt{spt}(\tau,\slen{\lambda_1})=(\tau_1,\tau_2)&\Rightarrow&\{\lambda_1 \uplus \lambda_2 :\tau\} \cup \sigma &\preceq& \{\lambda_1 :\tau_1\} \cup \{\lambda_2 :\tau_2\} \cup \sigma
    \end{array}
  \]
\end{center}
{\footnotesize
\[
\begin{array}{l}
\texttt{pmut}((c_1.i_1.i_2.c_2),n)=(c_1.i_2.i_1.c_2) \;\;\texttt{when}\;\slen{c_1}=n
\\
\texttt{mut}(\tnor{c},n)=\tnor{\texttt{pmut}(c,n)}
\qquad
\texttt{mut}(\tch{\overline{c}(m)},n)=\tch{\{\texttt{pmut}(c,n)|c\in\overline{c}(m)\}(m)}
\qquad
\texttt{mut}(\tau,n)=\tau\;\;[\texttt{owise}]
\\
\texttt{mer}(\tnor{c_1},\tnor{c_2})=\tnor{(c_1.c_2)}
\qquad
\texttt{mer}(\thad{\bigcirc},\thad{\bigcirc})=\thad{\bigcirc}
\qquad
\texttt{mer}(T\;\infty,T\;t)=T\;\infty
\\
\texttt{mer}(\tch{\overline{c_1}(m_1)},\tch{\overline{c_2}(m_2)})=\tch{(\overline{c_1}\times \overline{c_2})(m_1*m_2)}
\\
\texttt{spt}(\tnor{c_1.c_2},n)=(\tnor{c_1},\tnor{c_2}) \;\;\texttt{when}\;\slen{c_1}=n
\qquad
\texttt{spt}(\thad{t},n)=(\thad{t},\thad{t})
\\
\texttt{spt}(\tch{\{c_j.c|j\in [0,m)\wedge |c_j|=n\}(m)},n)=(\tch{\{c_j|j\in [0,m)\wedge |c_j|=n\}(m)},\tnor{c})
\end{array}
\]
}
\caption{Type environment partial order. We use set union ($\cup$) to describe the type environment concatenation with the empty set operation $\emptyset$. $i$ is a single bit either $0$ or $1$. The $.$ operation is bitstring concatenation. $\times$ is the Cartesian product of two sets.
$T$ is either $\texttt{Nor}$, $\texttt{Had}$ or $\texttt{CH}$. }
  \label{fig:env-equiv}
}
\end{figure}

\begin{figure}[t]
{
{\Small
  \begin{mathpar}
    \inferrule[TPar]{\sigma \preceq \sigma' \\ \Omega,\sigma' \vdash_g s \triangleright \sigma''}{\Omega,\sigma \vdash_g s \triangleright \sigma'' }

    \inferrule[TEXP]{\Omega[x\mapsto \cmode],\sigma\vdash_g s[n/x] \triangleright \sigma'}{\Omega,\sigma \vdash_g \sexp{x}{n}{s} \triangleright \sigma' }

    \inferrule[TMEA]{ \Omega(y)=\qmode{j} \\ \sigma(y) = \{y[0..j]\uplus\lambda\mapsto \tau \}
     \\\\ \Omega[x\mapsto \mmode],\sigma[\lambda \mapsto \tch{\infty}]\vdash_{\cmode} s \triangleright  \sigma'}{\Omega,\sigma \vdash_{\cmode} \sexp{x}{\smea{y}}{s} \triangleright \sigma' }

    \inferrule[TA-CH]{ FV(\mu)=\lambda\\ \sigma(\lambda\uplus\lambda') = \tch{\overline{c}(m)}\\\\
  \overline{c'}=\{(\llbracket \mu \rrbracket c_1).c_2\;\bm{|}\;c_1.c_2\in\overline{c}\wedge\slen{c_1}=\slen{\lambda}\}}{\Omega,\sigma \vdash_g \ssassign{\lambda}{}{\mu} \triangleright \{\lambda\uplus\lambda':\tch{\overline{c'}(m)}\} }

    \inferrule[TMEA-N]{ \Omega(y)=\qmode{j} \\ \overline{c'}=\{c_2\;\bm{|}\;\tos{n}.c_2\in\overline{c}\wedge\slen{\tos{n}}=j\}
     \\\\ \Omega[x\mapsto \mmode],\sigma[\lambda \mapsto \tch{\overline{c'}(\slen{\overline{c'}})}]\vdash_{\cmode} s \triangleright  \sigma'}{\Omega,\sigma[y[0..j]\uplus\lambda\mapsto \tch{\overline{c}(m)}] \vdash_{\cmode} \sexp{x}{\sret{y,(r,n)}}{s} \triangleright \sigma' }

    \inferrule[TSEQ]{\Omega,\sigma\vdash_g s_1 \triangleright\sigma_1
 \\\\\Omega,\sigma[\uparrow \sigma_1]\vdash_g s_2 \triangleright\sigma_2}{\Omega,\sigma \vdash_g \sseq{s_1}{s_2}\triangleright \;\sigma_2\cup\sigma_1|_{\not\in\dom{\sigma_2}} }

    \inferrule[TLOOP]{ \forall j\in[n_1,n_2)\;.\;\Omega,\sigma[\uparrow \sigma'[j/x]]\vdash_g \sifq{b}{s} \triangleright \sigma'[\texttt{S}\;j/x] }
                  {\Omega,\sigma \vdash_g \sqwhile{\sint{x}{n_1}}{x<n_2}{b}{\dplus{x}}{s} \triangleright \sigma'[n_2/x]}


\inferrule[TIF]{ 
FV(b@x[j])=\lambda\uplus x[j,\texttt{S}\;j]\\
FV(b@x[j])\cap FV(s) =\emptyset \\\\
\sigma(\lambda\uplus x[j,\texttt{S}\;j]\uplus \lambda_1)=\tch{\overline{c}(m)}
\\
     \Omega,\sigma \vdash_{\mmode} s \triangleright \{\lambda\uplus x[j,\texttt{S}\;j]\uplus \lambda_1:\tch{\overline{c'}(m)}\}} 
{\Omega,\sigma \vdash_g \sifq{b@x[j]}{s} \triangleright \{\lambda\uplus x[j,\texttt{S}\;j]\uplus \lambda_1:\tch{\overline{c''}(m)}\} }

  \end{mathpar}
}
{\footnotesize
\[
\begin{array}{l}
\overline{c''}=\{\tos{n}.1.c_2\;\bm{|}\;\tos{n}.d.c_1 \in \overline{c} \wedge \tos{n}.d.c_2 \in \overline{c'} \wedge b[\tos{n}/\lambda] \oplus d \wedge \slen{\tos{n}}=\slen{\lambda} \}
\\ \qquad\quad \cup \{\tos{n}.0.c_1\;\bm{|}\; \tos{n}.d.c_1 \in \overline{c} \wedge \neg (b[\tos{n}/\lambda] \oplus d) \wedge \slen{\tos{n}}=\slen{\lambda} \}
\\
\sigma[\uparrow \sigma'] = \sigma[\forall \lambda:\tau \in \sigma'\;.\;\tau/\lambda]
\\
\sigma|_{\not\in\dom{\sigma'}}=\{\lambda:\tau|\lambda \not\in \dom{\sigma'}\}

\end{array}
\]
}
}
  \caption{\qafny type system. $\llbracket \mu \rrbracket c$ is the \oqasm semantics of interpreting reversible expression $\mu$ in \Cref{fig:deno-sem}. Boolean expression $b$ can be $a_1=a_2$, $a_1 < a_2$ or \texttt{true}. $b[\tos{n}/\lambda]$ means that we treat $b$ as a \oqasm $\mu$ expression, replace qubits in array $\lambda$ with bits in bitstring $\tos{n}$, and evaluate it to a Boolean value.
$\sigma(y)=\{\lambda\mapsto \tau\}$ produces the map entry $\lambda\mapsto \tau$ and the range $y[0..\slen{y}]$ is in $\lambda$.
$\sigma(\lambda)=\tau$ is an abbreviation of $\sigma(\lambda)=\{\lambda\mapsto \tau\}$. $FV(-)$ produces a session by union all qubits appearing in $-$.}
  \label{fig:exp-sessiontype}
\end{figure}

In \qafny, typing is with respect to a \emph{kind environment} $\Omega$ and a \emph{finite type environment} $\sigma$,
which map \qafny variables to kinds and map sessions to types, respectively.
The typing judgment is written as $\Omega; \sigma\vdash_{g} s \triangleright \sigma'$,
which states that statements $s$ is well-typed under the context mode $g$ and environments $\Omega$ and $\sigma$,
the sessions representing $s$ is exactly the domain of $\sigma'$ as $\dom{\sigma'}$,
and $s$ transforms types for the sessions in $\sigma$ to types in $\sigma'$.
$\Omega$ describes the kinds for all program variables.
$\Omega$ is populated through \texttt{let} expressions that introduce variables,
and the \qafny type system enforces variable scope; such enforcement is neglected in \Cref{fig:exp-sessiontype} for simplicity.
We also assume that variables introduced in \texttt{let} expressions are all distinct through proper alpha conversions.
$\sigma$ and $\sigma'$ describe types for sessions referring to possibly entangled quantum clusters pointed to by quantum variables in $s$. 
$\sigma$ and $\sigma'$ are both finite and the domain of them contain sessions that do not overlap with each other; $\dom{\sigma}$ is large enough to describe all sessions pointed to by quantum variables in $s$,
while $\dom{\sigma'}$ should be the exact sessions containing quantum variables in $s$.
We have partial order relations defined for type environments in \Cref{fig:env-equiv}, which will be explained shortly.
Selected type rules are given in \Cref{fig:exp-sessiontype}; 
the rules not mentioned are similar and listed in \Cref{sec:qafny-app}.

The type system enforces five invariants.  First, well-formed and context restrictions for quantum programs.
Well-formedness means that qubits mentioned in the Boolean guard of a quantum conditional cannot be accessed in the conditional body,
while context restriction refers to the fact that the quantum conditional body cannot create (\texttt{init}) and measure (\texttt{measure}) qubits. 
For example the $FV$ checks in rule \textsc{TIF} enforces that the session for the Boolean and the conditional body does not overlap.
Coincidentally, we utilize the modes ($g$, either $\cmode$ or $\mmode$) as context modes for the type system. 
Context mode $\cmode$ permits most \qafny operations. Once a type rule turns a mode to $\mmode$, such as in the conditional body in rule \textsc{TIF}, we disallow \texttt{init} and \texttt{measure} operations. For example, rules \textsc{TMEA} and \textsc{TMEA-N} are valid only if the input context mode is $\cmode$.

Second, the type system tracks the basis state of every qubit in sessions. In rule \textsc{TA-CH}, we find that the oracle $\mu$ is applied on $\lambda$ belonging to a session $\lambda \uplus \lambda'$. Correspondingly, the session's type is $\tch{\overline{c}(m)}$, for each bitstring $c_1.c_2\in \overline{c}$, with $\slen{c_1}=\slen{\lambda}$, we apply $\mu$ on the $c_1$ and leave $c_2$ unchanged.
Here, we utilize the \oqasm semantics that describes transitions from a $\texttt{Nor}$ state to another $\texttt{Nor}$ one, and we generalize it to apply the semantic function on every element in the \texttt{CH} type.
During the transition, the number of elements $m$ does not change.
Similarly, applying a partial measurement on range $y[0..j]$ of the session $y[0..j]\uplus\lambda$ in rule \textsc{TMEA-N}
can be viewed as a array filter, i.e., for an element $c_1.c_2$ in set $\overline{c}$ of the type $\tch{\overline{c}(m)}$, with $\slen{c_1}=j$, we keep only the ones with $c_1=\tos{n}$ ($n$ is the measurement result) in the new set $\overline{c'}$ and recompute $\slen{\overline{c'}}$. In \qafny, the tracking procedure is to generate symbolic predicates that permit the production of the set $\overline{c'}(\slen{c'})$, not to actually produce such set. If the predicates are not not effectively trackable, we can always use $\infty$ to represent the set.


\liyi{may be we can add a rule about turning NOR to HAD so that we can say that the subtyping casting is also useful. }
Third, the type system enforces equational properties of 
quantum qubit sessions through a partial order relation over type environments, including subtyping, qubit position mutation, merge and split quantum sessions.
Essentially, we can view two qubit arrays be equivalent if there is a bijective permutation on the qubit positions of the two.
To analyze a quantum application on a qubit array, if the array is arranged in a certain way, the semantic definition will be a lot more trivial than other arrangements. For example, in applying a quantum oracle to a session (rule \textsc{TMEA}), we fix the qubits that permits the $\mu$ operation to always live in the front part ($\lambda$ in $\lambda\uplus\lambda'$).
This is achieved by a consecutive application of the mutation rule ($\texttt{mut}$) in the partial order ($\preceq$) in \Cref{fig:env-equiv}, which casts the left type environment to the format on the right through rule \textsc{TPar}.
Similarly, split ($\texttt{spt}$) and combination ($\texttt{mer}$) of sessions in \Cref{fig:env-equiv} are useful to describe some quantum operation behaviors. the split of a quantum session into two represents the process of disentanglement of quantum qubits.
For example, $\ket{00}+\ket{10}$ can be disentangled as $(\ket{0}+\ket{1})\otimes \ket{0}$.
The \texttt{spt} function is a partial one since disentanglement is considered to be a hard problem and it is usually done through case analyses as the ones in \Cref{fig:env-equiv}.
Merging two sessions is valuable for analyzing the behavior of quantum conditionals.
In rule \textsc{TIF}, the session ($\lambda_1\uplus x[j,\texttt{S}\;j]$) for the Boolean guard ($b@x[j]$)
 and the session for ($\lambda_2$) the body can be two separative sessions. 
Here, we first merge the two session through the $\texttt{mer}$ rule in \Cref{fig:env-equiv} by computing the Cartesian product of the two type bases, such that if the two sessions are both \texttt{CH} types $\lambda_1\uplus x[j,\texttt{S}\;j]\mapsto\tch{\overline{c_1}(m_1)}$ and $\lambda_2\mapsto\tch{\overline{c_2}(m_2)}$, the result is of type $\tch{(\overline{c_1}\times \overline{c_2})(m_1*m_2)}$. 
After that, the quantum conditional behavior can be understood as applying a partial map function on the size $m_1*m_2$ array of bitstrings, and we only apply the conditional body's effect on the second part (the $\overline{c_2}$ part) of some bitstrings whose first part is checked to be true by applying the Boolean guard $b$. 
\liyi{see how to merge the following to above}
Based on the new \texttt{CH} type with the set $\overline{c_1}\times \overline{c_2}$,
the quantum conditional creates a new set based on $\overline{c_1}\times \overline{c_2}$, i.e., for each element $\tos{n}.d.c$ in the set, with $\slen{\tos{n}}=\slen{\lambda_1}$, we compute Boolean guard $b$ value by substituting qubit variables in $b$ with the bitstring $\tos{n}$, and the result $b[\tos{n} / \lambda_1] \oplus d$ is true or not ($d$ represents the bit value for the qubit at $x[j,\texttt{S}\;j]$); if it is true, we replace the $c$ bitstring by applying the conditional body on it; otherwise, we keep $c$ to be the same.
In short, the quantum conditional behavior can be understood as applying a partial map function on an $m$ array of bitstrings, and we only apply the conditional body's effect on the second part of some bitstrings whose first part is checked to be true by applying the Boolean guard $b$.

Fourth, the type system enforces that the $\cmode$ classical variables can be evaluated to values in the compilation time. \footnote{We consider all computation that only needs classical computer is done in the compilation time.}, while tracks $\mmode$ variables which represent the measurement results of quantum sessions. Rule \textsc{TEXP} enforces that a classical variable $x$ is replaced with its assignment value $n$ in $s$. The substitution statement $s[n/x]$ also evaluates classical expressions in $s$, which is described in \Cref{sec:qafny-app}.
In measurement rules (\textsc{TMEA} and \textsc{TMEA-N}), we apply some gradual typing techniques.
There is an ghost expression $\texttt{ret}$ generated from one step evaluation of the measurement.
Before the step evaluation, rule \textsc{TMEA} types the partial measurement results as a classical $\mmode$ mode variable $x$ and a possible quantum leftover $\lambda$ as $\tch{\infty}$.
After the step is transitioned, we know the exact value for $x$ as $(r,n)$, so that we carry the result to type $\lambda$ as $\tch{\overline{c'}(\slen{\overline{c'}})}$. This does not violate type preservation because we have the subtyping relation $\tch{\overline{c'}(\slen{\overline{c'}})} \sqsubseteq_{\slen{\lambda}} \tch{\infty}$.

Finally, the type system extracts the result type environment of a for-loop as $\sigma'[n_2/x]$ based on the extraction of a type environment invariant on the $i$-th loop step of executing a conditional $\sifq{b}{s}$ in rule \textsc{TLOOP}, regardless if the conditional is classical or quantum. 

\subsection{\qafny Semantics and Type Soundness}\label{sec:semantics}

\begin{figure}
{\small
\begin{center}
 \[
  \begin{array}{r@{~}c@{~}l@{~}cl}
  &&\{\bot:\tau\} \cup \sigma &\preceq& \sigma\\
  \tau\sqsubseteq_{\slen{\lambda}}\tau' &\Rightarrow& \{\lambda:\tau\} \cup \sigma &\preceq& \{\lambda:\tau'\} \cup \sigma\\
  &&\{\lambda_1\uplus l_1 \uplus l_2 \uplus \lambda_2 :\tau\} \cup \sigma &\preceq& \{\lambda_1\uplus l_2 \uplus l_1 \uplus \lambda_2 : \texttt{mut}(\tau,\slen{\lambda_1})\} \cup \sigma\\
  &&\{\lambda_1 :\tau_1\} \cup \{\lambda_2 :\tau_2\} \cup \sigma &\preceq& \{\lambda_1 \uplus \lambda_2 :\texttt{mer}(\tau_1,\tau_2)\} \cup \sigma \\
  \texttt{spt}(\tau,\slen{\lambda_1})=(\tau_1,\tau_2)&\Rightarrow&\{\lambda_1 \uplus \lambda_2 :\tau\} \cup \sigma &\preceq& \{\lambda_1 :\tau_1\} \cup \{\lambda_2 :\tau_2\} \cup \sigma
    \end{array}
  \]
\end{center}
{\footnotesize
\[
\begin{array}{l}
\texttt{pmut}((c_1.i_1.i_2.c_2),n)=(c_1.i_2.i_1.c_2) \;\;\texttt{when}\;\slen{c_1}=n
\\
\texttt{mut}(\tnor{c},n)=\tnor{\texttt{pmut}(c,n)}
\qquad
\texttt{mut}(\tch{\overline{c}(m)},n)=\tch{\{\texttt{pmut}(c,n)|c\in\overline{c}(m)\}(m)}
\qquad
\texttt{mut}(\tau,n)=\tau\;\;[\texttt{owise}]
\\
\texttt{mer}(\tnor{c_1},\tnor{c_2})=\tnor{(c_1.c_2)}
\qquad
\texttt{mer}(\thad{\bigcirc},\thad{\bigcirc})=\thad{\bigcirc}
\qquad
\texttt{mer}(T\;\infty,T\;t)=T\;\infty
\\
\texttt{mer}(\tch{\overline{c_1}(m_1)},\tch{\overline{c_2}(m_2)})=\tch{(\overline{c_1}\times \overline{c_2})(m_1*m_2)}
\\
\texttt{spt}(\tnor{c_1.c_2},n)=(\tnor{c_1},\tnor{c_2}) \;\;\texttt{when}\;\slen{c_1}=n
\qquad
\texttt{spt}(\thad{t},n)=(\thad{t},\thad{t})
\\
\texttt{spt}(\tch{\{c_j.c|j\in [0,m)\wedge |c_j|=n\}(m)},n)=(\tch{\{c_j|j\in [0,m)\wedge |c_j|=n\}(m)},\tnor{c})
\end{array}
\]
}
\caption{Semantic state equivalence. We use set union ($\cup$) to describe the type environment concatenation with the empty set operation $\emptyset$. $i$ is a single bit either $0$ or $1$. The $.$ operation is bitstring concatenation. $\times$ is the Cartesian product of two sets.
$T$ is either $\texttt{Nor}$, $\texttt{Had}$ or $\texttt{CH}$. }
  \label{fig:state-equiv}
}
\end{figure}

\begin{figure}[t]
{
{\Small
  \begin{mathpar}
    \inferrule[TPar]{\sigma \preceq \sigma' \\ \Omega,\sigma' \vdash_g s \triangleright \sigma''}{\Omega,\sigma \vdash_g s \triangleright \sigma'' }

    \inferrule[TEXP]{\Omega[x\mapsto \cmode],\sigma\vdash_g s[n/x] \triangleright \sigma'}{\Omega,\sigma \vdash_g \sexp{x}{n}{s} \triangleright \sigma' }

    \inferrule[TMEA]{ \Omega(y)=\qmode{j} \\ \sigma(y) = \{y[0..j]\uplus\lambda\mapsto \tau \}
     \\\\ \Omega[x\mapsto \mmode],\sigma[\lambda \mapsto \tch{\infty}]\vdash_{\cmode} s \triangleright  \sigma'}{\Omega,\sigma \vdash_{\cmode} \sexp{x}{\smea{y}}{s} \triangleright \sigma' }

    \inferrule[TA-CH]{ FV(\mu)=\lambda\\ \sigma(\lambda\uplus\lambda') = \tch{\overline{c}(m)}\\\\
  \overline{c'}=\{(\llbracket \mu \rrbracket c_1).c_2\;\bm{|}\;c_1.c_2\in\overline{c}\wedge\slen{c_1}=\slen{\lambda}\}}{\Omega,\sigma \vdash_g \ssassign{\lambda}{}{\mu} \triangleright \{\lambda\uplus\lambda':\tch{\overline{c'}(m)}\} }

    \inferrule[TMEA-N]{ \Omega(y)=\qmode{j} \\ \overline{c'}=\{c_2\;\bm{|}\;\tos{n}.c_2\in\overline{c}\wedge\slen{\tos{n}}=j\}
     \\\\ \Omega[x\mapsto \mmode],\sigma[\lambda \mapsto \tch{\overline{c'}(\slen{\overline{c'}})}]\vdash_{\cmode} s \triangleright  \sigma'}{\Omega,\sigma[y[0..j]\uplus\lambda\mapsto \tch{\overline{c}(m)}] \vdash_{\cmode} \sexp{x}{\sret{y,(r,n)}}{s} \triangleright \sigma' }

    \inferrule[TSEQ]{\Omega,\sigma\vdash_g s_1 \triangleright\sigma_1
 \\\\\Omega,\sigma[\uparrow \sigma_1]\vdash_g s_2 \triangleright\sigma_2}{\Omega,\sigma \vdash_g \sseq{s_1}{s_2}\triangleright \;\sigma_2\cup\sigma_1|_{\not\in\dom{\sigma_2}} }

    \inferrule[TLOOP]{ \forall j\in[n_1,n_2)\;.\;\Omega,\sigma[\uparrow \sigma'[j/x]]\vdash_g \sifq{b}{s} \triangleright \sigma'[\texttt{S}\;j/x] }
                  {\Omega,\sigma \vdash_g \sqwhile{\sint{x}{n_1}}{x<n_2}{b}{\dplus{x}}{s} \triangleright \sigma'[n_2/x]}


\inferrule[TIF]{ 
FV(b@x[j])=\lambda\uplus x[j,\texttt{S}\;j]\\
FV(b@x[j])\cap FV(s) =\emptyset \\\\
\sigma(\lambda\uplus x[j,\texttt{S}\;j]\uplus \lambda_1)=\tch{\overline{c}(m)}
\\
     \Omega,\sigma \vdash_{\mmode} s \triangleright \{\lambda\uplus x[j,\texttt{S}\;j]\uplus \lambda_1:\tch{\overline{c'}(m)}\}} 
{\Omega,\sigma \vdash_g \sifq{b@x[j]}{s} \triangleright \{\lambda\uplus x[j,\texttt{S}\;j]\uplus \lambda_1:\tch{\overline{c''}(m)}\} }

  \end{mathpar}
}
{\footnotesize
\[
\begin{array}{l}
\overline{c''}=\{\tos{n}.1.c_2\;\bm{|}\;\tos{n}.d.c_1 \in \overline{c} \wedge \tos{n}.d.c_2 \in \overline{c'} \wedge b[\tos{n}/\lambda] \oplus d \wedge \slen{\tos{n}}=\slen{\lambda} \}
\\ \qquad\quad \cup \{\tos{n}.0.c_1\;\bm{|}\; \tos{n}.d.c_1 \in \overline{c} \wedge \neg (b[\tos{n}/\lambda] \oplus d) \wedge \slen{\tos{n}}=\slen{\lambda} \}
\\
\sigma[\uparrow \sigma'] = \sigma[\forall \lambda:\tau \in \sigma'\;.\;\tau/\lambda]
\\
\sigma|_{\not\in\dom{\sigma'}}=\{\lambda:\tau|\lambda \not\in \dom{\sigma'}\}

\end{array}
\]
}
}
  \caption{\qafny type system. $\llbracket \mu \rrbracket c$ is the \oqasm semantics of interpreting reversible expression $\mu$ in \Cref{fig:deno-sem}. Boolean expression $b$ can be $a_1=a_2$, $a_1 < a_2$ or \texttt{true}. $b[\tos{n}/\lambda]$ means that we treat $b$ as a \oqasm $\mu$ expression, replace qubits in array $\lambda$ with bits in bitstring $\tos{n}$, and evaluate it to a Boolean value.
$\sigma(y)=\{\lambda\mapsto \tau\}$ produces the map entry $\lambda\mapsto \tau$ and the range $y[0..\slen{y}]$ is in $\lambda$.
$\sigma(\lambda)=\tau$ is an abbreviation of $\sigma(\lambda)=\{\lambda\mapsto \tau\}$. $FV(-)$ produces a session by union all qubits appearing in $-$.}
  \label{fig:exp-semantics}
\end{figure}



\ignore{
\begin{figure*}[t]
{\footnotesize
  \begin{mathpar}

    \inferrule[PA-NOR ]{(\itau ,\itau')\models_g (T,\ssassign{\overline{l}}{}{a},T'):\zeta\triangleright\ttype{n}{\tnor{\overline{d}}}}
                {\Omega\vdash_g\fivepule{T}{P[\llbracket a \rrbracket \zeta /\zeta] } {\ssassign{\overline{l}}{}{a}} {T'}{P}}


    \inferrule[PA-CH ]{(\itau,\itau')\models_g (T,\ssassign{\overline{l}}{}{a},T'):\zeta\uplus\zeta'\triangleright \ttype{n}{\tch{m}{\beta}}
                 \\ \itau(\overline{l})=\zeta}
       {\Omega\vdash_g\fivepule{T}{P[\forall k < m.\;\llbracket a \rrbracket(\zeta[k]) / \zeta[k]] } {\ssassign{\overline{l}}{}{a}}{T'}{P}}


    \inferrule[P-MEA ]{ (\itau[\forall \zeta'\;.\;\zeta\uplus\zeta' \mapsto \ttype{n+n'}{\tch{(m\times m')}{(\beta\cdot\beta')}}],\itau'[\forall \zeta'\;.\;\zeta' \mapsto \ttype{n'}{\tch{m'}{\beta'}}])\models_{\cmode} (T,y,T''):\zeta\triangleright \ttype{n}{\tch{m}{\beta}}
  \\ v < m \\
   \Omega[x\mapsto M,y\mapsto \bot]\vdash_{\cmode} \fivepule{T''}{P[(\iasa{2}{\zeta[v]},\ibs{\zeta[v]}) /x, \bot / \zeta] } {s} {T'}{Q} } {\Omega\vdash_{\cmode}\fivepule{T}{P}{\sexp{x}{\smea{y}}{s}}{T'}{Q}}

    \inferrule[P-IF ]{(\itau,\itau')\models_{\qmode} (T,s,T'):\zeta'\triangleright \ttype{n'}{\tch{m'}{\beta'}}
      \\\Omega\vdash b(@x[v]): \zeta\uplus[(x,v,v+1)] \\ \itau(\zeta\uplus[(x,v,v+1)])= \ttype{n}{\tch{2m}{(\beta_1\cdot 0 \cup \beta_2\cdot 1)}}
       }{\Omega\vdash_{g}\fivepule{T}{P[(\zeta\uplus 0 \uplus \zeta')\texttt{++}(\zeta\uplus 1 \uplus \llbracket s \rrbracket\zeta') /\zeta\uplus[(x,v,v+1)]\uplus\zeta'] }
      {\sifq{b(@x[v])}{s}}{T'}{P}}

    \inferrule[P-LOOP ]{(\itau,\itau')\models_g (T(i),\sifq{b(@x[i])}{s},T(f(i))):\zeta\triangleright \tau 
            \\ \Omega\vdash_g\fivepule{T(i)}{P(i)}{\sifq{x[i]}{s}}{T(f(i))}{P(f(i))} }
     {\Omega\vdash_g\fivepule{T(a_1)}{P(a_1) }{\sqwhile{\sinit{i}{a_1}}{i<a_2}{x[i]}{f(i)}{T(i)}{P(i)}{s}}{T(a_2)}{P(a_2)}}
    
    \inferrule[P-DIS ]{(\itau,\itau')\models_g (T,\sdistr{x},T'):\zeta\triangleright \ttype{n'}{\tch{m'}{\beta'}}
             \\ \itau(x)=\{\zeta:\ttype{n'}{\tch{m}{\beta}}\}
    \\\zeta = \zeta' \uplus (x,0,\Sigma(x))
    \\ \beta_1 \cdot \beta_2=\beta(\downarrow (x,0,\Sigma(x)))\cdot \beta(\downarrow \zeta') } 
           {\Omega\vdash_g\fivepule{T}{P[\texttt{dis}(n',\zeta,\beta,\beta_1,\beta_2) /\zeta] }
      {\sdistr{x}}{T'}{P}}


  \end{mathpar}
}
{\footnotesize
\[
\begin{array}{l}
\texttt{ln}(\zeta)\text{: length of }\zeta
\qquad
\texttt{as}(\zeta[v])\text{: the amplitude of }\zeta[v]
\qquad
\texttt{bs}(\zeta[v])\text{: the base of }\zeta[v]
\qquad
\texttt{++}\text{: array concatenation.}
\\
\texttt{dis}(n,\zeta,\beta,\beta_1,\beta_2)\equiv \{\frac{1}{2^{n-1}}(\sum_k \texttt{as}(\zeta[k])-\texttt{as}(\zeta[j]))\beta_1[j]
                           \;|\; \beta_1[j]\in \tpower{n} \}
\\
\qquad\qquad\qquad\qquad\qquad
\cup  \bigcup_{j\in \beta_2}\{\frac{1}{2^{n}}\sum_k \texttt{as}(\zeta[k])z
                           \;|\; z\in \tpower{n} \wedge (\forall k.\;z \cdot \beta_2[j] \neq \beta[k]) \}
\end{array}
\]
}
\caption{Selected Proof System Rules}
\label{fig:exp-proofsystem}
\end{figure*}
}
\subsection{Logic Proof System}\label{sec:logical}


The reason of having the session type system in \Cref{fig:exp-sessiontype}
is to enable the proof system given in \Cref{fig:exp-proofsystem}.
Every proof rule is a structure as $\Omega\vdash_g \fivepule{T}{P}{s}{T'}{Q}$,
where $g$ and $\Omega$ are the type entities mentioned in \Cref{sec:typesystem}.
$T$ and $T'$ are the pre- and post- type predicates for the statement $s$, 
meaning that there is type environments $\itau$ and $\itau'$, such that $\itau\models T$,
$\itau'\models T'$, $g,\Omega,\itau \vdash s : \zeta\triangleright \tau$, and $(\zeta\mapsto \tau) \in \itau'$.
We denote $(\itau,\itau')\models (T,s,T'):\zeta\triangleright\tau$ as the property described above.
$P$ and $Q$ are the pre- and post- Hoare conditions for statement $s$.

The proof system is an imitation of the classical Hoare Logic array theory.
We view the three different quantum state forms in \Cref{fig:vqir-state} as arrays with elements in different forms,
and use the session types to guide the occurrence of a specific form at a time.
Sessions, like the array variables in the classical Hoare Logic theory,
represent the stores of quantum states.
The state changes are implemented by the substitutions of sessions
with expressions containing operation's semantic transitions.
The substitutions can happen for a single index session element or the whole session.

Rule \text{PA-NOR} and \text{PA-CH} specify the assignment rules.
If a session $\zeta$ has type \texttt{Nor}, it is a singleton array,
so the substitution $\llbracket a \rrbracket \zeta /\zeta$ means
that we substitute the singleton array by a term with the $a$'s application.
When $\zeta$ has type \texttt{CH}, term $\zeta[k]$ refers to each basis state in the entanglement.
The assignment is an array map operation that applies $a$ to every element in the array.
For example, in \Cref{fig:shorexample} line 12,
we apply a series of \code{H} gates to array $x$.
Its post-condition is $[(x,0,n)]=\Motimes_{k=0}^{n}\ket{\Phi(0)}$,
where $[(x,0,n)]$ is the session representing register variable $x$.
Thus, replacing the session $[(x,0,n)]$ with the \code{H} application
results in a pre-condition as $\code{H}[(x,0,n)]=\Motimes_{k=0}^{n}\ket{\Phi(0)}$,
which means that $[(x,0,n)]$ has the state $\ket{0}^n$.

Rule \text{P-MEA} is the rule for partial/complete measurement.
$y$'s session is $\zeta$, but it might be a part of an entangled session $\zeta\uplus\zeta'$.
After the measurement, $M$-mode $x$ has the measurement result $(\ias{\zeta[v]}^2,\ibs{\zeta[v]})$ coming
from one possible basis state of $y$ (picking a random index $v$ in $\zeta$), 
$\ias{\zeta[v]}$ is the amplitude and $\ibs{\zeta[v]}$ is the base.
We also remove $y$ and its session $\zeta$ ($\bot/\zeta$) in the new pre-condition because it is measured away.
The removal means that the entangled session $\zeta\uplus\zeta'$ is replaced by $\zeta'$ 
with the re-computation of the amplitudes and bases for each term.

Rule \text{P-IF} deals with a quantum conditional where the Boolean guard $b(@x[v])$ is of type $\ttype{n}{\tch{2m}{(\beta_1\cdot 0 \cup \beta_2\cdot 1)}}$. The bases are split into two sets $\beta_1\cdot 0$ and $\beta_2\cdot 1$, where the last bit represents the base state for the $x[v]$ position.
In quantum computing, a conditional is more similar to an assignment, where we create a new array to substitute 
the current state represented by the session $\zeta\uplus[(x,v,v+1)]\uplus\zeta'$.
Here, the new array is given as $(\zeta\uplus 0 \uplus \zeta')\texttt{++}(\zeta\uplus 1 \uplus \llbracket s \rrbracket\zeta')$,
where we double the array: if the $x[v]$ position is $0$, we concatenate the current session $\zeta'$ for the conditional body,
if $x[v]=1$, we apply $\llbracket s \rrbracket$ on the array $\zeta'$ and concatenate it to $(\zeta\uplus 1)$.

Rule \text{P-Loop} is an initiation of the classical while rule in Hoare Logic with the loop guard possibly having quantum variables.
In QWhile, we only has \texttt{for-loop} structure and we believe it is enough to specify any current quantum algorithms.
For any $i$, if we can maintain the loop invariant $P(i)$ and $T(i)$ with the post-state $P(f(i))$ and $T(f(i))$
for a single conditional $\sifq{x[i]}{s}$, the invariant is maintained for multiple steps
for $i$ from the lower-bound $a_1$ to the upper bound $a_2$.

Rule \text{P-DIS} proves a diffusion operator $\sdistr{x}$.
The quantum semantics for $\sdistr{x}$ is $\frac{1}{2^{n}}(2\sum_{i=0}^{2^n}(\sum_{j=0}\alpha_j)\ket{i} - \sum_{j=0}\alpha_j\ket{x_j})$.
As an array operation, $\sdistr{x}$ with the session $\zeta$ is an array operation as follows:
assume that $\zeta=(x,0,\Sigma(x))\uplus\zeta_1$, for every $k$,
if $\zeta[k]$'s value is $\theta_k(\overline{d_x}\cdot \overline{d_1})$,
for any bitstring $z$ in $\tpower{\Sigma(x)}$, if $z\cdot \overline{d_1}$
is not a base for $\zeta[j]$ for any $j$, then the state is
$\frac{1}{2^{n-1}}\sum_{k=0}\theta_k(z\cdot \overline{d_1})$;
if the base of $\zeta[j]$ is $z\cdot \overline{d_1}$,
then the state for $\zeta[j]$ is $\frac{1}{2^{n-1}}(\sum_{k=0}\theta_k)-\theta_j(z\cdot \overline{d_1})$.







