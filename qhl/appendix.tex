\section{\oqasm: An Assembly Language for Quantum Oracles}
\label{sec:vqir}

\begin{figure}[t]
{\small
  \begin{lstlisting}[numbers=left,language=C++,xleftmargin=4 mm]
method Shor ( a : int, N : int, n : int, m : int, x : Q[n], y : Q[n] )
 requires (n > 0)
 requires (1 < a < N)
 requires (N < 2^(n-1))
 requires (N^2 < 2^m <= 2 * N^2)
 requires (gcd(a, N) == 1)
 requires ( type(x) = Tensor n (Nor 0))
 requires ( type(y) = Tensor n (Nor 0))
 ensures (gcd(N, r) == 1)
 ensures (p.pos >= 4 / (PI ^ 2))
{
  x *= H ;
  y *= cl(y+1); //cl can be omitted.
  for (int i = 0; i < n; x[i]; i ++)
    invariant (0 <= i <= n)
    invariant (saturation(x[0..i]))
    invariant (type(y,x[0..i]) = Tensor n (ch (2^i) {k | j baseof x[0..i] && k = (a^j mod N,j)}))
    //psum(k=b,M,p(k),b(k)) = sum_{k=b}^M p(k)*b(k)
    invariant ((y,x[0..i]) == psum(k=0,2^i,1,(a^k mod N,k))) 
  {
    y *= cl(a^(2^i) * y mod N);
  }

 M z := measure(y);//partial measurement, actually measure(y,r) r is the period
 x *= RQFT;
 M p := measure(x); //p.pos and p.base
 var r := post_period(m,p.base) // exists t. 2^m * t / r = p.base
}
  \end{lstlisting}
}
\caption{Shor's Algorithm in Q-Dafny}
\label{fig:shorexample}
\end{figure}

We designed \oqasm to be able to express efficient quantum
oracles that can be easily tested and, if desired, proved
correct.
\oqasm operations leverage both the standard
computational basis and an alternative basis connected by the quantum
Fourier transform (QFT). 
\oqasm's type system tracks the bases of variables in
\oqasm programs, forbidding operations that would introduce
entanglement. \oqasm states are therefore efficiently
represented, so programs can be effectively tested and are simpler to
verify and analyze. In addition, \oqasm uses \emph{virtual qubits}
to support \emph{position shifting operations}, which support
arithmetic operations without introducing extra gates during
translation. All of these features are novel to quantum assembly
languages. 

This section presents \oqasm states and the language's syntax,
semantics, typing, and soundness results.  As a running example, we use the QFT
adder~\cite{qft-adder} shown in \Cref{fig:circuit-example}. The Coq
function \coqe{rz_adder} generates an \oqasm program that adds two
natural numbers \coqe{a} and \coqe{b}, each of length \coqe{n} qubits.

\begin{figure*}[t]
  \centering
  \begin{tabular}{c @{\quad} c}
  \begin{minipage}[b]{.55\textwidth}
  % \includegraphics[width=1\textwidth]{qft-adder.png}
    \Small
    \Qcircuit @C=0.5em @R=0.75em {
      \lstick{\ket{a_{n-1}}} & \qw & \ctrl{5} & \qw & \qw & \qw & \qw & \qw & \qw & \qw & \rstick{\ket{a_{n-1}}} \\
      \lstick{\ket{a_{n-2}}} & \qw & \qw & \ctrl{4} & \qw & \qw & \qw & \qw & \qw & \qw & \rstick{\ket{a_{n-2}}}\\
      \lstick{\vdots} & & & & & & & & & & \rstick{\vdots} \\
      \lstick{} & & & & & & & & & & \\
      \lstick{\ket{a_0}} & \qw & \qw & \qw & \qw & \qw & \qw & \ctrl{1} & \qw & \qw & \rstick{\ket{a_0}} \\
      \lstick{\ket{b_{n-1}}} & \multigate{5}{\texttt{QFT}} & \gate{\texttt{SR 0}} & \multigate{3}{\texttt{SR 1}} & \qw & \qw & \qw & \multigate{5}{\texttt{SR (n-1)}} & \multigate{5}{\texttt{QFT}^{-1}} & \qw & \rstick{\ket{a_{n-1} + b_{n-1}}} \\
      \lstick{} & & & & & \dots & & & & \\
      \lstick{\ket{b_{n-2}}} & \ghost{\texttt{QFT}} & \qw  &  \ghost{\texttt{SR 1}} & \qw & \qw & \qw & \ghost{\texttt{SR (n-1)}} & \ghost{\texttt{QFT}^{-1}} & \qw & \rstick{\ket{a_{n-2} + b_{n-2}}} \\
      \lstick{\vdots} & & & & & & & & & & \rstick{\vdots} \\
      \lstick{} & & & & & & & & & & \\
      \lstick{\ket{b_0}} & \ghost{\texttt{QFT}} & \qw & \qw & \qw & \qw & \qw & \ghost{\texttt{SR (n-1)}} & \ghost{\texttt{QFT}^{-1}}  & \qw & \rstick{\ket{a_0 + b_0}} 
      }
  \subcaption{Quantum circuit}
  \end{minipage} &
  \begin{minipage}[b]{.35\textwidth}
  \begin{coq}
  Fixpoint rz_adder' (a b:var) (n:nat) 
    := match n with 
       | 0 => ID (a,0)
       | S m => CU (a,m) (SR m b); 
                rz_adder' a b m
       end.
  Definition rz_adder (a b:var) (n:nat) 
    := Rev a ; Rev b ; $\texttt{QFT}$ b ;
       rz_adder' a b n;
       $\texttt{QFT}^{-1}$ b; Rev b ; Rev a.
  \end{coq}
  \subcaption{\oqasm metaprogram (in Coq)}
  \end{minipage}
  \end{tabular}
  \vspace{-0.5em}
  \caption{Example \oqasm program: QFT-based adder}
  \label{fig:circuit-example}
  \end{figure*}

\subsection{\oqasm States} \label{sec:pqasm-states}

\begin{figure}[t]
  \small
  \[\hspace*{-0.5em}
\begin{array}{l>{$} p{1.2cm} <{$} c l}
      \text{Bit} & b & ::= & 0 \mid 1 \\
      \text{Natural number} & n & \in & \mathbb{N} \\
      \text{Real} & r & \in & \mathbb{R}\\
      \text{Phase} & \alpha(r) & ::= & e^{2\pi i r} \\
      \text{Basis} & \tau & ::= & \texttt{Nor} \mid \texttt{Phi}\;n \\
      \text{Unphased qubit} & \overline{q} & ::= & \ket{b} ~~\mid~~ \qket{r} \\
      \text{Qubit} & q & ::= &\alpha(r) \overline{q}\\
      \text{State (length $d$)} & \varphi & ::= & q_1 \otimes q_2 \otimes \cdots \otimes q_d
    \end{array}
  \]
  \caption{\oqasm state syntax}
  \label{fig:vqir-state}
\end{figure}

An \oqasm program state is represented according to the grammar in
\Cref{fig:vqir-state}. A state $\varphi$ of $d$ qubits is 
a length-$d$ tuple of qubit values $q$; the state models the tensor
product of those values. This means that the size of $\varphi$ is
$O(d)$ where $d$ is the number of qubits. A $d$-qubit state in a
language like \sqir is represented as a length $2^d$ vector of complex
numbers, which is $O(2^d)$ in the number of qubits.  Our linear state
representation is possible because applying any well-typed \oqasm
program on any well-formed \oqasm state never causes qubits to be
entangled.

A qubit value $q$ has one of two forms $\overline{q}$, scaled by a
global phase $\alpha(r)$. The two forms depend on the \emph{basis}
$\tau$ that the qubit is in---it could be either \texttt{Nor} or \texttt{Phi}. A \texttt{Nor} qubit has form
$\ket{b}$ (where $b \in \{ 0, 1 \}$), which is a
computational basis value. 
A \texttt{Phi} qubit has form $\qket{r} = \frac{1}{\sqrt{2}}(\ket{0}+\alpha(r)\ket{1})$, which is a value of the (A)QFT basis.
The number $n$ in \texttt{Phi}$\;n$ indicates the precision of the state $\varphi$.
As shown by~\citet{qft-adder}, arithmetic on the computational basis can sometimes be more efficiently carried out on the QFT basis, which leads to the use of quantum operations (like QFT) when implementing circuits with classical input/output behavior.
 
\subsection{\oqasm Syntax, Typing, and Semantics}\label{sec:oqasm-syn}

\liyi{add RZ gate back}

\begin{figure}[t]
\begin{minipage}[t]{0.5\textwidth}
{\small \centering

  $ \hspace*{-0.8em}
\begin{array}{llcl}
      \text{Position} & p & ::= & (x,n) \qquad   \text{Nat. Num}~n
                                  \qquad   \text{Variable}~x\\
      \text{Instruction} & \instr & ::= & \iskip{p} \mid \inot{p}
                                          \mid \irz[\lbrack -1 \rbrack]{n}{p} \mid \iseq{\instr}{\instr}\\
                & & \mid &  \isr[\lbrack -1 \rbrack]{n}{x} \mid \iqft[\lbrack -1 \rbrack]{n}{x} \mid \ictrl{p}{\instr}  \\
                      & & \mid & \ilshift{x} \mid \irshift{x} \mid \irev{x} 
    \end{array}
  $
}
  \caption{\oqasm syntax. For an operator \texttt{OP}, $\texttt{OP}^{\lbrack -1 \rbrack}$ indicates that the operator has a built-in inverse available.}
  \label{fig:vqir}
\end{minipage}
\hfill
\begin{minipage}[t]{0.45\textwidth}
\centering
\begin{tabular}{c@{$\quad=\quad$}c}
  \begin{minipage}{0.3\textwidth}
  \Small
%\includegraphics[width=0.3\textwidth]{sr-meaning.png}
  \Qcircuit @C=0.5em @R=0.5em {
    \lstick{} & \qw     & \multigate{4}{\texttt{SR m}} & \qw & \qw \\
    \lstick{} & \qw     & \ghost{\texttt{SR m}}           & \qw & \qw \\
    \lstick{} & \vdots & & \vdots & \\
    \lstick{} & & & & \\
    \lstick{} & \qw     & \ghost{\texttt{SR m}}           & \qw  & \qw
    }
  \end{minipage} & 
  \begin{minipage}{0.3\textwidth}
  \Small
  \Qcircuit @C=0.5em @R=0.5em {
    \lstick{} & \qw     & \gate{\texttt{RZ (m+1)}} & \qw & \qw \\
    \lstick{} & \qw     & \gate{\texttt{RZ m}}          & \qw & \qw \\
    \lstick{} & & \vdots & & \\
    \lstick{} & & & & \\
    \lstick{} & & & & \\
    \lstick{} & \qw     & \gate{\texttt{RZ 1}}           & \qw  & \qw
    }
  \end{minipage} 
\end{tabular}
\caption{\texttt{SR} unfolds to a series of \texttt{RZ} instructions}
\label{fig:sr-meaning}
\end{minipage}
\end{figure}

\Cref{fig:vqir} presents \oqasm's syntax. An \oqasm program consists of
a sequence of instructions $\instr$. Each instruction applies an
operator to either a variable $x$, which represents a group of qubits,
or a \emph{position} $p$, which identifies a particular offset into a variable $x$. 

The instructions in the first row correspond to simple single-qubit
quantum gates---$\iskip{p}$, $\inot{p}$, and $\irz[\lbrack -1 \rbrack]{n}{p}$
 ---and instruction sequencing.
The instructions in the next row apply to whole variables: $\iqft{n}{x}$
applies the AQFT to variable $x$ with $n$-bit precision and
$\iqft[-1]{n}{x}$ applies its inverse.
If $n$ is equal to the size of $x$, then the AQFT operation is exact.
$\isr[\lbrack -1 \rbrack]{n}{x}$
applies a series of \texttt{RZ} gates (\Cref{fig:sr-meaning}). 
Operation $\ictrl{p}{\instr}$
applies instruction $\instr$ \emph{controlled} on qubit position
$p$. All of the operations in this row---\texttt{SR}, \texttt{QFT}, and \texttt{CU}---will be translated to multiple \sqir
gates. Function \coqe{rz_adder} in \Cref{fig:circuit-example}(b) uses
many of these instructions; e.g., it uses \texttt{QFT} and \texttt{QFT}$^{-1}$ and applies
\texttt{CU} to the $m$th position of variable \texttt{a} to control
instruction \texttt{SR m b}.

In the last row of \Cref{fig:vqir}, instructions $\ilshift{x}$,
$\irshift{x}$, and $\irev{x}$ are \emph{position shifting operations}.
Assuming that $x$ has $d$ qubits and $x_k$ represents the $k$-th qubit
state in $x$, $\texttt{Lshift}\;x$ changes the $k$-th qubit state to
$x_{(k + 1)\% d}$, $\texttt{Rshift}\;x$ changes it to
$x_{(k + d - 1)\% d}$, and \texttt{Rev} changes it to $x_{d-1-k}$. In
our implementation, shifting is \emph{virtual} not physical. The \oqasm
translator maintains a logical map of variables/positions to concrete
qubits and ensures that shifting operations are no-ops, introducing no extra gates.

Other quantum operations could be added to \oqasm to
allow reasoning about a larger class of quantum programs, while still
guaranteeing a lack of entanglement. In \Cref{sec:extended-oqasm}, we
show how \oqasm can be extended to include the Hadamard gate
\texttt{H}, $z$-axis rotations \texttt{Rz}, and a new basis
\texttt{Had} to reason directly about implementations of QFT and AQFT\@.
However, this extension compromises the property of type reversibility
(\Cref{thm:reversibility}, \Cref{sec:metatheory}), and we have not found it necessary in
oracles we have developed.

\begin{figure}[t]
\begin{minipage}[t]{0.6\textwidth}
{\Small
  \begin{mathpar}
    \inferrule[X]{\Omegaty(x)=\texttt{Nor} \\ n < \Omegasz(x)}{\Sigma;\Omega \vdash \inot{(x,n)}\triangleright \Omega}
  
    \inferrule[RZ]{\Omegaty(x)=\texttt{Nor} \\ n < \Omegasz(x)}{\Sigma;\Omega \vdash \irz{q}{(x,n)} \triangleright \Omega}

    \inferrule[SR]{\Omegaty(x)=\tphi{n} \\ m < n}{\Sigma;\Omega \vdash \texttt{SR}\;m\;x\triangleright \Omega}   

    \inferrule[QFT]{\Omegaty(x)=\texttt{Nor}\\n \le \Omegasz(x)}{\Sigma; \Omega \vdash \iqft{n}{x}\triangleright \Omega[x\mapsto \tphi{n}]}    
     
    \inferrule[RQFT]{\Omegaty(x)=\tphi{n}\\n \le \Omegasz(x)}{\Sigma; \Omega \vdash \iqft[-1]{n}{x}\triangleright \Omega[x\mapsto \texttt{Nor}]}             
    
    \inferrule[CU]{\Omegaty(x)=\texttt{Nor} \\ \texttt{fresh}~(x,n)~\instr \\\\ \Sigma; \Omega\vdash \instr\triangleright \Omega \\ \texttt{neutral}(\instr)}{\Sigma; \Omega \vdash \texttt{CU}\;(x,n)\;\instr \triangleright \Omega} 
     
    \inferrule[LSH]{\Omegaty(x)=\texttt{Nor}}{\Sigma; \Omega \vdash \texttt{Lshift}\;x\triangleright \Omega}

     \inferrule[SEQ]{\Sigma; \Omega\vdash \instr_1\triangleright \Omega' \\ \Sigma; \Omega'\vdash \instr_2\triangleright \Omega''}{\Sigma; \Omega \vdash \instr_1\;;\;\instr_2\triangleright \Omega''} 
    
  \end{mathpar}
}
  \caption{Select \oqasm typing rules}
  \label{fig:exp-well-typed}
\end{minipage}
\hfill
\begin{minipage}[t]{0.35\textwidth}
{\footnotesize
\begin{center}\hspace*{-1em}
\begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3.2cm,
                    semithick]
  \tikzstyle{every state}=[fill=black,draw=none,text=white]

  \node[state] (A)              {$\texttt{Nor}$};
  \node[state]         (C) [left of=A] {$\tphi{n}$};

  \path (A) edge [loop above]            node {$\Big\{\begin{array}{l}\texttt{ID},~\texttt{X},~\texttt{RZ}^{\lbrack -1 \rbrack},~\texttt{CU},\\
              \texttt{Rev},\texttt{Lshift},\texttt{Rshift}\end{array}\Big\}$} (A)
            edge   node [above] {\{$\texttt{QFT}\;n$\}} (C);
  \path (C) edge [loop above]            node {$\{\texttt{ID},~\texttt{SR}^{\lbrack -1 \rbrack}\}$} (C)
            edge  [bend right]             node {$\{\texttt{QFT}^{-1}\;n\}$} (A);
\end{tikzpicture}
\end{center}
}
\caption{Type rules' state machine}
\label{fig:state-machine}
\end{minipage}
\end{figure}

\myparagraph{Typing}
\label{sec:vqir-typing}

In \oqasm, typing is with respect to a \emph{type environment}
$\Omega$ and a predefined \emph{size
  environment} $\Sigma$, which map \oqasm
variables to their basis and size (number of qubits), respectively.
The typing judgment is written $\Sigma; \Omega\vdash \instr \triangleright \Omega'$ which
states that $\instr$ is well-typed under $\Omega$ and $\Sigma$, and
transforms the variables' bases to be as in $\Omega'$ ($\Sigma$ is unchanged). 
\liyi{good?}
$\Sigma$ is fixed because the number of qubits in an execution is always fixed.
It is generated in the high level language compiler, such as \sourcelang in \Cref{sec:qimp}.
The algorithm generates $\Sigma$ by taking an \sourcelang program and scanning through
all the variable initialization statements.
Select type rules are given in \Cref{fig:exp-well-typed}; 
the rules not shown (for \texttt{ID}, \texttt{Rshift}, \texttt{Rev}, \texttt{RZ}$^{-1}$, and \texttt{SR}$^{-1}$) are similar.

The type system enforces three invariants.  First, it enforces that
instructions are well-formed, meaning that gates are applied to valid
qubit positions (the second premise in \rulelab{X}) and that any control qubit is distinct from the
target(s) (the \texttt{fresh} premise in
\rulelab{CU}).  This latter property enforces the quantum
\emph{no-cloning rule}.
For example, we can apply the \texttt{CU} in \code{rz\_adder'} (\Cref{fig:circuit-example})
because position \code{a,m} is distinct from variable \code{b}.

Second, the type system enforces that instructions leave affected
qubits in a proper basis (thereby avoiding entanglement). The
rules implement the state machine shown in
\Cref{fig:state-machine}. For example, $\texttt{QFT}\;n$ transforms a variable from \texttt{Nor} to
$\tphi{n}$ (rule \rulelab{QFT}), while $\texttt{QFT}^{-1}\;n$
transforms it from $\tphi{n}$ back to \texttt{Nor} (rule
\rulelab{RQFT}). Position shifting operations 
are disallowed on variables $x$ in
the \texttt{Phi} basis because the qubits that make up $x$ are
internally related (see \Cref{appx:well-formed}) and cannot be rearranged. Indeed, applying a
\texttt{Lshift} and then a $\texttt{QFT}^{-1}$ on $x$ in \texttt{Phi}
would entangle $x$'s qubits.

% \begin{figure}[t]
% {\footnotesize
% \begin{center}
% \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=3.2cm,
%                     semithick]
%   \tikzstyle{every state}=[fill=white,draw=black,text=black]
% 
%   \node[initial,accepting,state] (A)              {$\texttt{OK}$};
%   \node[state]         (B) [right of=A] {$ $};
% 
%   \path (A) edge [loop above]            node {$b,\epsilon / \epsilon$} (A)
%             edge  [above] node {$a,\emptyset / a$} (B);
%   \path (B) edge [loop right]            node [right] {$\begin{array}{l}b,\epsilon / \epsilon\\
%                                                                 a,a' / a a'\\
%                                                                 a,\overline{a} / \epsilon\\
%                                                  \end{array}$} (B)
%             edge  [bend left]             node [above] {$\epsilon,\emptyset / \emptyset$} (A);
% \end{tikzpicture}
% \end{center}
% }
% {
% \footnotesize
% $
% \begin{array}{l}
% a,a'\in \{\ilshift{x},\irshift{x},\irev{x} \} \wedge a' \neq \overline{a}
% \\
% \overline{\ilshift{x}}=\irshift{x}
% \quad
% \overline{\irshift{x}}=\ilshift{x}
% \quad
% \overline{\irev{x}}=\irev{x}
% \\
% b\not\in\{\ilshift{x},\irshift{x},\irev{x}, \instr;\instr \}
% \\
% \emptyset=\text{ no element in stack}
% \end{array}
% $
% }
% 
% \caption{Pushdown automata for \texttt{neutral}}
% \label{fig:pushdown-neu}
% \end{figure}

Third, the type system enforces that the effect of position shifting
operations can be statically tracked. The \texttt{neutral} condition of
\rulelab{CU} requires that any shifting within $\instr$ is restored by the time it
completes. 
For example, $\sseq{\ictrl{p}{(\ilshift{x})}}{\inot{(x,0)}}$ is not well-typed, because knowing the final physical position of qubit $(x,0)$ would require statically knowing the value of $p$. 
On the other hand, the program $\sseq{\ictrl{c}{(\sseq{\ilshift{x}}{\sseq{\inot{(x,0)}}{\irshift{x}}})}}{\inot{(x,0)}}$ is well-typed 
because the effect of the \texttt{Lshift} is ``undone'' by an \texttt{Rshift} inside the body of the \texttt{CU}.

% \texttt{neutral}'s definition in \Cref{fig:pushdown-neu}
% views $\instr$ as a string concatenated
% by the sequence operation ($;$) and requires $\instr$ to be
% accepted according to a family of pushdown automatas $\{G\}_{x}$ for every $x$ presented in $\instr$. 
% A program $\instr$ is \texttt{neutral}, iff, $\instr$ as a string is
% accepted by all the automatas in $\{G\}_{x}$.

\myparagraph{Semantics}\label{sec:pqasm-dsem}

\begin{figure}[t]
{\footnotesize
\[
\begin{array}{lll}
\llbracket \iskip{p} \rrbracket\varphi &= \varphi\\[0.2em]

\llbracket \inot{(x, i)} \rrbracket\varphi &= \app{\uparrow\xsem(\downarrow\varphi(x,i))}{\varphi}{(x,i)}
& \texttt{where  }\xsem(\ket{0})=\ket{1} \qquad\, \xsem(\ket{1})=\ket{0}
\\[0.5em]

\llbracket \ictrl{(x,i)}{\instr} \rrbracket\varphi &=  \csem(\downarrow\varphi(x,i),\instr,\varphi)
&
\texttt{where  }
\csem({\ket{0}},{\instr},\varphi)=\varphi\quad\;\,
\csem({\ket{1}},{\instr},\varphi)=\llbracket \instr \rrbracket\varphi
\\[0.4em]

\llbracket \irz{m}{(x,i)} \rrbracket\varphi &= \app{\uparrow {\rsem}({m},\downarrow\varphi(x,i))}{\varphi}{(x,i)}
&\texttt{where  }{\rsem}(m,\ket{0})=\ket{0} \; \quad{\rsem}(m,\ket{1})=\alpha(\frac{1}{2^m})\ket{1}
\\[0.5em]

\llbracket \irz[-1]{m}{(x,i)} \rrbracket\varphi &= \app{\uparrow {\rrsem}({m},\downarrow\varphi(x,i))}{\varphi}{(x,i)}
 &\texttt{where  }{\rrsem}(m,\ket{0})=\ket{0}
\quad{\rrsem}(m,\ket{1})=\alpha(-\frac{1}{2^m})\ket{1}
\\[0.5em]

\llbracket \isr{m}{x} \rrbracket\varphi &
                                            \multicolumn{2}{l}{= \app{\uparrow \qket{r_i+\frac{1}{2^{m-i+1}}}}{\varphi}{\forall i \le m.\;(x,i)}
\qquad \texttt{when  }
\downarrow\varphi(x,i) = \qket{r_i}}\\[0.5em]

\llbracket \isr[-1]{m}{x} \rrbracket\varphi&\multicolumn{2}{l}{= \app{\uparrow \qket{r_i-\frac{1}{2^{m-i+1}}}}{\varphi}{\forall i \le m.\;(x,i)}
\qquad \texttt{when  }
\downarrow\varphi(x,i) = \qket{r_i}}\\[0.5em]

\llbracket \iqft{n}{x} \rrbracket\varphi &= \app{\uparrow\qsem(\Sigma(x),\downarrow\varphi(x),n)}{\varphi}{x}
& \texttt{where  }\qsem(i,\ket{y},n)=\bigotimes_{k=0}^{i-1}(\qket{\frac{y}{2^{n-k}}})
\\[0.5em]

\llbracket \iqft[-1]{n}{x} \rrbracket\varphi &=  \app{\uparrow\qsem^{-1}(\Sigma(x),\downarrow\varphi(x),n)}{\varphi}{x}
\\[0.5em]

\llbracket \ilshift{x} \rrbracket\varphi &= \app{{\psem}_{l}(\varphi(x))}{\varphi}{x}
&
\texttt{where  }{\psem}_{l}(q_0\otimes q_1\otimes \cdots \otimes q_{n-1})=q_{n-1}\otimes q_0\otimes q_1 \otimes \cdots
\\[0.5em]

\llbracket \irshift{x} \rrbracket\varphi &= \app{{\psem}_{r}(\varphi(x))}{\varphi}{x}
&
\texttt{where  }{\psem}_{r}(q_0\otimes q_1\otimes \cdots \otimes q_{n-1})=q_1\otimes \cdots \otimes q_{n-1} \otimes q_0
\\[0.5em]

\llbracket \irev{x} \rrbracket\varphi &= \app{{\psem}_{a}(\varphi(x))}{\varphi}{x}
&
\texttt{where  }{\psem}_{a}(q_0\otimes \cdots \otimes q_{n-1})=q_{n-1}\otimes \cdots \otimes q_0
\\[0.5em]

\llbracket \iota_1; \iota_2 \rrbracket\varphi &= \llbracket \iota_2 \rrbracket (\llbracket \iota_1 \rrbracket\varphi)
\end{array}
\]
}
{\footnotesize
$
\begin{array}{l}
\\[0.2em]
\downarrow \alpha(b)\overline{q}=\overline{q}
\qquad
\downarrow (q_1\otimes \cdots \otimes q_n) = \downarrow q_1\otimes \cdots \otimes \downarrow q_n
\\[0.2em]
\app{\uparrow \overline{q}}{\varphi}{(x,i)}=\app{\alpha(b)\overline{q}}{\varphi}{(x,i)}
\qquad \texttt{where  }\varphi(x,i)=\alpha(b)\overline{q_i}
\\[0.2em]
\app{\uparrow \alpha(b_1)\overline{q}}{\varphi}{(x,i)}=\app{\alpha(b_1+b_2)\overline{q}}{\varphi}{(x,i)}
\qquad \texttt{where  }\varphi(x,i)=\alpha(b_2)\overline{q_i}
\\[0.2em]
\app{q_x}{\varphi}{x}=\app{q_{(x,i)}}{\varphi}{\forall i < \Sigma(x).\;(x,i)}
\\[0.2em]
\app{\uparrow q_x}{\varphi}{x}=\app{\uparrow q_{(x,i)}}{\varphi}{\forall i < \Sigma(x).\;(x,i)}
\end{array}
$
}
\vspace*{-0.5em}
\caption{\oqasm semantics}
  \label{fig:deno-sem}
\end{figure}

We define the semantics of an \oqasm program as a partial function
$\llbracket\rrbracket$ from
an instruction $\instr$ and input state $\varphi$ to an output state
$\varphi'$, written 
$\llbracket \instr \rrbracket\varphi=\varphi'$, shown in \Cref{fig:deno-sem}.
% The definition for $\llbracket\rrbracket$ is syntax-driven, meaning that it is defined in terms of the state syntax presented in \Cref{fig:vqir-state}.

% defines the denotational semantics of \oqasm, which maps a \oqasm instruction $\instr \in \{\instr\}$ to its unitary operator on $\varphi \in \hsp{S}^d$.

% The key takeaway of the \oqasm denotational semantics is that given an input $\varphi \in \hsp{S}^d$, a well typed instruction affects only one qubit (notation: $\varphi{(x,n)}$ or $q_{(x,n)}$) or qubit array (notation: $\varphi{(x)}$ or $q_x$), which means it \emph{does not create entanglement}.
% The benefit of this is that we can completely describe the state $\varphi$ using $d$ terms, instead of considering a length $2^d$ vector, as would generally be required to analyze an $d$-qubit system.

Recall that a state $\varphi$ is a tuple of $d$ qubit values,
modeling the tensor product $q_1\otimes \cdots \otimes q_d$. 
The rules implicitly map each variable $x$ to a
range of qubits in the state, e.g., 
$\varphi(x)$ corresponds to some sub-state $q_k\otimes \cdots \otimes q_{k+n-1}$
where $\Omegasz(x)=n$.
%
Many of the rules in \Cref{fig:deno-sem} update a \emph{portion} of a
state. We write $\app{q_{(x,i)}}{\varphi}{(x,i)}$ to update the $i$-th
qubit of variable $x$ to be the (single-qubit) state $q_{(x,i)}$, and
$\app{q_{x}}{\varphi}{x}$ to update variable $x$ according to
the qubit \emph{tuple} $q_x$.
$\app{\uparrow q_{(x,i)}}{\varphi}{(x,i)}$ and $\app{\uparrow q_{x}}{\varphi}{x}$ 
are similar, except that they also accumulate the previous global phase of $\varphi(x,i)$ (or $\varphi(x)$).
We use $\downarrow$ to convert a qubit $\alpha(b)\overline{q}$ to an unphased qubit $\overline{q}$.
%Thus, we have $\downarrow \alpha(b)\overline{q}=\overline{q}$ 
%and $\downarrow (q_1\otimes...\otimes q_n) = \downarrow q_1\otimes...\otimes \downarrow q_n$. 
%$\app{\uparrow q_{(x,i))}}{\varphi}{(x,i)}$ means to put back the global phase to the result qubit assigning to $(x,i)$. 
%%If $\varphi(x,i)=e^{2\pi i b}\overline{q}$ 
%and the result $q_{(x,i)}=\overline{q_{(x,i)}}$, 
%then we assign $e^{2\pi i b}\overline{q_{(x,i)}}$ to $(x,i)$;
%if the result $q_{(x,i)}=e^{2\pi i b_1}\overline{q_{(x,i)}}$, then we assign $e^{2\pi i (b+b_1)}\overline{q_{(x,i)}}$ to $(x,i)$. $\app{\uparrow q_{x}}{\varphi}{x}$ applies the above scenario to a list of qubits $q_k\otimes ... \otimes q_{k+n-1}$
%where $\Omegasz(x)=n$.

Function $\xsem$ updates the state of a single
qubit according to the rules for the standard quantum gate $X$.  
\texttt{cu} is a conditional operation
depending on the \texttt{Nor}-basis qubit $(x,i)$. 
\liyi{good?}
\texttt{RZ} (or $\texttt{RZ}^{-1}$) is an z-axis phase rotation operation.
Since it applies to \texttt{Nor}-basis, it applies a global phase.
By \Cref{thm:sem-same}, when we compiles it to \sqir,
the global phase might be turned to a local one.
For example, to prepare the state $\sum_{j=0}^{2^n}(-i)^x\ket{x}$ \cite{ChildsNAND}, 
we apply a series of Hadamard gates following by several controlled-\texttt{RZ} gates on $x$,
where the controlled-\texttt{RZ} gates are definable by \oqasm.
\texttt{SR} (or
$\texttt{SR}^{-1}$) applies an $m+1$ series of \texttt{RZ} (or
$\texttt{RZ}^{-1}$) rotations where the $i$-th rotation
applies a phase of $\alpha({\frac{1}{2^{m-i+1}}})$
(or $\alpha({-\frac{1}{2^{m-i+1}}})$).
$\qsem$ applies an approximate quantum Fourier transform; $\ket{y}$ is an abbreviation of
$\ket{b_1}\otimes \cdots \otimes \ket{b_i}$ (assuming $\Omegasz(y)=i$)
and $n$ is the degree of approximation.
If $n = i$, then the operation is the standard QFT\@.
Otherwise, each qubit in the state is mapped to $\qket{\frac{y}{2^{n-k}}}$, which is equal to $\frac{1}{\sqrt{2}}(\ket{0} + \alpha(\frac{y}{2^{n-k}})\ket{1})$ when $k < n$ and $\frac{1}{\sqrt{2}}(\ket{0} + \ket{1}) = \ket{+}$ when $n \leq k$ (since $\alpha(n) = 1$ for any natural number $n$).
$\qsem^{-1}$ is the inverse function of $\qsem$. 
Note that the input state to $\qsem^{-1}$ is guaranteed to have the form $\bigotimes_{k=0}^{i-1}(\qket{\frac{y}{2^{n-k}}})$ because it has type $\tphi{n}$.
$\psem_l$, $\psem_r$, and
$\psem_a$ are the semantics for \itext{Lshift}, 
\itext{Rshift}, and \itext{Rev}, respectively.   
% Several takeaways about \oqasm denotational semantics.
% For any operation application within the space domain $\hsp{S}^d$, the semantic application $U$ only has effect on the specific qubit ($\varphi_{(x,n)}$) / qubit array ($\varphi_{x}$) that it targets at, which does not create entanglement with other subsystems.
% This clear separation only works for the domain $\hsp{S}^d$.
% When we compile these operations to \sqir and see their effects on a general Hilbert space $\hsp{H}$, they might have entanglement effects.
% \yxp{Even if we turn it into unitary over the Hilbert space, it still does not generate entanglement with other subsystems.}
% \liyi{Can you have CNOT x y when you have x is Had and y is in Nor, then you will definitely have entanglement. }
% However, the clear separation in $\hsp{S}^d$ provides us a decompositional and analytical way of verifying and validating quantum oracles; thus, each sub-oracle-component can be analyzed individually. The potential entanglements in a general Hilbert space becomes the naturally extended (additive) superposition effects.
% In addition, all semantic functions in Fig.~\ref{fig:deno-sem} are carefully engineered to only target qubits in a register $\varphi$, and does not target on invidual vectors in the vector space $\varphi$ represents.
% For example, $\xsem$ is defined for a basis phase space case $\ket{c}$, and we also define the case for superposition $\frac{1}{\sqrt{2}}(\ket{0}+(-1)^c\ket{1})$. We do not assume the the semantics of the basis phase space is automatically extended to dealing with individual elements in the superposition case.
% By using the semantics to prove quantum oracle properties, we only need to consider $O(n)$ qubits instead of the possible $2^n$ expanded vector elements.
% The semantics of a universal quantum assembly language like \sqir, by contrast, represents a quantum state as a unitary matrix whose size is \emph{exponential} in the number of vectors by expanding qubits to vectors in a register. \sqir's semantics also relies on the use of concrete qubits; using a unitary matrix and virtual positions would inject a virtual-to-physical mapping into the semantic definition, which can severely complicate proofs~\cite{PQPC}. This leads to the successful correctness proof of the QFT-adder for the first time (Sec.~\ref{sec:op-verification}).
% We only define semantic functions for qubit forms when it is possible to apply. For example, we do not define $\xsem$ for the form $\frac{1}{\sqrt{2}}(\ket{0}+e^{2\pi{i} b}\ket{1})$, because the \oqasm type system does not allow it. 

\subsection{\oqasm Metatheory}\label{sec:metatheory}

\myparagraph{Soundness}
We prove that well-typed \oqasm programs are well defined; i.e., the
type system is sound with respect to the semantics. 
We begin by defining the well-formedness of an \oqasm state.

\begin{definition}[Well-formed \oqasm state]\label{appx:well-formed}\rm 
  A state $\varphi$ is \emph{well-formed}, written
  $\Sigma;\Omega \vdash \varphi$, iff:
\begin{itemize}
\item For every $x \in \Omega$ such that $\Omegaty(x) = \texttt{Nor}$,
  for every $k <\Omegasz(x)$, $\varphi(x,k)$ has the form
  $\alpha(r)\ket{b}$.

\item For every $x \in \Omega$ such that $\Omegaty(x) = \tphi{n}$ and $n \le \Omegasz(x)$,
  there exists a value $\upsilon$ such that for
  every $k < \Omegasz(x)$, $\varphi(x,k)$ has the form
  $\alpha(r)\qket{\frac{\upsilon}{ 2^{n- k}}}$.\footnote{Note that $\Phi(x) = \Phi(x + n)$, where the integer $n$ refers to phase $2 \pi n$; so multiple choices of $\upsilon$ are possible.}
\end{itemize}
\end{definition}

\noindent
Type soundness is stated as follows; the proof is by induction on $\instr$, and is mechanized in Coq.

\begin{theorem}\label{thm:type-sound-oqasm}\rm[\oqasm type soundness]
If $\Sigma; \Omega \vdash \instr \triangleright \Omega'$ and $\Sigma;\Omega \vdash \varphi$ then there exists $\varphi'$ such that $\llbracket \instr \rrbracket\varphi=\varphi'$ and $\Sigma;\Omega' \vdash \varphi'$.
\end{theorem}

\myparagraph{Algebra}
Mathematically, the set of well-formed $d$-qubit \oqasm states for a given $\Omega$ can be interpreted as a subset $\hsp{S}^d$ of a $2^d$-dimensional Hilbert space $\hsp{H}^d$,\footnote{A \emph{Hilbert space} is a vector space with an inner product that is complete with respect to the norm defined by the inner product. $\hsp{S}^d$ is a sub\emph{set}, not a sub\emph{space} of $\hsp{H}^d$ because $\hsp{S}^d$ is not closed under addition: Adding two well-formed states can produce a state that is not well-formed.}
and the semantics function $\llbracket \rrbracket$ can be interpreted as a $2^d \times 2^d$ unitary matrix, as is standard when representing the semantics of programs without measurement~\cite{PQPC}.
Because \oqasm's semantics can be viewed as a unitary matrix, correctness properties extend by linearity from $\hsp{S}^d$ to $\hsp{H}^d$---an oracle that performs addition for classical \texttt{Nor} inputs will also perform addition over a superposition of \texttt{Nor} inputs. We have proved that $\hsp{S}^d$ is closed under well-typed \oqasm programs.

\liyi{good?}
Given a qubit size map $\Sigma$ and type environment $\Omega$, the set of \oqasm programs that are well-typed with respect to $\Sigma$ and $\Omega$ (i.e., $\Sigma;\Omega \vdash \instr \triangleright \Omega'$) form a algebraic structure $(\{\instr\},\Sigma, \Omega,\hsp{S}^d)$, where $\{\instr\}$ defines the set of valid program syntax, such that there exists $\Omega'$, $\Sigma;\Omega \vdash \instr \triangleright \Omega'$ for all $\instr$ in $\{\instr\}$; $\hsp{S}^d$ is the set of $d$-qubit states on which programs $\instr\in \{\instr\}$ are run, and are well-formed ($\Sigma;\Omega \vdash \varphi$) according to \Cref{appx:well-formed}.
From the \oqasm semantics and the type soundness theorem, for all $\instr \in \{\instr\}$ and $\varphi \in \hsp{S}^d$, such that $\Sigma;\Omega \vdash \instr \triangleright \Omega'$ and $\Sigma;\Omega \vdash \varphi$, we have $\llbracket \instr \rrbracket\varphi=\varphi'$, $\Sigma;\Omega' \vdash \varphi'$, and $\varphi' \in \hsp{S}^d$. Thus, $(\{\instr\},\Sigma, \Omega,\hsp{S}^d)$, where $\{\instr\}$ defines a groupoid.

We can certainly extend the groupoid to another algebraic structure $(\{\instr'\},\Sigma,\hsp{H}^d)$, where $\hsp{H}^d$ is a general $2^d$ dimensional Hilbert space $\hsp{H}^d$ and $\{\instr'\}$ is a universal set of quantum gate operations.
Clearly, we have $\hsp{S}^d \subseteq \hsp{H}^d$ and $\{\instr\} \subseteq \{\instr'\}$, because sets $\hsp{H}^d$ and $\{\instr'\}$ can be acquired by removing the well-formed ($\Sigma;\Omega \vdash \varphi$) and well-typed ($\Sigma;\Omega \vdash \instr \triangleright \Omega'$) definitions for $\hsp{S}^d$ and $\{\instr\}$, respectively.
$(\{\instr'\},\Sigma,\hsp{H}^d)$ is a groupoid because every \oqasm operation is valid in a traditional quantum language like \sqir. We then have the following two two theorems to connect \oqasm operations with operations in the general Hilbert space: 

 \begin{theorem}\label{thm:subgroupoid}\rm
   $(\{\instr\},\Sigma, \Omega,\hsp{S}^d) \subseteq (\{\instr\},\Sigma,\hsp{H}^d)$ is a subgroupoid.
 \end{theorem}

\begin{theorem}\label{thm:sem-same}\rm
Let $\ket{y}$ be an abbreviation of $\bigotimes_{m=0}^{d-1} \alpha(r_m) \ket{b_m}$ for $b_m \in \{0,1\}$.
If for every $i\in [0,2^d)$, $\llbracket \instr \rrbracket\ket{y_i}=\ket{y'_i}$, then $\llbracket \instr \rrbracket (\sum_{i=0}^{2^d-1} \ket{y_i})=\sum_{i=0}^{2^d-1} \ket{y'_i}$.
\end{theorem}

We prove these theorems as corollaries of the compilation correctness theorem from \oqasm to \sqir (\Cref{thm:vqir-compile}). 
\Cref{thm:subgroupoid} suggests that the space $\hsp{S}^d$ is closed under the application of any well-typed \oqasm operation.
\Cref{thm:sem-same} says that \oqasm oracles can be safely applied to superpositions over classical states.\footnote{Note that a superposition over classical states can describe \emph{any} quantum state, including entangled states.}

\begin{figure}[t]
  {\Small
    \begin{mathpar}
      \inferrule[ ]{}{\inot{(x,n)}\xrightarrow{\text{inv}} \inot{(x,n)}}
    
      \inferrule[  ]{}{\texttt{SR}\;m\;x\xrightarrow{\text{inv}} \texttt{SR}^{-1}\;m\;x}
  
      \inferrule[ ]{}{\iqft{n}{x} \xrightarrow{\text{inv}}  \iqft[-1]{n}{x}}   
  
      \inferrule[ ]{}{\texttt{Lshift}\;x\xrightarrow{\text{inv}} \texttt{Rshift}\;x} 
       
      \inferrule[ ]{\instr \xrightarrow{\text{inv}} \instr'}{\texttt{CU}\;(x,n)\;\instr \xrightarrow{\text{inv}} \texttt{CU}\;(x,n)\;\instr'} 
  
      \inferrule[ ]{\instr_1 \xrightarrow{\text{inv}} \instr'_1 \\ \instr_2 \xrightarrow{\text{inv}} \instr'_2}{\instr_1\;;\;\instr_2\xrightarrow{\text{inv}} \instr'_2\;;\;\instr'_1} 
      
    \end{mathpar}
  }
  \caption{Select \oqasm inversion rules}
  \label{fig:exp-reversed-fun}
\end{figure}

\begin{figure}[t]
\centering
\begin{tabular}{c@{$\quad=\quad$}c@{\qquad}c@{$\quad=\quad$}c}
  \begin{minipage}{0.25\textwidth}
  \footnotesize
  \Qcircuit @C=0.25em @R=0.35em {
    & \qw & \multigate{3}{(x+a)_n} & \qw \\
    & \vdots & & \\
    & & & \\
    & \qw & \ghost{(x+a)_n} & \qw \\
    }
  \end{minipage}
&
\begin{minipage}{.45\textwidth}
% \includegraphics[width=1\textwidth]{qft-adder.png}
  \footnotesize
  \Qcircuit @C=0.35em @R=0.55em {
     & \qw & \gate{\texttt{SR}\;0} & \multigate{3}{\texttt{SR}\;1} & \qw & \qw & \qw & \multigate{5}{\texttt{SR}\;(n-1)} & \qw  \\
      & & & & & \dots & & &  \\
      & \qw & \qw  &  \ghost{\texttt{SR}\; 1} & \qw & \qw & \qw & \ghost{\texttt{SR}\;(n-1)} & \qw \\
      & & & & & & & &  \\
     & & & & & & & &  \\
   & \qw & \qw & \qw & \qw & \qw & \qw & \ghost{\texttt{SR}\;(n-1)}  & \qw 
    }
\end{minipage}
&  
\begin{minipage}{0.25\textwidth}
  \footnotesize
  \Qcircuit @C=0.25em @R=0.35em {
    & \qw & \multigate{3}{(x-a)_n} & \qw \\
    & \vdots & & \\
    & & & \\
    & \qw & \ghost{(x+a)_n} & \qw \\
    }
  \end{minipage}
&
\begin{minipage}{.45\textwidth}
% \includegraphics[width=1\textwidth]{qft-adder.png}
  \footnotesize
  \Qcircuit @C=0.35em @R=0.55em {
    & \qw & \multigate{5}{\texttt{SR}^{-1} (n-1)} & \qw & \qw & \qw & \multigate{3}{\texttt{SR}^{-1} 1} & \gate{\texttt{SR}^{-1} 0} & \qw \\
    &     &                                  &     & \dots &   &                              &                      &   \\
    & \qw & \ghost{\texttt{SR}^{-1} (n-1)}        & \qw & \qw   & \qw & \ghost{\texttt{SR}^{-1} 1} & \qw & \qw  \\
      & & & & & & & &  \\
     & & & & & & & &  \\
    & \qw & \ghost{\texttt{SR}^{-1} (n-1)} & \qw & \qw & \qw & \qw & \qw & \qw 
    }
\end{minipage}
\end{tabular}
\caption{Addition/subtraction circuits are inverses}
\label{fig:circuit-add-sub}
\end{figure}

\oqasm programs are easily invertible, as shown by the rules in \Cref{fig:exp-reversed-fun}.
This inversion operation is useful for constructing quantum oracles; for example, the core logic in the QFT-based subtraction circuit is just the inverse of the core logic in the addition circuit (\Cref{fig:exp-reversed-fun}).
This allows us to reuse the proof of addition in the proof of subtraction.
The inversion function satisfies the following properties:

 \begin{theorem}\label{thm:reversibility}\rm[Type reversibility]
    For any well-typed program $\instr$, such that $\Sigma; \Omega \vdash \instr \triangleright \Omega'$, its inverse $\instr'$, where $\instr \xrightarrow{\text{inv}} \instr'$, is also well-typed and we have $\Sigma;\Omega' \vdash \instr' \triangleright \Omega$. Moreover, $\llbracket \instr ; \instr' \rrbracket \varphi=\varphi$.
 \end{theorem}



\section{The full definitions of \qafny}
\label{sec:qafny-app}


\subsection{\qafny Session Generation}\label{sec:session-gen}

\begin{figure}[t]
{\Small
  \begin{mathpar}
    \inferrule[ ]{ }{\Omega \vdash x : \Omega(x)}



    \inferrule[ ]{\Omega(x)=(x,0,\Sigma(x)) }{\Omega \vdash x[n] : [(x,n,n+1)]}

    \inferrule[ ]{ \Omega \vdash a_1 : q_1 \\ \Omega \vdash a_2 : q_2 }{\Omega \vdash a_1 + a_2 : q_1 \sqcup q_2}   

    \inferrule[ ]{ \Omega \vdash a_1 : q_1 \\ \Omega \vdash a_2 : q_2 }{\Omega \vdash a_1 * a_2 : q_1 \sqcup q_2}   
 

    \inferrule[ ]{ \Omega \vdash a_1 : q_1 \\ \Omega \vdash a_2 : q_2 \Omega \vdash a_3 : q_3  }{\Omega \vdash (a_1 = a_2)@x[n] : q_1 \sqcup q_2\sqcup q_3}   

    \inferrule[ ]{ \Omega \vdash a_1 : q_1 \\ \Omega \vdash a_2 : q_2 \Omega \vdash a_3 : q_3  }{\Omega \vdash (a_1 < a_2)@x[n] : q_1 \sqcup q_2\sqcup q_3}

    \inferrule[ ]{ \Omega \vdash b : q}{\Omega \vdash \neg b : q}  

    \inferrule[ ]{ \Omega \vdash e : \zeta_2 \sqcup \zeta_1 }{\Omega \vdash e : \zeta_1 \sqcup \zeta_2}   

  \end{mathpar}
}
{\footnotesize
\[
\begin{array}{l}
\zeta_1 \sqcup \zeta_2 = \zeta_1 \uplus \zeta_2
\zeta \sqcup g = \zeta
\qquad 
g \sqcup \zeta = \zeta
\qquad
\cmode \sqcup \cmode = \cmode
\qquad
\qmode \sqcup \cmode = \qmode
\qquad
\cmode \sqcup \qmode = \qmode
\qquad
\cmode \le \qmode \le \zeta
\\[0.2em]
\bot \uplus l = l
\qquad 
l \uplus \bot = l

\qquad

[(x,v_1,v_2)] \uplus [(y,v_3,v_4)] = [(x,v_1,v_2), (y,v_3,v_4)]

\\

[v_2,v_2] \cap [v_3,v_4] \neq \emptyset \Rightarrow [(x,v_1,v_2)] \uplus [(x,v_3,v_4)] = [(x,\texttt{min}(v_1,v_3),\texttt{max}(v_2,v_4))]

\end{array}
\]
}
  \caption{Arith, Bool, Gate Mode Checking}
  \label{fig:exp-well-typed}
\end{figure}


A type is written as $\ttype{n}{t}$, where $n$ refers to the total number of qubits in a session,
and $t$ describes the qubit state form. 
A session being type $\ttype{n}{\tnor{\overline{d}}}$
means that every qubit is in normal basis (either $\ket{0}$ or $\ket{1}$),
and $\overline{d}$ describes basis states for the qubits.
The type corresponds to a single qubit basis state $\alpha(n)\ket{\overline{d}}$,
where the global phase $\alpha(n)$ has the form $e^{2 \pi i \frac{1}{n}}$ and $\overline{d}$ is a list of bit values.
Global phases for \texttt{Nor} type are usually ignored in many semantic definitions.
In QWhile, we record it because in quantum conditionals, such global phases might be turned to local phases.

$\ttype{n}{\thad{w}}$ means that every qubit in the session has the state: $(\alpha_1\ket{0} + \alpha_2\ket{1})$;
the qubits are in superposition but they are not entangled.
$\bigcirc$ represents the state is a uniform superposition,
while $\infty$ means the phase amplitude for each qubit is unknown.
If a session has such type, it then has the value form $\Motimes_{k=0}^{m}\ket{\Phi(n_k)}$,
where $\ket{\Phi(n_k)}=\frac{1}{\sqrt{2}}(\ket{0}+\alpha(n_k)\ket{1})$.

All qubits in a session that has type $\ttype{n}{\tch{m}{\beta}}$ are supposedly entangled (eventual entanglement below).
$m$ refers to the number of possible different entangled states in the session,
and the bitstring indexed set $\beta$ describes each of these states, while every element in $\beta$ is indexed by $i\in [0,m)$.
$\beta$ can also be $\infty$ meaning that the entanglement structure is unknown.
For example, in quantum phase estimation, after applying the $\texttt{QFT}^{-1}$ operation, the state has type $\ttype{n}{\tch{m}{\infty}}$. In such case, the only quantum operation to apply is a measurement.
If a session has type $\ttype{n}{\tch{m}{\beta}}$ and the entanglement is a uniform superposition,
we can describe its state as $\sum_{i=0}^{m}{\frac{1}{\sqrt{m}}\beta(i)}$, and the length of bitstring $\beta(i)$ is $n$.
For example, in a $n$-length GHZ application, the final state is: $\ket{0}^{\otimes n}+\ket{1}^{\otimes n}$. 
Thus, its type is $\ttype{n}{\tch{2}{\{\overline{0}^n,\overline{1}^n\}}}$, where $\overline{d}^n$ is a $n$-bit string having bit $d$.

The type $\ttype{n}{\tch{m}{\beta}}$ corresponds to the value form $\sum_{k=0}^{m}\theta_k\ket{\overline{d_k}}$.
$\theta_k$ is an amplitude real number, and $\overline{d_k}$ is the basis.
Basically, $\sum_{k=0}^{m}\theta_k\ket{\overline{d_k}}$ represents a size $m$ array of basis states
that are pairs of $\theta_k$ and $\overline{d_k}$. For a session $\zeta$ of type $\texttt{CH}$,
one can use $\zeta[i]$ to access the $i$-th basis state in the above summation, and the length is $m$.
In the Q-Dafny implementation section, we show how we can represent $\theta_k$ for effective automatic theorem proving.

The QWhile type system has the type judgment: $\Omega,\itau\vdash_g s : \zeta\triangleright \tau$, where $g$ is the context mode, mode environment $\Omega$ maps variables to modes or sessions ($q$ in \Cref{fig:vqimp}), type environment $\itau$ maps a session to its type, $s$ is the statement being typed, $\zeta$ is the session of $s$, and $\tau$ is $\zeta$'s type. 
The QWhile type system in \Cref{fig:exp-sessiontypea} has several tasks. First, it enforces context mode restrictions.
Context mode $g$ is either \cmode or \qmode.
$Q$ represents the current expression lives inside a quantum conditional or loop, while \cmode refers to other cases.
In a $Q$ context, one cannot perform $M$-mode operations, i.e., no measurement is allowed.
There are other well-formedness enforcement. For example,
the session of the Boolean guard $b$ in a conditional/loop is disjoint with the session in the conditional/loop body,
i.e., qubits used in a Boolean guard cannot appear in its conditional/loop body.

Second, the type system enforces mode checking for variables and expressions in \Cref{fig:exp-well-typed}.
In QWhile, \cmode-mode variables are evaluated to values during type checking.
In a \texttt{let} statement (\Cref{fig:exp-sessiontypea}),
\cmode-mode expression is evaluated to a value $n$, and the variable $x$ is replaced by $n$ in $s$.
The expression mode checking (\Cref{fig:exp-well-typed}) has the judgment: $\Omega \vdash (a\mid b) : q$. It takes a mode environment $\Omega$, and an expression ($a$, $b$), and judges if the expression has the mode $g$ if it contains only classical values, or a quantum session $\zeta$ if it contains some quantum values. 
All the supposedly \cmode-mode locations in an expression are assumed
to be evaluated to values in the type checking step,
such as the index value $x[n]$ in difference expressions in \Cref{fig:exp-well-typed}.
It is worth noting that the session computation ($\uplus$)
is also commutative as the last rule in \Cref{fig:exp-well-typed}.

Third, by generating the session of an expression, the QWhile type system assigns a type $\tau$ for the session indicating its state format, which will be discussed shortly below. Recall that a session is a list of quantum qubit fragments.
In quantum computation, qubits can entangled with each other.
We utilize type $\tau$ (\Cref{fig:vqir-state}) to state entanglement properties appearing in a group of qubits.
It is worth noting that the entanglement property refers to \textit{eventual entanglement}, .i.e. a group of qubits that are eventually entangled. Entanglement classification is tough and might not be necessary. In most near term quantum algorithms, such as Shor's algorithm \cite{shors} and Childs' Boolean equation algorithm (BEA) \cite{ChildsNAND}, programmers care about if qubits eventually become entangled during a quantum loop execution. This is why the normal basis type ($\ttype{n}{\tnor{\overline{d}}}$) can also be a subtype of a entanglement type ($\ttype{n}{\tch{1}{\{\overline{d}\}}}$) in our system (\Cref{fig:exp-subtyping}).

\myparagraph{Entanglement Types}
We first investigate the relationship between the types and entanglement states.
It is well-known that every single quantum gate application
does not create entanglement ($\texttt{X}$, $\texttt{H}$, and $\texttt{RZ}$).
It is enough to classify entanglement effects through a control gate application, i.e., 
$\sifq{x[i]}{e(y)}$, where the control node is $x[i]$ and $e$ is an operation applying on $y$.

A qubit can be described as $\alpha_1\ket{b_1}+\alpha_2\ket{b_2}$,
where $\alpha_1$/$\alpha_2$ are phase amplitudes, and $b_1$/$b_2$ are bases.
For simplicity, we assume that
when we applying a quantum operation on a qubit array $y$, we either solely change the qubit amplitudes or bases.
We identify the former one as $\mathpzc{R}$ kind, referring to its similarity of applying an \texttt{RZ} gate;
and the latter as $\mathpzc{X}$ kind, referring to its similarity of applying an \texttt{X} gate.
The entanglement situation between $x[i]$ and $y$ after applying a control statement $\sifq{x[i]}{e(y)}$ is described in \Cref{fig:control-entanglement}.

\begin{figure*}[t]
{\footnotesize
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|}
\hline                           
&  Case 1 & Case 2 & Case 3 & Case 4 & Case 5 & Case 6 & Case 7 & Case 8 & Case 9 \\
\hline
$x[i]$ & \texttt{Nor} & \texttt{Had} & \texttt{Had} & \texttt{Had} & \texttt{Had} & \texttt{Had} & \texttt{Had} & \texttt{CH} & \texttt{CH} \\
$y$  & any & \texttt{Nor} & \texttt{Nor} & \texttt{Had} & \texttt{Had} & \texttt{CH} & \texttt{CH} & \texttt{CH} & \texttt{CH}   \\\hline
$y$'s operation type  & any & $\mathpzc{X}$ & $\mathpzc{R}$ & $\mathpzc{X}$ & $\mathpzc{R}$ & $\mathpzc{X}$ & $\mathpzc{R}$ &  $\mathpzc{X}$ & $\mathpzc{R}$ \\\hline
Output Type Entangled?  & N & Y & N & N & Y & Y & Y & Y & Y  \\
\hline                           
\end{tabular}
  \caption{Control Gate Entanglement Situation}
  \label{fig:control-entanglement}
}
\end{figure*}

If $x[i]$ has input type \texttt{Nor}, the control operation acts as a classical conditional, i.e., no entanglement is possible.
In most quantum algorithms, $x[i]$ will be in superposition (type \texttt{Had}) to enable entanglement creation.
When $y$ has type $\texttt{Nor}$, if $y$'s operation is of $\mathpzc{X}$ kind, an entanglement between $x[i]$ and $y$ is created, such as the GHZ algorithm; 
if the operation is of $\mathpzc{R}$ kind, there is not entanglement after the control application, such as the Quantum Phase Estimation (QPE) algorithm.

When $x[i]$ and $y$ are both of type \texttt{Had}, if we apply an $\mathpzc{X}$ kind operation on $y$,
it does not create entanglement. An example application is the phase kickback pattern.
If we apply a $\mathpzc{R}$ operation on $y$, this does create entanglement.
This kind of operations appears in state preparations, such as preparing a register $x$ to have state $\sum_{t=0}^N i^{-t}\ket{t}$ in Childs' Boolean equation algorithm \cite{ChildsNAND}. 
The main goal for preparing such state is not to entanglement qubits, but to prepare a state with phases related to its bases.

\begin{figure}[t]
{\small
$
\begin{array}{l}
\ttype{n}{\tnor{\overline{d}}} \sqsubseteq \ttype{n}{\tch{1}{\{\overline{d}\}}}
\qquad 
\ttype{n}{\tch{2^n}{\beta}} \sqsubseteq \ttype{n}{\tch{2^n}{\infty}}
\qquad 
\ttype{n}{\thad{\bigcirc}} \sqsubseteq \ttype{n}{\tch{2^n}{\tpower{n}}}
\end{array}
$
}
  \caption{Session Type Subtyping}
  \label{fig:exp-subtyping}
\end{figure}

The case when $x[i]$ and $y$ has type \texttt{Had} and \texttt{CH}, respectively,
happens in the middle of executing a quantum loop, such as in the Shor's algorithm and BEA.
Applying both $\mathpzc{X}$ and $\mathpzc{R}$ kind operations result in entanglement.
In this narrative, algorithm designers intend to
merge an additional qubit $x[i]$ into an existing entanglement session $y$.
$x[i]$ is commonly in uniform superposition,
but there can be some additional local phases attached with some bases,
which we named this situation as saturation, i.e.,
In an entanglement session written as $\sum_{i=0}^n \ket{x_l,y,x_r}$,
for any fixing $x_l$ and $x_r$ bases, if $y$ covers all possible bases,
we then say that the part $y$ in the entanglement is in saturation.
This concept is important for generating auto-proof, which will be discussed in \Cref{sec:logical}.


When $x[i]$ and $y$ are both of type \texttt{CH}, there are two situations.
When the two parties belong to the same entanglement session,
it is possible that an $\mathpzc{X}$ or $\mathpzc{R}$ operation de-entangles the session.
Since QWhile tracks eventual entanglement.
In many cases, \texttt{HAD} type can be viewed as a kind of entanglement.
In addition, the QWhile type system make sure that most de-entanglements happen
at the end of the algorithm by turning the qubit type to $\tch{m}{\infty}$,
so that after the possible de-entanglement, the only possible application is a measurement.

If $x[i]$ and $y$ are in different entanglement sessions,
the situation is similar to when $x[i]$ having \texttt{Had} and $y$ having \texttt{CH} type.
It merges the two sessions together through the saturation $x[i]$.
For example, in BEA, The quantum Boolean guard computes the following operation $(z < i) @ x[i]$
on a \texttt{Had} type variable $z$ (state: $\sum_{k=0}^{2^n}\ket{k}$)
and a $\texttt{Nor}$ type factor $x[i]$ (state: $\ket{0}$).
The result is an entanglement $\sum_{k=0}^{2^n}\ket{k,k < i}$,
where the $x[i]$ position stores the Boolean bit result $k < i$. \footnote{When $k<i$, $x[i]=1$ while $\neg (k<i)$, $x[i]=0$.}
The algorithm further merges the $\ket{z,x[i]}$ session with a loop body entanglement session $y$. 
In this cases, both $\ket{z,x[i]}$ and $y$ are of \texttt{CH} type. 


\section{A Complicated Type System}\label{sec:newtype}

\begin{figure}
{\small
{\hspace*{-6em}
\begin{minipage}[t]{0.4\textwidth}
\begin{center}
 \[
  \begin{array}{l@{~}cl}
  \tnor{\infty} &\sqsubseteq_n& \tch{\infty}\\
  \tnor{c} &\sqsubseteq_n& \tch{\{c\}}\\
  \tch{\overline{c}(1)} &\sqsubseteq_n& \tnor{\overline{c}[0]}\\
  \thad{p} &\sqsubseteq_n& \tch{\{\tos{j}|j\in[0,2^n)\}(2^n)}\\
  \tch{\{0,1\}} &\sqsubseteq_1& \thad{\infty}\\
  \tch{p} &\sqsubseteq_n& \tch{\infty}
    \end{array}
  \]
\end{center}
\subcaption{Subtyping}
  \label{fig:qafny-subtype}
\end{minipage}
\qquad
\begin{minipage}[t]{0.45\textwidth}
\begin{center}
   \[
   \begin{array}{l@{~}cl}
  \ket{c} &\equiv_n& \sch{1}{ }{c}\\
  \sch{1}{z_j}{c_j} &\equiv_n& \ket{c_0}\\
  \shad{2^n}{n}{\alpha(r_j)} &\equiv_n& \sch{2^n}{\frac{\alpha(\sum_{k=0}^{n} r_k \cdot \tos{j}[k])}{\sqrt{2^n}}}{j}\\
  \sch{2}{z_j}{c_j} &\equiv_1& \shad{2}{1}{\frac{\sqrt{2}z_1}{z_0}}\\
   &&\qquad\texttt{when }c_0=0\;\;c_1=1
    \end{array}
 \]
\end{center}
\subcaption{State Equivalence}
  \label{fig:qafny-sequiv}
\end{minipage}
  \caption{\qafny type/state relations. $\overline{c}[n]$ produces the $n$-th element in set $\overline{c}$. $\{\tos{j}|j\in[0,2^n)\}(2^n)$ defines a set $\{\tos{j}|j\in[0,2^n)\}$ with the emphasis that it has $2^n$ elements. $\{0,1\}$ is a set of two single element bitstrings $0$ and $1$. $\cdot$ is the multiplication operation, $\tos{j}$ turns a number $j$ to a bitstring, $\tos{j}[k]$ takes the $k$-th element in the bitstring $\tos{j}$, and $\ket{j}$ is an abbreviation of $\ket{\tos{j}}$.}
  \label{fig:qafny-eq}
}
}
\end{figure}

The \qafny element component syntax is represented according to the grammar in \Cref{fig:qafny-state}. 
In \qafny, there are three kinds of values, two of which are classical ones represented by the two modes: $\cmode$ and $\mmode$.
The former represents classical values, represented as a natural number $n$, that do not intervene with quantum measurements and are evaluated in the compilation time, the latter represents values, represented as a pair $(r,n)$, produced from a quantum measurement. The real number $r$ is a characteristic representing the theoretical probability of the measurement resulting in the value $n$.
Any classical arithmetic operation does not change $r$, i.e., $(r,n)+m=(r,n+m)$. 

Quantum variables are defined as kind $\qmode{n}$, where $n$ is the number of qubits in a variable representing as a qubit array. Quantum values are more often to be described as sessions ($\lambda$) that can be viewed as clusters of possibly entangled qubits, where the number of qubits is exactly the session length, i.e., $\slen{\overline{x[n..m]}}$.
Each session consists of different disjoint ranges, connected by the $\uplus$ operation (meaning that different ranges are disjoint), represented as $x[n..m]$ that refers the number range $[n,m)$ in a quantum array named $x$. For simplicity, we assume that different variable names referring to different quantum arrays without aliasing. Sessions have associated equational properties. They are associative and identitive with the identity operation as $\bot$. There are another two equational properties for sessions below:

{\small
\[n \le j < m \Rightarrow x[n,m]\uplus\lambda \equiv_{\lambda} x[n,j]\uplus x[j,m] \uplus\lambda
\qquad 
x[n,n] \equiv_{\lambda} \bot
\]
}

Each length-$n$ session is associated to a quantum state that can be one of the three forms ($q$ in \Cref{fig:qafny-state}) that are corresponding to three different types ($\tau$ in \Cref{fig:qafny-state}). The first kind of state is of \texttt{Nor} type ($\tnor{(\topt{c})}$), having the state form $\ket{c}$, which is a computational basis value. $c$ is of length $n$ and represents a tensor product of qubits, all being $0$ or $1$. The second kind of state is of \texttt{Had} type ($\thad{(\topt{\bigcirc})}$),  meaning that qubits in such session are in superposition but not entangled.
The state form is $\shad{2^n}{n}{\alpha(r_j)}$, where $\alpha(r_j)$ is a local phase for the $j$-th qubit in the session. If $r_j=0$ for all $j$, the state can be represented by  type $\thad{\bigcirc}$ representing a uniformly distributed superposition; otherwise, we represent the type as $\thad{\infty}$. The third kind of state is of $\texttt{CH}$ type ($\tch{(\topt{\overline{c}(m)})}$), having the state form $\sch{m}{z_j}{c_j}$, referring to that qubits in such session are possibly entangled. The state $\sch{m}{z_j}{c_j}$ can be viewed as an $m$ element set of pairs $z_j\ket{c_j}$, where $z_j$ and $c_j$ are the $j$-th amplitude and basis.
The well-formed restrictions for the state are three: 1) $\sum_{j=0}^{m}|z_j|^2=1$ ($z_j$ is a complex number); 2) length of $c_j$ is $n$ for all $j$ and $m \le 2^n$; 3) any two bases $c_j$ and $c_k$ are distinct if $j \neq k$.

In \qafny, the quantum types and states are associated through bases and equational properties.
For each quantum state $q$, especially for \texttt{Nor} type state $\ket{c}$ and \texttt{CH} type state $\sch{m}{z_j}{c_j}$, the type factors are either $\infty$ meaning no bases can be tracked, or having the form $c$ and $\overline{c}(m)$ that track the bases of the state $\ket{c}$ and $\sch{m}{z_j}{c_j}$, respectively. For \texttt{Nor} type, this means that the type factor $c$ (in $\tnor{c}$) and the state qubit format $\ket{c}$ must be equal; for \texttt{CH} type ($\tch{\overline{c}(m)}$), if the state is $\sch{m}{z_j}{c_j}$, the $j$-th element $\overline{c}[j]$ is equal to $c_j$.
Additionally, \qafny types permit subtyping relations that correspond to state equivalent relations in \Cref{fig:qafny-eq}. 
Both subtype relation $\sqsubseteq_n$ and state equivalence relation $\equiv_n$ are parameterized by a session length number $n$, such that they establish relations between two quantum states describing a session of length $n$.
$\sqsubseteq_n$ in \Cref{fig:qafny-subtype} describes a type term on the left can be used as a type on the right. For example, a \texttt{Nor} type qubit array $\tnor{c}$ can be used as a single element entanglement type term $\tch{\{c\}}$ \footnote{If a qubit array only consists of $0$ and $1$, it can be viewed as an entanglement of unique possibility. }. 
Correspondingly, state equivalence relation $\equiv_n$ describes the two state forms to be equivalent; specifically, the left state term can be used as the right one, e.g., a single element entanglement state $\sch{1}{z_j}{c_j}$ can be used as a \texttt{Nor} type state $\ket{c_0}$ with the fact that $z_0$ is now a global phase that can be neglected.


\subsection{Type Checking: A Quantum Session Type System}\label{sec:typesystemappx}

\begin{figure}[t]
{
  \small
  \[\begin{array}{llcl} 
      \text{\oqasm Expr} & \mu\\
      \text{Parameter} & l & ::= & x \mid x[a] \\
      \text{Arith Expr} & a & ::= & x \mid v \mid a + a \mid a * a \mid ... \\
      \text{Bool Expr} & b & ::= & x[a] \mid (a = a) @ x[a] \mid (a < a) @ x[a] \mid ... \\
      \text{Predicate} & P & ::= & a = a \mid a < a \mid \lambda \mapsto q \mid P \wedge P \mid P * P \mid ... \\
      \text{Gate Expr} & op & ::= & \texttt{H} \mid \iqft[\lbrack -1 \rbrack]{}{} \\
      \text{C/M Moded Expr}& e & ::= & a \mid \sinit{a} \mid \smea{y} \mid \textcolor{red}{\sret{y,(r,n)}} \\
      \text{Statement} & s & ::= & \sskip \mid \sexp{x}{e}{s} \mid  \ssassign{l}{}{op} \mid \ssassign{\lambda}{}{\mu} 
                                 \mid \ssassign{l}{}{\sdis}
                                 \\ & & \mid & \sseq{s}{s} \mid \sifq{b}{s} \mid
                                     \sqwhile{j}{a_1}{a_2}{b}{s}
    \end{array}
  \]
}
  \caption{Core \qafny syntax. \oqasm is in \Cref{sec:qafny}. For an operator \texttt{OP}, $\texttt{OP}^{\lbrack -1 \rbrack}$ indicates that the operator has a built-in inverse available. Arithmetic expressions in $e$ are only used for classical operations, while Boolean expressions are used for both classical and quantum operations. $x[a]$ represents the $a$-th element in the qubit array $x$, while a quantum variable $x$ represents the qubit group $x[0..n]$ and $n$ is the length of $x$. }
  \label{fig:vqimpappx}
\end{figure}


\begin{figure}
{\small
\begin{center}
 \[
  \begin{array}{r@{~}c@{~}l@{~}cl}
  &&\{\bot:\tau\} \cup \sigma &\preceq& \sigma\\
  \tau\sqsubseteq_{\slen{\lambda}}\tau' &\Rightarrow& \{\lambda:\tau\} \cup \sigma &\preceq& \{\lambda:\tau'\} \cup \sigma\\
  &&\{\lambda_1\uplus l_1 \uplus l_2 \uplus \lambda_2 :\tau\} \cup \sigma &\preceq& \{\lambda_1\uplus l_2 \uplus l_1 \uplus \lambda_2 : \texttt{mut}(\tau,\slen{\lambda_1})\} \cup \sigma\\
  &&\{\lambda_1 :\tau_1\} \cup \{\lambda_2 :\tau_2\} \cup \sigma &\preceq& \{\lambda_1 \uplus \lambda_2 :\texttt{mer}(\tau_1,\tau_2)\} \cup \sigma \\
  \texttt{spt}(\tau,\slen{\lambda_1})=(\tau_1,\tau_2)&\Rightarrow&\{\lambda_1 \uplus \lambda_2 :\tau\} \cup \sigma &\preceq& \{\lambda_1 :\tau_1\} \cup \{\lambda_2 :\tau_2\} \cup \sigma
    \end{array}
  \]
\end{center}
{\footnotesize
\[
\begin{array}{l}
\texttt{pmut}((c_1.i_1.i_2.c_2),n)=(c_1.i_2.i_1.c_2) \;\;\texttt{when}\;\slen{c_1}=n
\\
\texttt{mut}(\tnor{c},n)=\tnor{\texttt{pmut}(c,n)}
\qquad
\texttt{mut}(\tch{\overline{c}(m)},n)=\tch{\{\texttt{pmut}(c,n)|c\in\overline{c}(m)\}(m)}
\qquad
\texttt{mut}(\tau,n)=\tau\;\;[\texttt{owise}]
\\
\texttt{mer}(\tnor{c_1},\tnor{c_2})=\tnor{(c_1.c_2)}
\qquad
\texttt{mer}(\thad{\bigcirc},\thad{\bigcirc})=\thad{\bigcirc}
\qquad
\texttt{mer}(T\;\infty,T\;t)=T\;\infty
\\
\texttt{mer}(\tch{\overline{c_1}(m_1)},\tch{\overline{c_2}(m_2)})=\tch{(\overline{c_1}\times \overline{c_2})(m_1*m_2)}
\\
\texttt{spt}(\tnor{c_1.c_2},n)=(\tnor{c_1},\tnor{c_2}) \;\;\texttt{when}\;\slen{c_1}=n
\qquad
\texttt{spt}(\thad{t},n)=(\thad{t},\thad{t})
\\
\texttt{spt}(\tch{\{c_j.c|j\in [0,m)\wedge |c_j|=n\}(m)},n)=(\tch{\{c_j|j\in [0,m)\wedge |c_j|=n\}(m)},\tnor{c})
\end{array}
\]
}
\caption{Type environment partial order. We use set union ($\cup$) to describe the type environment concatenation with the empty set operation $\emptyset$. $i$ is a single bit either $0$ or $1$. The $.$ operation is bitstring concatenation. $\times$ is the Cartesian product of two sets.
$T$ is either $\texttt{Nor}$, $\texttt{Had}$ or $\texttt{CH}$. }
  \label{fig:env-equiv}
}
\end{figure}

\begin{figure}[t]
{
{\Small
  \begin{mathpar}
    \inferrule[TPar]{\sigma \preceq \sigma' \\ \Omega,\sigma' \vdash_g s \triangleright \sigma''}{\Omega,\sigma \vdash_g s \triangleright \sigma'' }

    \inferrule[TEXP]{\Omega[x\mapsto \cmode],\sigma\vdash_g s[n/x] \triangleright \sigma'}{\Omega,\sigma \vdash_g \sexp{x}{n}{s} \triangleright \sigma' }

    \inferrule[TMEA]{ \Omega(y)=\qmode{j} \\ \sigma(y) = \{y[0..j]\uplus\lambda\mapsto \tau \}
     \\\\ \Omega[x\mapsto \mmode],\sigma[\lambda \mapsto \tch{\infty}]\vdash_{\cmode} s \triangleright  \sigma'}{\Omega,\sigma \vdash_{\cmode} \sexp{x}{\smea{y}}{s} \triangleright \sigma' }

    \inferrule[TA-CH]{ FV(\mu)=\lambda\\ \sigma(\lambda\uplus\lambda') = \tch{\overline{c}(m)}\\\\
  \overline{c'}=\{(\llbracket \mu \rrbracket c_1).c_2\;\bm{|}\;c_1.c_2\in\overline{c}\wedge\slen{c_1}=\slen{\lambda}\}}{\Omega,\sigma \vdash_g \ssassign{\lambda}{}{\mu} \triangleright \{\lambda\uplus\lambda':\tch{\overline{c'}(m)}\} }

    \inferrule[TMEA-N]{ \Omega(y)=\qmode{j} \\ \overline{c'}=\{c_2\;\bm{|}\;\tos{n}.c_2\in\overline{c}\wedge\slen{\tos{n}}=j\}
     \\\\ \Omega[x\mapsto \mmode],\sigma[\lambda \mapsto \tch{\overline{c'}(\slen{\overline{c'}})}]\vdash_{\cmode} s \triangleright  \sigma'}{\Omega,\sigma[y[0..j]\uplus\lambda\mapsto \tch{\overline{c}(m)}] \vdash_{\cmode} \sexp{x}{\sret{y,(r,n)}}{s} \triangleright \sigma' }

    \inferrule[TSEQ]{\Omega,\sigma\vdash_g s_1 \triangleright\sigma_1
 \\\\\Omega,\sigma[\uparrow \sigma_1]\vdash_g s_2 \triangleright\sigma_2}{\Omega,\sigma \vdash_g \sseq{s_1}{s_2}\triangleright \;\sigma_2\cup\sigma_1|_{\not\in\dom{\sigma_2}} }

    \inferrule[TLOOP]{ \forall j\in[n_1,n_2)\;.\;\Omega,\sigma[\uparrow \sigma'[j/x]]\vdash_g \sifq{b}{s} \triangleright \sigma'[\texttt{S}\;j/x] }
                  {\Omega,\sigma \vdash_g \sqwhile{\sint{x}{n_1}}{x<n_2}{b}{\dplus{x}}{s} \triangleright \sigma'[n_2/x]}


\inferrule[TIF]{ 
FV(b@x[j])=\lambda\uplus x[j,\texttt{S}\;j]\\
FV(b@x[j])\cap FV(s) =\emptyset \\\\
\sigma(\lambda\uplus x[j,\texttt{S}\;j]\uplus \lambda_1)=\tch{\overline{c}(m)}
\\
     \Omega,\sigma \vdash_{\mmode} s \triangleright \{\lambda\uplus x[j,\texttt{S}\;j]\uplus \lambda_1:\tch{\overline{c'}(m)}\}} 
{\Omega,\sigma \vdash_g \sifq{b@x[j]}{s} \triangleright \{\lambda\uplus x[j,\texttt{S}\;j]\uplus \lambda_1:\tch{\overline{c''}(m)}\} }

\inferrule[SLOOP-N]{}{(\varphi,\sqwhile{j}{n_1}{n_2}{b}{s})\longrightarrow (\varphi,\{\})}

  \end{mathpar}
}
{\footnotesize
\[
\begin{array}{l}
\overline{c''}=\{\tos{n}.1.c_2\;\bm{|}\;\tos{n}.d.c_1 \in \overline{c} \wedge \tos{n}.d.c_2 \in \overline{c'} \wedge b[\tos{n}/\lambda] \oplus d \wedge \slen{\tos{n}}=\slen{\lambda} \}
\\ \qquad\quad \cup \{\tos{n}.0.c_1\;\bm{|}\; \tos{n}.d.c_1 \in \overline{c} \wedge \neg (b[\tos{n}/\lambda] \oplus d) \wedge \slen{\tos{n}}=\slen{\lambda} \}
\\
\sigma[\uparrow \sigma'] = \sigma[\forall \lambda:\tau \in \sigma'\;.\;\tau/\lambda]
\\
\sigma|_{\not\in\dom{\sigma'}}=\{\lambda:\tau|\lambda \not\in \dom{\sigma'}\}

\end{array}
\]
}
}
  \caption{\qafny type system. $\llbracket \mu \rrbracket c$ is the \oqasm semantics of interpreting reversible expression $\mu$ in \Cref{fig:deno-sem}. Boolean expression $b$ can be $a_1=a_2$, $a_1 < a_2$ or \texttt{true}. $b[\tos{n}/\lambda]$ means that we treat $b$ as a \oqasm $\mu$ expression, replace qubits in array $\lambda$ with bits in bitstring $\tos{n}$, and evaluate it to a Boolean value.
$\sigma(y)=\{\lambda\mapsto \tau\}$ produces the map entry $\lambda\mapsto \tau$ and the range $y[0..\slen{y}]$ is in $\lambda$.
$\sigma(\lambda)=\tau$ is an abbreviation of $\sigma(\lambda)=\{\lambda\mapsto \tau\}$. $FV(-)$ produces a session by union all qubits appearing in $-$.}
  \label{fig:exp-sessiontypea}
\end{figure}

In \qafny, typing is with respect to a \emph{kind environment} $\Omega$ and a \emph{finite type environment} $\sigma$,
which map \qafny variables to kinds and map sessions to types, respectively.
The typing judgment is written as $\Omega; \sigma\vdash_{g} s \triangleright \sigma'$,
which states that statements $s$ is well-typed under the context mode $g$ and environments $\Omega$ and $\sigma$,
the sessions representing $s$ is exactly the domain of $\sigma'$ as $\dom{\sigma'}$,
and $s$ transforms types for the sessions in $\sigma$ to types in $\sigma'$.
$\Omega$ describes the kinds for all program variables.
$\Omega$ is populated through \texttt{let} expressions that introduce variables,
and the \qafny type system enforces variable scope; such enforcement is neglected in \Cref{fig:exp-sessiontypea} for simplicity.
We also assume that variables introduced in \texttt{let} expressions are all distinct through proper alpha conversions.
$\sigma$ and $\sigma'$ describe types for sessions referring to possibly entangled quantum clusters pointed to by quantum variables in $s$. 
$\sigma$ and $\sigma'$ are both finite and the domain of them contain sessions that do not overlap with each other; $\dom{\sigma}$ is large enough to describe all sessions pointed to by quantum variables in $s$,
while $\dom{\sigma'}$ should be the exact sessions containing quantum variables in $s$.
We have partial order relations defined for type environments in \Cref{fig:env-equiv}, which will be explained shortly.
Selected type rules are given in \Cref{fig:exp-sessiontypea}; 
the rules not mentioned are similar and listed in \Cref{sec:qafny-app}.

The type system enforces five invariants.  First, well-formed and context restrictions for quantum programs.
Well-formedness means that qubits mentioned in the Boolean guard of a quantum conditional cannot be accessed in the conditional body,
while context restriction refers to the fact that the quantum conditional body cannot create (\texttt{init}) and measure (\texttt{measure}) qubits. 
For example the $FV$ checks in rule \textsc{TIF} enforces that the session for the Boolean and the conditional body does not overlap.
Coincidentally, we utilize the modes ($g$, either $\cmode$ or $\mmode$) as context modes for the type system. 
Context mode $\cmode$ permits most \qafny operations. Once a type rule turns a mode to $\mmode$, such as in the conditional body in rule \textsc{TIF}, we disallow \texttt{init} and \texttt{measure} operations. For example, rules \textsc{TMEA} and \textsc{TMEA-N} are valid only if the input context mode is $\cmode$.

Second, the type system tracks the basis state of every qubit in sessions. In rule \textsc{TA-CH}, we find that the oracle $\mu$ is applied on $\lambda$ belonging to a session $\lambda \uplus \lambda'$. Correspondingly, the session's type is $\tch{\overline{c}(m)}$, for each bitstring $c_1.c_2\in \overline{c}$, with $\slen{c_1}=\slen{\lambda}$, we apply $\mu$ on the $c_1$ and leave $c_2$ unchanged.
Here, we utilize the \oqasm semantics that describes transitions from a $\texttt{Nor}$ state to another $\texttt{Nor}$ one, and we generalize it to apply the semantic function on every element in the \texttt{CH} type.
During the transition, the number of elements $m$ does not change.
Similarly, applying a partial measurement on range $y[0..j]$ of the session $y[0..j]\uplus\lambda$ in rule \textsc{TMEA-N}
can be viewed as a array filter, i.e., for an element $c_1.c_2$ in set $\overline{c}$ of the type $\tch{\overline{c}(m)}$, with $\slen{c_1}=j$, we keep only the ones with $c_1=\tos{n}$ ($n$ is the measurement result) in the new set $\overline{c'}$ and recompute $\slen{\overline{c'}}$. In \qafny, the tracking procedure is to generate symbolic predicates that permit the production of the set $\overline{c'}(\slen{c'})$, not to actually produce such set. If the predicates are not not effectively trackable, we can always use $\infty$ to represent the set.


\liyi{may be we can add a rule about turning NOR to HAD so that we can say that the subtyping casting is also useful. }
Third, the type system enforces equational properties of 
quantum qubit sessions through a partial order relation over type environments, including subtyping, qubit position mutation, merge and split quantum sessions.
Essentially, we can view two qubit arrays be equivalent if there is a bijective permutation on the qubit positions of the two.
To analyze a quantum application on a qubit array, if the array is arranged in a certain way, the semantic definition will be a lot more trivial than other arrangements. For example, in applying a quantum oracle to a session (rule \textsc{TMEA}), we fix the qubits that permits the $\mu$ operation to always live in the front part ($\lambda$ in $\lambda\uplus\lambda'$).
This is achieved by a consecutive application of the mutation rule ($\texttt{mut}$) in the partial order ($\preceq$) in \Cref{fig:env-equiv}, which casts the left type environment to the format on the right through rule \textsc{TPar}.
Similarly, split ($\texttt{spt}$) and combination ($\texttt{mer}$) of sessions in \Cref{fig:env-equiv} are useful to describe some quantum operation behaviors. the split of a quantum session into two represents the process of disentanglement of quantum qubits.
For example, $\ket{00}+\ket{10}$ can be disentangled as $(\ket{0}+\ket{1})\otimes \ket{0}$.
The \texttt{spt} function is a partial one since disentanglement is considered to be a hard problem and it is usually done through case analyses as the ones in \Cref{fig:env-equiv}.
Merging two sessions is valuable for analyzing the behavior of quantum conditionals.
In rule \textsc{TIF}, the session ($\lambda_1\uplus x[j,\texttt{S}\;j]$) for the Boolean guard ($b@x[j]$)
 and the session for ($\lambda_2$) the body can be two separative sessions. 
Here, we first merge the two session through the $\texttt{mer}$ rule in \Cref{fig:env-equiv} by computing the Cartesian product of the two type bases, such that if the two sessions are both \texttt{CH} types $\lambda_1\uplus x[j,\texttt{S}\;j]\mapsto\tch{\overline{c_1}(m_1)}$ and $\lambda_2\mapsto\tch{\overline{c_2}(m_2)}$, the result is of type $\tch{(\overline{c_1}\times \overline{c_2})(m_1*m_2)}$. 
After that, the quantum conditional behavior can be understood as applying a partial map function on the size $m_1*m_2$ array of bitstrings, and we only apply the conditional body's effect on the second part (the $\overline{c_2}$ part) of some bitstrings whose first part is checked to be true by applying the Boolean guard $b$. 
\liyi{see how to merge the following to above}
Based on the new \texttt{CH} type with the set $\overline{c_1}\times \overline{c_2}$,
the quantum conditional creates a new set based on $\overline{c_1}\times \overline{c_2}$, i.e., for each element $\tos{n}.d.c$ in the set, with $\slen{\tos{n}}=\slen{\lambda_1}$, we compute Boolean guard $b$ value by substituting qubit variables in $b$ with the bitstring $\tos{n}$, and the result $b[\tos{n} / \lambda_1] \oplus d$ is true or not ($d$ represents the bit value for the qubit at $x[j,\texttt{S}\;j]$); if it is true, we replace the $c$ bitstring by applying the conditional body on it; otherwise, we keep $c$ to be the same.
In short, the quantum conditional behavior can be understood as applying a partial map function on an $m$ array of bitstrings, and we only apply the conditional body's effect on the second part of some bitstrings whose first part is checked to be true by applying the Boolean guard $b$.

Fourth, the type system enforces that the $\cmode$ classical variables can be evaluated to values in the compilation time. \footnote{We consider all computation that only needs classical computer is done in the compilation time.}, while tracks $\mmode$ variables which represent the measurement results of quantum sessions. Rule \textsc{TEXP} enforces that a classical variable $x$ is replaced with its assignment value $n$ in $s$. The substitution statement $s[n/x]$ also evaluates classical expressions in $s$, which is described in \Cref{sec:qafny-app}.
In measurement rules (\textsc{TMEA} and \textsc{TMEA-N}), we apply some gradual typing techniques.
There is an ghost expression $\texttt{ret}$ generated from one step evaluation of the measurement.
Before the step evaluation, rule \textsc{TMEA} types the partial measurement results as a classical $\mmode$ mode variable $x$ and a possible quantum leftover $\lambda$ as $\tch{\infty}$.
After the step is transitioned, we know the exact value for $x$ as $(r,n)$, so that we carry the result to type $\lambda$ as $\tch{\overline{c'}(\slen{\overline{c'}})}$. This does not violate type preservation because we have the subtyping relation $\tch{\overline{c'}(\slen{\overline{c'}})} \sqsubseteq_{\slen{\lambda}} \tch{\infty}$.

Finally, the type system extracts the result type environment of a for-loop as $\sigma'[n_2/x]$ based on the extraction of a type environment invariant on the $i$-th loop step of executing a conditional $\sifq{b}{s}$ in rule \textsc{TLOOP}, regardless if the conditional is classical or quantum. 



\subsection{\qafny Semantics and Type Soundness}\label{sec:semantics}

\begin{figure}[t]
{
{\Small
  \begin{mathpar}
    \inferrule[SPar]{\varphi \equiv \varphi' }{(\varphi,s) \longrightarrow (\varphi',s) }

    \inferrule[SMEA]{\sigma(y) = y[0..k]\uplus\lambda\mapsto \sch{m}{z_j}{c_j} \\ r = \forall j\in[0,m).\;c_j=\tos{n}.c\Rightarrow \sum{\slen{z_j}^2}}{(\varphi,\sexp{x}{\smea{y}}{s} \longrightarrow (\varphi,\sexp{x}{\sret{(y,(r,n))}}{s}) }


    \inferrule[SSEQ-1]{(\varphi,s_1) \longrightarrow (\varphi',s'_1)}{(\varphi,\sseq{s_1}{s_2})\longrightarrow (\varphi',\sseq{s'_1}{s_2}) }

    \inferrule[SMEA-N]{ \varphi(y) = \{y[0..k]\uplus \lambda : \sch{m}{z_j}{c_{j1}.c_{j2}}\} \\\overline{c}=\{c_{j2}|c_{j1}=\tos{n}\}\\c_j\in \overline{c}}{(\varphi,\sexp{x}{\sret{(y,(r,n))}}{s} \longrightarrow (\varphi[x\mapsto (r,n),\lambda \mapsto \sch{\slen{\overline{c}}}{\frac{1}{\sqrt{r}}z_j}{c_j}],s)}

    \inferrule[SSEQ-2]{}{(\varphi,\sseq{\{\}}{s_2})\longrightarrow (\varphi,s_2) }

    \inferrule[SA-CH]{ \varphi(\lambda)=\{\lambda\uplus\lambda'\mapsto \sch{m}{z_j}{c_{j1}.c_{j2}}\} \\\\ \slen{c_{j1}}=\slen{\lambda}
    \\\llbracket \mu \rrbracket c_{j1} = z'_j\ket{c'_{j1}} }{ (\varphi,\ssassign{\lambda}{}{\mu}) \longrightarrow (\varphi[\lambda\uplus\lambda'\mapsto \sch{m}{z'_j\cdot z_j}{c'_{j1}.c_{j2}}],\{\}) }

    \inferrule[SEXP]{ }{(\varphi,\sexp{x}{n}{s}) \longrightarrow (\varphi,s[n/x]) }


\inferrule[SIF]{ \lambda=\lambda_1\uplus x[j,\texttt{S}\;j]\uplus \lambda_2 \\ FV(b@x[j]) = \lambda\uplus x[j,\texttt{S}\;j] \\ 
  \varphi(\lambda)=\sch{m}{z_j}{c_{j1}.c_{j2}}]
\\
(\varphi,s) \longrightarrow^* (\varphi[\lambda\mapsto \sch{m}{z'_j}{c_{j1}.c'_{j2}}],\{\}) \\ \slen{c_{j1}}=\slen{\lambda} } 
{(\varphi,\sifq{b@x[j]}{s}) \longrightarrow (\varphi[\lambda\mapsto \texttt{pmap}(m,z_j,z'_j,c_{j1},c'_{j1},c_{j2})],\{\}) }

  \end{mathpar}
}
}
  \caption{\qafny small step semantics. $\llbracket \mu \rrbracket c$ is the \oqasm semantics of interpreting reversible expression $\mu$ in \Cref{fig:deno-sem}. Boolean expression $b$ can be $a_1=a_2$, $a_1 < a_2$ or \texttt{true}.
$\varphi(y)=\{\lambda\mapsto q\}$ produces the map entry $\lambda\mapsto q$ and the range $y[0..\slen{y}]$ is in $\lambda$.
$\varphi(\lambda)=q$ is an abbreviation of $\varphi(\lambda)=\{\lambda\mapsto q\}$.}
  \label{fig:exp-semantics}
\end{figure}

We define the semantics of an \oqasm program as a partial function
$\llbracket\rrbracket$ from
an instruction $\instr$ and input state $\varphi$ to an output state
$\varphi'$, written 
$\llbracket \instr \rrbracket\varphi=\varphi'$, shown in \Cref{fig:deno-sem}.
% The definition for $\llbracket\rrbracket$ is syntax-driven, meaning that it is defined in terms of the state syntax presented in \Cref{fig:vqir-state}.

% defines the denotational semantics of \oqasm, which maps a \oqasm instruction $\instr \in \{\instr\}$ to its unitary operator on $\varphi \in \hsp{S}^d$.

% The key takeaway of the \oqasm denotational semantics is that given an input $\varphi \in \hsp{S}^d$, a well typed instruction affects only one qubit (notation: $\varphi{(x,n)}$ or $q_{(x,n)}$) or qubit array (notation: $\varphi{(x)}$ or $q_x$), which means it \emph{does not create entanglement}.
% The benefit of this is that we can completely describe the state $\varphi$ using $d$ terms, instead of considering a length $2^d$ vector, as would generally be required to analyze an $d$-qubit system.

Recall that a state $\varphi$ is a tuple of $d$ qubit values,
modeling the tensor product $q_1\otimes \cdots \otimes q_d$. 
The rules implicitly map each variable $x$ to a
range of qubits in the state, e.g., 
$\varphi(x)$ corresponds to some sub-state $q_k\otimes \cdots \otimes q_{k+n-1}$
where $\Omegasz(x)=n$.
%
Many of the rules in \Cref{fig:deno-sem} update a \emph{portion} of a
state. We write $\app{q_{(x,i)}}{\varphi}{(x,i)}$ to update the $i$-th
qubit of variable $x$ to be the (single-qubit) state $q_{(x,i)}$, and
$\app{q_{x}}{\varphi}{x}$ to update variable $x$ according to
the qubit \emph{tuple} $q_x$.
$\app{\uparrow q_{(x,i)}}{\varphi}{(x,i)}$ and $\app{\uparrow q_{x}}{\varphi}{x}$ 
are similar, except that they also accumulate the previous global phase of $\varphi(x,i)$ (or $\varphi(x)$).
We use $\downarrow$ to convert a qubit $\alpha(b)\overline{q}$ to an unphased qubit $\overline{q}$.
%Thus, we have $\downarrow \alpha(b)\overline{q}=\overline{q}$ 
%and $\downarrow (q_1\otimes...\otimes q_n) = \downarrow q_1\otimes...\otimes \downarrow q_n$. 
%$\app{\uparrow q_{(x,i))}}{\varphi}{(x,i)}$ means to put back the global phase to the result qubit assigning to $(x,i)$. 
%%If $\varphi(x,i)=e^{2\pi i b}\overline{q}$ 
%and the result $q_{(x,i)}=\overline{q_{(x,i)}}$, 
%then we assign $e^{2\pi i b}\overline{q_{(x,i)}}$ to $(x,i)$;
%if the result $q_{(x,i)}=e^{2\pi i b_1}\overline{q_{(x,i)}}$, then we assign $e^{2\pi i (b+b_1)}\overline{q_{(x,i)}}$ to $(x,i)$. $\app{\uparrow q_{x}}{\varphi}{x}$ applies the above scenario to a list of qubits $q_k\otimes ... \otimes q_{k+n-1}$
%where $\Omegasz(x)=n$.

Function $\xsem$ updates the state of a single
qubit according to the rules for the standard quantum gate $X$.  
\texttt{cu} is a conditional operation
depending on the \texttt{Nor}-basis qubit $(x,i)$. 
\texttt{SR} (or
$\texttt{SR}^{-1}$) applies an $m+1$ series of \texttt{RZ} (or
$\texttt{RZ}^{-1}$) rotations where the $i$-th rotation
applies a phase of $\alpha({\frac{1}{2^{m-i+1}}})$
(or $\alpha({-\frac{1}{2^{m-i+1}}})$).
$\qsem$ applies an approximate quantum Fourier transform; $\ket{y}$ is an abbreviation of
$\ket{b_1}\otimes \cdots \otimes \ket{b_i}$ (assuming $\Omegasz(y)=i$)
and $n$ is the degree of approximation.
If $n = i$, then the operation is the standard QFT\@.
Otherwise, each qubit in the state is mapped to $\qket{\frac{y}{2^{n-k}}}$, which is equal to $\frac{1}{\sqrt{2}}(\ket{0} + \alpha(\frac{y}{2^{n-k}})\ket{1})$ when $k < n$ and $\frac{1}{\sqrt{2}}(\ket{0} + \ket{1}) = \ket{+}$ when $n \leq k$ (since $\alpha(n) = 1$ for any natural number $n$).
$\qsem^{-1}$ is the inverse function of $\qsem$. 
Note that the input state to $\qsem^{-1}$ is guaranteed to have the form $\bigotimes_{k=0}^{i-1}(\qket{\frac{y}{2^{n-k}}})$ because it has type $\tphi{n}$.
$\psem_l$, $\psem_r$, and
$\psem_a$ are the semantics for \itext{Lshift}, 
\itext{Rshift}, and \itext{Rev}, respectively.   
% Several takeaways about \oqasm denotational semantics.
% For any operation application within the space domain $\hsp{S}^d$, the semantic application $U$ only has effect on the specific qubit ($\varphi_{(x,n)}$) / qubit array ($\varphi_{x}$) that it targets at, which does not create entanglement with other subsystems.
% This clear separation only works for the domain $\hsp{S}^d$.
% When we compile these operations to \sqir and see their effects on a general Hilbert space $\hsp{H}$, they might have entanglement effects.
% \yxp{Even if we turn it into unitary over the Hilbert space, it still does not generate entanglement with other subsystems.}
% \liyi{Can you have CNOT x y when you have x is Had and y is in Nor, then you will definitely have entanglement. }
% However, the clear separation in $\hsp{S}^d$ provides us a decompositional and analytical way of verifying and validating quantum oracles; thus, each sub-oracle-component can be analyzed individually. The potential entanglements in a general Hilbert space becomes the naturally extended (additive) superposition effects.
% In addition, all semantic functions in Fig.~\ref{fig:deno-sem} are carefully engineered to only target qubits in a register $\varphi$, and does not target on invidual vectors in the vector space $\varphi$ represents.
% For example, $\xsem$ is defined for a basis phase space case $\ket{c}$, and we also define the case for superposition $\frac{1}{\sqrt{2}}(\ket{0}+(-1)^c\ket{1})$. We do not assume the the semantics of the basis phase space is automatically extended to dealing with individual elements in the superposition case.
% By using the semantics to prove quantum oracle properties, we only need to consider $O(n)$ qubits instead of the possible $2^n$ expanded vector elements.
% The semantics of a universal quantum assembly language like \sqir, by contrast, represents a quantum state as a unitary matrix whose size is \emph{exponential} in the number of vectors by expanding qubits to vectors in a register. \sqir's semantics also relies on the use of concrete qubits; using a unitary matrix and virtual positions would inject a virtual-to-physical mapping into the semantic definition, which can severely complicate proofs~\cite{PQPC}. This leads to the successful correctness proof of the QFT-adder for the first time (Sec.~\ref{sec:op-verification}).
% We only define semantic functions for qubit forms when it is possible to apply. For example, we do not define $\xsem$ for the form $\frac{1}{\sqrt{2}}(\ket{0}+e^{2\pi{i} b}\ket{1})$, because the \oqasm type system does not allow it. 

\ignore{
\begin{figure*}[t]
{\footnotesize
  \begin{mathpar}

    \inferrule[PA-NOR ]{(\itau ,\itau')\models_g (T,\ssassign{\overline{l}}{}{a},T'):\zeta\triangleright\ttype{n}{\tnor{\overline{d}}}}
                {\Omega\vdash_g\fivepule{T}{P[\llbracket a \rrbracket \zeta /\zeta] } {\ssassign{\overline{l}}{}{a}} {T'}{P}}


    \inferrule[PA-CH ]{(\itau,\itau')\models_g (T,\ssassign{\overline{l}}{}{a},T'):\zeta\uplus\zeta'\triangleright \ttype{n}{\tch{m}{\beta}}
                 \\ \itau(\overline{l})=\zeta}
       {\Omega\vdash_g\fivepule{T}{P[\forall k < m.\;\llbracket a \rrbracket(\zeta[k]) / \zeta[k]] } {\ssassign{\overline{l}}{}{a}}{T'}{P}}


    \inferrule[P-MEA ]{ (\itau[\forall \zeta'\;.\;\zeta\uplus\zeta' \mapsto \ttype{n+n'}{\tch{(m\times m')}{(\beta\cdot\beta')}}],\itau'[\forall \zeta'\;.\;\zeta' \mapsto \ttype{n'}{\tch{m'}{\beta'}}])\models_{\cmode} (T,y,T''):\zeta\triangleright \ttype{n}{\tch{m}{\beta}}
  \\ v < m \\
   \Omega[x\mapsto M,y\mapsto \bot]\vdash_{\cmode} \fivepule{T''}{P[(\iasa{2}{\zeta[v]},\ibs{\zeta[v]}) /x, \bot / \zeta] } {s} {T'}{Q} } {\Omega\vdash_{\cmode}\fivepule{T}{P}{\sexp{x}{\smea{y}}{s}}{T'}{Q}}

    \inferrule[P-IF ]{(\itau,\itau')\models_{\qmode} (T,s,T'):\zeta'\triangleright \ttype{n'}{\tch{m'}{\beta'}}
      \\\Omega\vdash b(@x[v]): \zeta\uplus[(x,v,v+1)] \\ \itau(\zeta\uplus[(x,v,v+1)])= \ttype{n}{\tch{2m}{(\beta_1\cdot 0 \cup \beta_2\cdot 1)}}
       }{\Omega\vdash_{g}\fivepule{T}{P[(\zeta\uplus 0 \uplus \zeta')\texttt{++}(\zeta\uplus 1 \uplus \llbracket s \rrbracket\zeta') /\zeta\uplus[(x,v,v+1)]\uplus\zeta'] }
      {\sifq{b(@x[v])}{s}}{T'}{P}}
    
    \inferrule[P-DIS ]{(\itau,\itau')\models_g (T,\sdistr{x},T'):\zeta\triangleright \ttype{n'}{\tch{m'}{\beta'}}
             \\ \itau(x)=\{\zeta:\ttype{n'}{\tch{m}{\beta}}\}
    \\\zeta = \zeta' \uplus (x,0,\Sigma(x))
    \\ \beta_1 \cdot \beta_2=\beta(\downarrow (x,0,\Sigma(x)))\cdot \beta(\downarrow \zeta') } 
           {\Omega\vdash_g\fivepule{T}{P[\texttt{dis}(n',\zeta,\beta,\beta_1,\beta_2) /\zeta] }
      {\sdistr{x}}{T'}{P}}


  \end{mathpar}
}
{\footnotesize
\[
\begin{array}{l}
\texttt{ln}(\zeta)\text{: length of }\zeta
\qquad
\texttt{as}(\zeta[v])\text{: the amplitude of }\zeta[v]
\qquad
\texttt{bs}(\zeta[v])\text{: the base of }\zeta[v]
\qquad
\texttt{++}\text{: array concatenation.}
\\
\texttt{dis}(n,\zeta,\beta,\beta_1,\beta_2)\equiv \{\frac{1}{2^{n-1}}(\sum_k \texttt{as}(\zeta[k])-\texttt{as}(\zeta[j]))\beta_1[j]
                           \;|\; \beta_1[j]\in \tpower{n} \}
\\
\qquad\qquad\qquad\qquad\qquad
\cup  \bigcup_{j\in \beta_2}\{\frac{1}{2^{n}}\sum_k \texttt{as}(\zeta[k])z
                           \;|\; z\in \tpower{n} \wedge (\forall k.\;z \cdot \beta_2[j] \neq \beta[k]) \}
\end{array}
\]
}
\caption{Selected Proof System Rules}
\label{fig:exp-proofsystem}
\end{figure*}
}
\subsection{Logic Proof System}\label{sec:logical}


The reason of having the session type system in \Cref{fig:exp-sessiontypea}
is to enable the proof system given in \Cref{fig:exp-proofsystem}.
Every proof rule is a structure as $\Omega\vdash_g \fivepule{T}{P}{s}{T'}{Q}$,
where $g$ and $\Omega$ are the type entities mentioned in \Cref{sec:typesystem}.
$T$ and $T'$ are the pre- and post- type predicates for the statement $s$, 
meaning that there is type environments $\itau$ and $\itau'$, such that $\itau\models T$,
$\itau'\models T'$, $g,\Omega,\itau \vdash s : \zeta\triangleright \tau$, and $(\zeta\mapsto \tau) \in \itau'$.
We denote $(\itau,\itau')\models (T,s,T'):\zeta\triangleright\tau$ as the property described above.
$P$ and $Q$ are the pre- and post- Hoare conditions for statement $s$.

The proof system is an imitation of the classical Hoare Logic array theory.
We view the three different quantum state forms in \Cref{fig:vqir-state} as arrays with elements in different forms,
and use the session types to guide the occurrence of a specific form at a time.
Sessions, like the array variables in the classical Hoare Logic theory,
represent the stores of quantum states.
The state changes are implemented by the substitutions of sessions
with expressions containing operation's semantic transitions.
The substitutions can happen for a single index session element or the whole session.

Rule \text{PA-NOR} and \text{PA-CH} specify the assignment rules.
If a session $\zeta$ has type \texttt{Nor}, it is a singleton array,
so the substitution $\llbracket a \rrbracket \zeta /\zeta$ means
that we substitute the singleton array by a term with the $a$'s application.
When $\zeta$ has type \texttt{CH}, term $\zeta[k]$ refers to each basis state in the entanglement.
The assignment is an array map operation that applies $a$ to every element in the array.
For example, in \Cref{fig:shorexample} line 12,
we apply a series of \code{H} gates to array $x$.
Its post-condition is $[(x,0,n)]=\Motimes_{k=0}^{n}\ket{\Phi(0)}$,
where $[(x,0,n)]$ is the session representing register variable $x$.
Thus, replacing the session $[(x,0,n)]$ with the \code{H} application
results in a pre-condition as $\code{H}[(x,0,n)]=\Motimes_{k=0}^{n}\ket{\Phi(0)}$,
which means that $[(x,0,n)]$ has the state $\ket{0}^n$.

Rule \text{P-MEA} is the rule for partial/complete measurement.
$y$'s session is $\zeta$, but it might be a part of an entangled session $\zeta\uplus\zeta'$.
After the measurement, $M$-mode $x$ has the measurement result $(\ias{\zeta[v]}^2,\ibs{\zeta[v]})$ coming
from one possible basis state of $y$ (picking a random index $v$ in $\zeta$), 
$\ias{\zeta[v]}$ is the amplitude and $\ibs{\zeta[v]}$ is the base.
We also remove $y$ and its session $\zeta$ ($\bot/\zeta$) in the new pre-condition because it is measured away.
The removal means that the entangled session $\zeta\uplus\zeta'$ is replaced by $\zeta'$ 
with the re-computation of the amplitudes and bases for each term.

Rule \text{P-IF} deals with a quantum conditional where the Boolean guard $b(@x[v])$ is of type $\ttype{n}{\tch{2m}{(\beta_1\cdot 0 \cup \beta_2\cdot 1)}}$. The bases are split into two sets $\beta_1\cdot 0$ and $\beta_2\cdot 1$, where the last bit represents the base state for the $x[v]$ position.
In quantum computing, a conditional is more similar to an assignment, where we create a new array to substitute 
the current state represented by the session $\zeta\uplus[(x,v,v+1)]\uplus\zeta'$.
Here, the new array is given as $(\zeta\uplus 0 \uplus \zeta')\texttt{++}(\zeta\uplus 1 \uplus \llbracket s \rrbracket\zeta')$,
where we double the array: if the $x[v]$ position is $0$, we concatenate the current session $\zeta'$ for the conditional body,
if $x[v]=1$, we apply $\llbracket s \rrbracket$ on the array $\zeta'$ and concatenate it to $(\zeta\uplus 1)$.

Rule \text{P-Loop} is an initiation of the classical while rule in Hoare Logic with the loop guard possibly having quantum variables.
In QWhile, we only has \texttt{for-loop} structure and we believe it is enough to specify any current quantum algorithms.
For any $i$, if we can maintain the loop invariant $P(i)$ and $T(i)$ with the post-state $P(f(i))$ and $T(f(i))$
for a single conditional $\sifq{x[i]}{s}$, the invariant is maintained for multiple steps
for $i$ from the lower-bound $a_1$ to the upper bound $a_2$.

Rule \text{P-DIS} proves a diffusion operator $\sdistr{x}$.
The quantum semantics for $\sdistr{x}$ is $\frac{1}{2^{n}}(2\sum_{i=0}^{2^n}(\sum_{j=0}\alpha_j)\ket{i} - \sum_{j=0}\alpha_j\ket{x_j})$.
As an array operation, $\sdistr{x}$ with the session $\zeta$ is an array operation as follows:
assume that $\zeta=(x,0,\Sigma(x))\uplus\zeta_1$, for every $k$,
if $\zeta[k]$'s value is $\theta_k(\overline{d_x}\cdot \overline{d_1})$,
for any bitstring $z$ in $\tpower{\Sigma(x)}$, if $z\cdot \overline{d_1}$
is not a base for $\zeta[j]$ for any $j$, then the state is
$\frac{1}{2^{n-1}}\sum_{k=0}\theta_k(z\cdot \overline{d_1})$;
if the base of $\zeta[j]$ is $z\cdot \overline{d_1}$,
then the state for $\zeta[j]$ is $\frac{1}{2^{n-1}}(\sum_{k=0}\theta_k)-\theta_j(z\cdot \overline{d_1})$.



We evaluate \name by (1) demonstrating how it can be used for validation, both by verification and random testing, and (2) by showing that it gets good performance in terms of resource usage compared to Quipper, a state-of-the-art quantum programming framework~\cite{Green2013}.
%
This section presents the arithmetic operators we have implemented in
\oqasm, while the next section discusses the geometric operators and
expressions implemented in \vqimp. The following section presents an
end-to-end case study applying Grover's search.

\begin{figure}[t]
{\small
\[\hspace*{-1em}
\begin{array}{r l  l}
\textcolor{blue}{1}
&&
\{A(x) * A(y) \}
\quad\text{where}\;\;
A(\beta) = \beta[0..n] \mapsto \ket{\overline{0}} 
\\[0.2em]
&&
\qquad\qquad\qquad
\qquad\qquad\quad
\begin{array}{l}
B = 1 < a < N \wedge n > 0 \;\wedge
\\\qquad N < 2^n \wedge \texttt{gcd}(a,N)=1
\end{array}
\\[0.5em]
\textcolor{blue}{2}
&
&
\textcolor{teal}{
\Rightarrow
\{\dabs{\ihadh}(x[0..n]) \mapsto C * A(y) * B \}
}
\\[0.2em]
&&
\qquad\qquad\qquad
\qquad\;\;
\text{where}
\;\;
\textcolor{teal}{
C = \shad{2^n}{n}{}
}
\\[0.5em]
\textcolor{blue}{3}
& \ssassign{x}{}{\ihadh};
&
\textcolor{teal}{
\{x[0..n] \mapsto C * A(y) * B \}
}
\\[0.4em]
\textcolor{blue}{4}
&
&
\textcolor{teal}{
\Rightarrow
\{x[0..n] \mapsto C * \dabs{y\splus 1}(y[0..n]) \mapsto \ket{\overline{0}.1} * B \}
}
\\[0.4em]
\textcolor{blue}{5}
& \ssassign{y}{}{y\splus 1};
&
\textcolor{teal}{
\{x[0..n] \mapsto C * y[0..n] \mapsto \ket{\overline{0}.1} * B \}
}
\\[0.4em]
\textcolor{blue}{6}
& 
&
\textcolor{teal}{
\Rightarrow
\{ E(0) * B \}
}
\;\;
\texttt{where}\;\;
\textcolor{teal}{E(k) =}
\\[0.2em]
&&
\qquad\qquad\quad\;
\qquad
\textcolor{teal}{
\begin{array}{l}
x[0..n\,\sminus\,k] \mapsto \shad{2^{n \,\sminus\,  k}}{n \,\sminus\, k}{}\;*
\\[0.2em]
\{x[0..k],y[0..n]\} \mapsto \sch{2^k}{\frac{1}{\sqrt{2^k}}}{\tos{j}.\tos{a^{j}\;\%\;N}}
\end{array}
}
\\[0.4em]
\textcolor{blue}{7}
&\sqforh{\sint{j}{0}}{j\,\slt\, n}{x[j]}{\dplus{j}}
&
\{E(j) * B \}
\\[0.4em]
\textcolor{blue}{8}
&
\{\quad  \ssassign{y}{}{a^{2^j}y\;\%\; N}
&
\textcolor{teal}{
\{E(j\,\splus\, 1) * B \}
}
\\[0.4em]
\textcolor{blue}{9}
&
\}
&
\textcolor{teal}{
\{E(n) * B \}
}
\\[0.4em]
\textcolor{blue}{10}
&
&
\textcolor{teal}{
\Rightarrow
\{\{x[0..n],y[0..n]\} \mapsto \sch{2^{n}}{\frac{1}{\sqrt{2^{n}}}}{\tos{j}.\tos{a^{j}\;\%\;N}} * B \}
}
\\[0.4em]
\textcolor{blue}{11}
& \sexp{u}{\smea{y}}{...}
&
\textcolor{purple}{
\big{\{}
\begin{array}{l}
x[0..n] \mapsto \smch{\frac{1}{\sqrt{s}}}{s}{t\,\splus\,k p} 
\wedge
p = \texttt{ord}(a,N)
\\
\wedge\;
\texttt{nat}(u)=a^{t}\;\%\;N
\wedge
s=\texttt{rnd}(\frac{2^n}{p}) \wedge B
\end{array}
\big{\}}
}
\end{array}
\]
}
\caption{Pre-measurement quantum steps of the Shor's algorithm. Second half in \Cref{fig:shorqafny2}. $\snat{u}$ gets the integer number part of $u$ (mode $\mmode$). $\sord{a,N}$ gets the order of $a$ and $N$. $\srnd{r}$ rounds $r$ to the nearest integer. }
\label{fig:shorqafnyaa}
\end{figure}

\begin{figure}[t]
{\small
\[
\begin{array}{r l  l}
\textcolor{blue}{11}
&
\sexp{z}{\smea{y}}{}
&
\textcolor{purple}{
\big{\{}
\begin{array}{l}
x[0..n] \mapsto \smch{\frac{1}{\sqrt{s}}}{s}{t+jr} 
\wedge
\\
\texttt{nat}(z)=a^{n}\;\%\;N
\wedge
s=\texttt{rnd}(\frac{2^n}{r}) \wedge B
\end{array}
\big{\}}
}
\\[0.4em]
\textcolor{blue}{12}
&
\quad\ssassign{x}{}{\iqft[-1]{}{}}; 
&
\textcolor{teal}{
\big{\{}
x[0..n] \mapsto \smich{\frac{1}{\sqrt{s 2^n}}}{2^n}{(\omega^{tk}\Msum_{j=0}^{s}\omega^{tkj})}{k} 
\wedge
s=\texttt{rnd}(\frac{2^n}{r}) \wedge B
\big{\}}
}
\\[0.4em]
\textcolor{blue}{13}
&
\quad\sexp{u}{\smea{x}}{}
&
\textcolor{teal}{
\big{\{}
\texttt{nat}(u)=r \wedge \texttt{pos}(u)=\frac{4}{\pi ^ {2 r}}
\wedge
s=\texttt{rnd}(\frac{2^n}{r}) \wedge r = \texttt{ord}(a,N) \wedge B
\big{\}}
}
\\[0.4em]
\textcolor{blue}{14}
&
\quad\quad\texttt{post}(u)
&
\big{\{}
\texttt{nat}(\texttt{post}(u))=r \wedge r = \texttt{ord}(a,N) \wedge \texttt{pos}(u)=\frac{4e^{-2}}{\pi^2 \texttt{log}_2^4 N \wedge B}
\big{\}}
\end{array}
\]
}
{\footnotesize
\[
B=1 < a < N \wedge n > 0 \wedge N < 2^n \wedge \texttt{gcd}(a,N)=1
\qquad
\omega=e^{\frac{2\pi i}{2^n}}
\]
}
\caption{Second half of the Shor's algorithm quantum part in Qafny.}
\label{fig:shorqafny2}
\end{figure}


\subsection{Implemented Operators}

\Cref{fig:circ-evaluation} and \Cref{fig:op-table} tabulate the
arithmetic operators we have implemented in \vqir. 

The addition and modular multiplication circuits 
(parts (a) and (d) of \Cref{fig:circ-evaluation}) are components of the oracle used in Shor's factoring algorithm~\cite{shors}, which accounts for most of the algorithm's cost \cite{Gidney2021howtofactorbit}.
The oracle performs modular exponentiation on natural numbers via modular multiplication, which takes a quantum variable $x$ and two co-prime constants $M, N \in \mathbb{N}$ and produces $(x * M) \% N$. We have implemented two modular multipliers---inspired by \citet{qft-adder}
and \citet{ripple-carry-mod}---in \vqir. 
Both modular multipliers are constructed using controlled modular addition by a constant, which is implemented in terms of controlled addition and subtraction by a constant, as shown in \Cref{fig:mod-mult}.
The two implementations differ in their underlying adder and subtractor circuits: the first (QFT) uses a quantum Fourier transform-based circuit for addition and subtraction \cite{Draper2000AdditionOA}, while the second (TOFF) uses a ripple-carry adder \cite{ripple-carry-mod}, which makes use of classical controlled-controlled-not (Toffoli) gates.


\begin{figure}
{\footnotesize
{\hspace*{-6em}
\begin{minipage}[t]{0.35\textwidth}
\begin{center}
 \[
  \begin{array}{l@{~}cl}
  \tau & \sqsubseteq & \tau \\
  \tnort &\sqsubseteq& \tcht\\
  \thadt &\sqsubseteq& \tcht
    \end{array}
  \]
\end{center}
\subcaption{Subtyping}
  \label{fig:qafny-subtype}
\end{minipage}
\qquad
\begin{minipage}[t]{0.5\textwidth}
\begin{center}
   \[
   \begin{array}{l@{~}cl}
   q & \equiv_{\slen{q}} & q \\
  \ket{c} &\equiv_n& \sch{1}{ }{c}\\
  \shad{2^n}{n}{\alpha(r_j)} &\equiv_n& \sch{2^n}{\frac{\alpha(\sum_{k=0}^{n} r_k \cdot \tos{j}[k])}{\sqrt{2^n}}}{j}
    \end{array}
 \]
\end{center}
\subcaption{Quantum Value Equivalence}
  \label{fig:qafny-sequiv}
\end{minipage}
\hfill{}
\begin{minipage}[t]{0.8\textwidth}
\begin{center}
 \[
  \begin{array}{l @{~} c @{~} l l@{~}c @{~} l l @{~}c @{~} l l @ {~} c @{~} l}
\lambda &\equiv & \lambda
&
\qquad
x[n,n] & \equiv & \bot
&
\qquad
\bot \uplus \lambda & \equiv & \lambda
&
\qquad
x[n,m]\uplus\lambda & \equiv & x[n,j]\uplus x[j,m] \uplus\lambda
\\
&&&&&&&&&&&
\texttt{where}\;\;n \le j < m

    \end{array}
  \]
\end{center}
\subcaption{Session Equivalence}
  \label{fig:qafny-ses-equal}
\end{minipage}
\hfill{}
\hspace*{-5em}
\begin{minipage}[t]{0.475\textwidth}
\begin{center}
 \[
  \begin{array}{l@{~}c@{~}l}
    \sigma & \preceq & \sigma \\[0.2em]
  \{\bot:\tau\} \cup \sigma &\preceq& \sigma\\[0.2em]
   \{\lambda:\tau\} \cup \sigma &\preceq& \{\lambda:\tau'\} \cup \sigma\\
&&\texttt{where}\;\;\tau\sqsubseteq_{\slen{\lambda}}\tau' \\[0.2em]
  \{\lambda_1\uplus l_1 \uplus l_2 \uplus \lambda_2 :\tau\} \cup \sigma &\preceq& \{\lambda_1\uplus l_2 \uplus l_1 \uplus \lambda_2 : \tau\} \cup \sigma\\[0.2em]
  \{\lambda_1 :\tau\} \cup \{\lambda_2 :\tau\} \cup \sigma &\preceq& \{\lambda_1 \uplus \lambda_2 :\tau\} \cup \sigma \\[0.2em]
  \{\lambda_1 \uplus \lambda_2 :\tau\} \cup \sigma &\preceq& \{\lambda_1 :\tau\} \cup \{\lambda_2 :\tau\} \cup \sigma
\\
&&\texttt{where}\;\;\tau\neq\tcht
    \end{array}
  \]
\end{center}
\subcaption{Environment Equivalence}
  \label{fig:env-equiv}
\end{minipage}
\begin{minipage}[t]{0.475\textwidth}
\begin{center}
   \[
   \begin{array}{l@{~}c@{~}l}
    \varphi & \equiv & \varphi \\[0.2em]
  \{\bot:q\} \cup \varphi &\equiv& \varphi\\[0.2em]
   \{\lambda:q\} \cup \varphi &\equiv& \{\lambda:q'\} \cup \varphi\\
   &&\texttt{where}\;\;q\equiv_{\slen{\lambda}}q' 
   \\[0.2em]
  \{\lambda_1\uplus l_1 \uplus l_2 \uplus \lambda_2 :q\} \cup \varphi &\equiv& \{\lambda_1\uplus l_2 \uplus l_1 \uplus \lambda_2 : \texttt{mut}(q,\slen{\lambda_1})\} \cup \varphi\\[0.2em]
  \{\lambda_1 :q_1\} \cup \{\lambda_2 :q_2\} \cup \varphi &\equiv& \{\lambda_1 \uplus \lambda_2 :\texttt{mer}(q_1,q_2)\} \cup \varphi 
   \\[0.2em]
  \{\lambda_1 \uplus \lambda_2 :\varphi\} \cup \sigma &\equiv& \{\lambda_1 :\varphi_1\} \cup \{\lambda_2 :\varphi_2\} \cup \sigma
\\
&&\texttt{where}\;\;\texttt{spt}(\tau,\slen{\lambda_1})=(\varphi_1,\varphi_2)
    \end{array}
 \]
\end{center}
\subcaption{State Equivalence}
  \label{fig:qafny-stateequiv}
\end{minipage}
{\footnotesize
\[
\begin{array}{l}
\texttt{pmut}((c_1.i_1.i_2.c_2),n)=(c_1.i_2.i_1.c_2) \;\;\texttt{when}\;\slen{c_1}=n
\\[0.2em]
\texttt{mut}(\ket{c},n)=\ket{\texttt{pmut}(c,n)}
\\[0.2em]
\texttt{mut}(\frac{1}{\sqrt{2^m}}(q_1 \bigotimes (\ket{0}+\alpha(r_n)\ket{1}) \bigotimes (\ket{0}+\alpha(r_{n+1})\ket{1}) \bigotimes q_2),n)
\\
\qquad\qquad
=\frac{1}{\sqrt{2^m}}(q_1 \bigotimes (\ket{0}+\alpha(r_{n+1})\ket{1}) \bigotimes (\ket{0}+\alpha(r_n)\ket{1}) \bigotimes q_2)
\quad\texttt{when\;}\slen{q_1}=n
\\[0.2em]
\texttt{mut}(\sch{m}{z_j}{c_j},n)=\sch{m}{z_j}{\texttt{pmut}(c_j,n)}
\\[0.2em]
\texttt{mer}(\ket{c_1},\ket{c_2})=\ket{c_1.c_2}
\\[0.2em]
\texttt{mer}(\shad{2^n}{n}{\alpha(r_j)},\shad{2^m}{m}{\alpha(r_j)})=\shad{2^{n+m}}{n+m}{\alpha(r_j)}
\\[0.2em]
\texttt{mer}(\sch{n}{z_j}{c_j},\schk{m}{z_k}{c_k})=\schi{n*m}{z_j\cdot z_k}{c_j.c_k}
\\[0.2em]
\texttt{spt}(\ket{c_1.c_2},n)=(\ket{c_1},\ket{c_2}) \;\;\texttt{when}\;\slen{c_1}=n
\\[0.2em]
\texttt{spt}(q_1\bigotimes q_2,n)=(q_1,q_2) \;\;\texttt{when}\;\slen{q_1}=n
\end{array}
\]
}
  \caption{\qafny type/state relations. $\{\tos{j}|j\in[0,2^n)\}(2^n)$ defines a set $\{\tos{j}|j\in[0,2^n)\}$ with the emphasis that it has $2^n$ elements. $\{0,1\}$ is a set of two single element bitstrings $0$ and $1$. $\cdot$ is the multiplication operation, $\tos{j}$ turns a number $j$ to a bitstring, $\tos{j}[k]$ takes the $k$-th element in the bitstring $\tos{j}$, and $\ket{j}$ is an abbreviation of $\ket{\tos{j}}$. We use set union ($\cup$) to describe the state concatenation with the empty set operation $\emptyset$. $i$ is a single bit either $0$ or $1$. The $.$ operation is bitstring concatenation. Term $\Msum^{n*m}P$ is a summation formula that omits the indexing details.
Term $(\frac{1}{\sqrt{2^{n}}}\Motimes_{j=0}^{n}q_j) \bigotimes(\frac{1}{\sqrt{2^{m}}}\Motimes_{j=0}^{m}q_j)$ is equivalent to $\frac{1}{\sqrt{2^{n+m}}}\Motimes_{j=0}^{n+m}q_j$.}
  \label{fig:qafny-eq}
}
}
\end{figure}

\subsection{State Equivalence}

As we suggested in \Cref{sec:shors}, quantum states have certain level of permutation symmetries. Essentially, quantum computation is implemented as circuits. In \Cref{fig:background-circuit-example}, if the first and second circuit lines and qubits are permuted, it is intuitive that the two circuit results are equivalence up to the permutation. Additionally, as indicated in \Cref{sec:shors}, we need quantum sessions to be split and regrouped sometimes. All these properties are formulated in \qafny as equational properties in \Cref{fig:qafny-eq} that rely on session rewrites, which can then be used as builtin libraries in the proof system. As one can imagine, the equational properties might bring nondeterminism in the \qafny implementation, such that the automated system does not know which equations to apply in a step. In dealing with the nondeterminism, we design a type system for \qafny to track the uses, split, and join of sessions, as well as the three state types in every transition step, so that the system knows exactly how to apply an equation.

\Cref{fig:qafny-eq} shows the equivalence relations on types and states.
\Cref{fig:qafny-subtype} shows the subtyping relation such that $\tnort$ and $\thadt$ subtype to $\tcht$.
Correspondingly, the subtype of $\tnort$ to $\tcht$ represents the first line equation in \Cref{fig:qafny-sequiv}, where a $\tnort$ state is converted to a $\tcht$ form. Similarly, a $\thadt$ state can also be converted to a $\tcht$ state in the second line.
Additionally, \Cref{fig:qafny-ses-equal} defines the equivalence relations for the session concatenation operation $\uplus$: it is associative, identitive with the identity empty session element $\bot$.
We also view a range $x[n,n]$ to be empty ($\bot$), and a range $x[n,m]$ can be split into a two ranges in the session as $x[n,j] \uplus x[j,m]$. 

The main result to define state equivalence is to capture the permutation symmetry, split, and join of sessions introduced in \Cref{sec:shors}. The first rule describes the case for empty session, while the second rule in \Cref{fig:qafny-stateequiv} connects the quantum value equivalence to the state equivalence.
The third rule describes the qubit permutation equivalence by the \texttt{mut} function.
The fourth rule describes the join of two sessions in a state.
For the two sessions are of the type $\tnort$ and $\thadt$, a join means an array concatenation.
If the two sessions have $\tcht$ types, a join means a Cartesian product of the two basis states.
The final rule is to split a session, where we only allows the split of a $\tnort$ and $\thadt$ type state and their splits are simply array splits. Splitting a $\tcht$ type state is equivalent to qubit disentanglement, which is a hard problem and we need to upgrade the type system to permit certain types of such disentanglement. In \Cref{sec:newtype}, we upgrade the \qafny type system to a dependent type system to track the disentanglement of $\tcht$ type state.

\begin{figure*}[t]
{\small
\begin{tabular}{l}   
{\noindent\textcolor{blue}{\text{Predicate modeling:}}}\\

  \begin{mathpar}
    \inferrule[]{\Omega;\sigma\vdash \kappa \\  \models \varphi(\kappa) \mapsto q }{\Omega;\sigma,\varphi\models \kappa \mapsto q }

    \inferrule[]{ q\equiv_{\slen{q}} q' }{\models q \mapsto q' }

    \inferrule[]{ \sch{m}{z_j}{c_j} \subseteq \sch{m}{z'_j}{c'_j} \\ 
             \sch{m}{z'_j}{c'_j} \subseteq \sch{m}{z_j}{c_j} }{\models \sch{m}{z_j}{c_j} \mapsto \sch{m}{z'_j}{c'_j} }

    \inferrule[]{\sigma \bot \sigma' \\ \varphi \bot \varphi' 
      \\ \Omega;\sigma, \varphi \models P \\ \Omega;\sigma',\varphi' \models Q}
        {\Omega;\sigma \cup \sigma',\varphi \cup \varphi'\models P * Q }

    
  \end{mathpar}

\\[1em]
{\noindent\textcolor{blue}{\text{Sequence Semantic and Proof Rules:}}}\\[0.5em]


  \begin{mathpar}
    \inferrule[SSeq-1]{(\varphi,s_1) \longrightarrow (\varphi',s'_1)}{(\varphi,\sseq{s_1}{s_2})\longrightarrow (\varphi',\sseq{s'_1}{s_2}) }

    \inferrule[SSeq-2]{}{(\varphi,\sseq{\{\}}{s_2})\longrightarrow (\varphi,s_2) }

    \inferrule[PSeq]{
          \Omega;\sigma\vdash_g s_1 \triangleright \sigma' \\\\
       \fivepule{\Omega}{\sigma}{g}{P}{s_1}{R} \\ 
           \fivepule{\Omega}{\sigma[\uparrow \sigma']}{g}{R}{s_2}{Q}}
                {\fivepule{\Omega}{\sigma}{g}{P}{\sseq{s_1}{s_2}}{Q}}

  \end{mathpar}

\\[1em]
{\noindent\textcolor{blue}{\text{Pre-condition strengthening and Post-condition weakening Proof Rules:}}}\\[0.5em]

  \begin{mathpar}
    \inferrule[PConL]{
       (\Omega,\sigma,P) \Rightarrow (\Omega,\sigma',P') \\ \fivepule{\Omega}{\sigma'}{g}{P'}{s}{Q}}
                {\fivepule{\Omega}{\sigma}{g}{P}{s}{Q}}

    \inferrule[PConR]{\Omega,\sigma\vdash_g s_1 \triangleright \sigma'\\\\
          \fivepule{\Omega}{\sigma'}{g}{P}{s}{Q'} \\(\Omega,\sigma'',Q') \nRightarrow (\Omega,\sigma[\uparrow \sigma'],Q) }
                {\fivepule{\Omega}{\sigma}{g}{P}{s}{Q}}
  \end{mathpar}
\end{tabular}
}
{\footnotesize
\[
\begin{array}{l}
\\
(\Omega,\sigma,P) \Rightarrow (\Omega,\sigma',P') \triangleq \Omega,\sigma\vdash P \wedge \Omega,\sigma' \vdash P' \wedge \sigma \preceq \sigma' \wedge P \Rightarrow P'
\\[0.2em]
(\Omega,\sigma,Q) \nRightarrow (\Omega,\sigma',Q') \triangleq \Omega,\sigma\vdash Q \wedge \Omega,\sigma' \vdash Q' \wedge \sigma' \preceq \sigma \wedge Q \Rightarrow Q'
\ignore{
\\[0.2em]
\varphi \equiv \varphi' \wedge \varphi \models P \wedge \varphi' \models P' \Rightarrow (P \Leftrightarrow P') 
}
\end{array}
\]
}
\caption{Sequence and Consequence Rules}
\label{fig:exp-proofsystem-1}
\end{figure*}


\begin{figure*}[t]
{\small

\begin{minipage}[t]{0.4\textwidth}
\subcaption{Application Analogy}
  \vspace{1cm}
  \includegraphics[width=\textwidth]{oracle}
  \label{fig:qafny-oracle-analog}
\end{minipage}
\hfill
\begin{minipage}[t]{0.5\textwidth}
\subcaption{App Function Modeling}
  \begin{mathpar}

    \inferrule[]{\forall j.\;\slen{c_{j1}}=n \\ \Omega;\sigma;\varphi\models \sch{m}{z_j}{\denote{\mu}(c_{j1}).c_{j2}\,\beta_j} \mapsto q}
          {\Omega;\sigma;\varphi\models \eth \;n.\denote{\mu}(\sch{m}{z_j}{c_{j1}.c_{j2}\,\beta_j}) 
              \mapsto q }
  \end{mathpar}
  \label{fig:qafny-mu-model}
\end{minipage}

\begin{minipage}[t]{\textwidth}
\subcaption{Semantic/Proof Rules}
  \begin{mathpar}


    \inferrule[SH-N]{ FV(\emptyset,l)= \kappa \\ \varphi(\kappa)=\ket{c} }{ (\varphi,\ssassign{l}{}{\texttt{H}}) \longrightarrow (\varphi[\kappa\mapsto \shad{2^{\slen{c}}}{\slen{c}}{\alpha(\frac{1}{2^{c[j]}})}],\{\}) }

    \inferrule[PH-N]{FV(\Omega,l)=\kappa \\ \sigma(\kappa)=\tau}
                {\fivepule{\Omega}{\sigma}{g}{P[\eth \;\kappa.\denote{\texttt{H}}(\kappa) / \kappa]}{\ssassign{l}{}{\texttt{H}}}{P}}

  \end{mathpar}
  \label{fig:qafny-oracle-rules}
\end{minipage}
}
\caption{Oracle application and state preparation rules. $\eth$ is an array map operation, where $\eth \;\kappa.\denote{\mu}(\kappa \uplus \kappa')$ means that for every basis state in the state of $\kappa \uplus \kappa'$, we apply $\denote{\mu}$ to $\kappa$ part of session. }
\label{fig:exp-proofsystem-2}
\end{figure*}

\ignore{

\begin{minipage}[t]{0.4\textwidth}
\subcaption{Application Analogy}
  \vspace{1cm}
  \includegraphics[width=\textwidth]{oracle}
  \label{fig:qafny-oracle-analog}
\end{minipage}
\hfill
\begin{minipage}[t]{0.5\textwidth}
\subcaption{App Function Modeling}
  \begin{mathpar}

}

{\footnotesize
  \begin{mathpar}
\mprset{flushleft}
\inferrule[]{
   \inferrule[]
   { \inferrule[] {
    \fivepule{\Omega}{\sigma_2}{\mmode}{X(\snext{j}) * \{y[0..n]\}\mapsto C(j).1}{ s }{X(\snext{j}) * \{y[0..n]\}\mapsto C'(j).1} }
  { \fivepule{\Omega}{\sigma_2}{\mmode}{X(\snext{j}) * \mathpzc{M}(b,\{y[0..n]\})\mapsto 0.C(j)+1.C(j)}{ s }{X(\snext{j}) * \{y[0..n]\}\mapsto C'(j).1} } }
   {  \Omega,\sigma_1\vdash_{\mmode} \{X(\snext{j}) * \{x[0..\snext{j}],y[0..n]\}\mapsto 0.C(j)+1.C(j)\} \sifq{x[j]}{s}
     \\\\\qquad\qquad \{ X(\snext{j}) * \mathpzc{U}(\neg x[j],\{x[0..\snext{j}],y[0..n]\})\mapsto 0.C(j)
          * \mathpzc{U}(x[j],\{x[0..\snext{j}],y[0..n]\})\mapsto C'(j).1\}
     } } {
\fivepule{\Omega}{\sigma}{\mmode}{X(j) * \{x[0..j],y[0..n]\}\mapsto C(j)}{ \sifq{x[j]}{s} }{X(j\,\sminus\,1) * \{x[0..\snext{j}],y[0..n]\} \mapsto 0.C(j)+1.C'(j)} }
  \end{mathpar}
{\hspace*{-1.5em}
$\begin{array}{l}
X(j)=\shad{2^{n \,\sminus\,  j}}{n \,\sminus\, j}{}
\quad
C(j)=\sch{2^k}{\frac{1}{\sqrt{2^k}}}{\tos{j}^{k}.\tos{a^{\tos{j}^k}\;\%\;N}}
\quad
i.C(j)=\sch{2^{\snext{k}}}{\frac{1}{\sqrt{2^{\snext{k}}}}}{\tos{j}^k.i.\tos{a^{\tos{j}^k}\;\%\;N}}
\\
C'(j).i=\sch{2^{\snext{k}}}{\frac{1}{\sqrt{2^{\snext{k}}}}}{\tos{a^{\tos{j}^k.1}\;\%\;N}\,|\,\tos{j}^k.i}
\qquad
i.C'(j)=\sch{2^{\snext{k}}}{\frac{1}{\sqrt{2^{\snext{k}}}}}{\tos{j}^k.i.\tos{a^{\tos{j}^k.1}\;\%\;N}}
\\
\sigma_1=\{x[0..n\,\sminus\,\snext{j}] \mapsto \thadt, \{x[0..\snext{j}],y[0..n]\} \mapsto \tcht \}
\quad
\sigma=\{x[0..n\,\sminus\,\snext{j}] \mapsto \thadt, y[0..n] \mapsto \tcht \}
\quad
s=\ssassign{y}{}{a^{2^j}y\;\%\; N}
\end{array}$
}
}


\subsection{Additional Proof Rules}\label{appx:proof-rules}

The proof is built from bottom up. We first cut the $\thadt$ type state into two sessions ($x[0..n\,\sminus\,\snext{j}]$ and $x[j]$), join $x[j]$ with session $\{x[0..j],y[0..n]\}$, and double the state elements to be $0.C(j)+1.C(j)$, which is proved by applying the consequence rules. Notice that the type environment is also transitioned from $\sigma$ to $\sigma_1$.
By the same strategy of the $\mathpzc{U}$ rule in \Cref{fig:qafny-mu-model}, we combine the two $\mathpzc{U}$ terms into the final result. 
The second step applies rule \textsc{PIF} to substitute session $\{x[0..\snext{j}],y[0..n]\}$ with the mask construct $\mathpzc{M}(b,\{y[0..n]\})$ in the pre-condition and create two $\mathpzc{U}$ terms in the post-condition. The step on the top applies the modulo multiplication on every element in the masked state $\mapsto C(j).1$ by rule \textsc{PA-CH}.

\begin{figure*}[t]
{\small
  \begin{mathpar}

\hspace*{-1em}
    \inferrule[Frame]{FV(s)\cap FV(R)=\emptyset \\ FV(s)\subseteq \dom{\sigma} \\\\
       \sigma\bot\sigma' \\ \fivepule{\Omega}{\sigma}{g}{P}{s}{Q}}
                {\fivepule{\Omega}{\sigma\cup\sigma'}{g}{P * R}{s}{Q * R}}

    \inferrule[]{\sigma \bot \sigma' \\ \varphi \bot \varphi' 
      \\ \Omega;\sigma; \psi; \varphi \models_g P \\ \Omega;\sigma';\psi; \varphi' \models_g Q}
        {\Omega;\sigma \cup \sigma';\psi; \varphi \cup \varphi'\models_g P * Q }

    \inferrule[SSeq-1]{(\psi,\varphi,s_1) \longrightarrow (\psi',\varphi',s'_1)}{(\psi,\varphi,\sseq{s_1}{s_2})\longrightarrow (\psi',\varphi',\sseq{s'_1}{s_2}) }
\quad
    \inferrule[SSeq-2]{}{(\psi,\varphi,\sseq{\{\}}{s_2})\longrightarrow (\psi,\varphi,s_2) }
\quad
    \inferrule[PSeq]{
          \Omega;\sigma\vdash_g s_1 \triangleright \sigma' \\\\
       \fivepule{\Omega}{\sigma}{g}{P}{s_1}{R} \quad
           \fivepule{\Omega}{\sigma[\uparrow \sigma']}{g}{R}{s_2}{Q}}
                {\fivepule{\Omega}{\sigma}{g}{P}{\sseq{s_1}{s_2}}{Q}}


    \inferrule[PConL]{
       (\Omega,\sigma,P) \Rightarrow (\Omega,\sigma',P') \\ \fivepule{\Omega}{\sigma'}{g}{P'}{s}{Q}}
                {\fivepule{\Omega}{\sigma}{g}{P}{s}{Q}}

    \inferrule[PConR]{\Omega,\sigma\vdash_g s_1 \triangleright \sigma'\\\\
          \fivepule{\Omega}{\sigma'}{g}{P}{s}{Q'} \\(\Omega,\sigma'',Q') \nRightarrow (\Omega,\sigma[\uparrow \sigma'],Q) }
                {\fivepule{\Omega}{\sigma}{g}{P}{s}{Q}}
  \end{mathpar}
}
{\footnotesize
\[
\begin{array}{l}
\\
(\Omega,\sigma,P) \Rightarrow (\Omega,\sigma',P') \triangleq \Omega,\sigma\vdash P \wedge \Omega,\sigma' \vdash P' \wedge \sigma \preceq \sigma' \wedge P \Rightarrow P'
\\[0.2em]
(\Omega,\sigma,Q) \nRightarrow (\Omega,\sigma',Q') \triangleq \Omega,\sigma\vdash Q \wedge \Omega,\sigma' \vdash Q' \wedge \sigma' \preceq \sigma \wedge Q \Rightarrow Q'
\ignore{
\\[0.2em]
\varphi \equiv \varphi' \wedge \varphi \models P \wedge \varphi' \models P' \Rightarrow (P \Leftrightarrow P') 

\\[0.2em]
 q(c_j) = \scha{m}{z_j}{c_{j}}{\beta_j}
\qquad \llbracket \mu \rrbracket c_{j} = z'_j\ket{c'_{j}}
}
\end{array}
\]
}
\caption{Sequence and Consequence Rules}
\label{fig:exp-proofsystem-seq}
\end{figure*}

\subsection{Well-formed Sessions and Predicates}\label{appx:well-formed}

\begin{definition}[Well-formed session domain]\label{def:well-formed-ses}\rm 
  The domain of a environment $\sigma$ (or state $\varphi$) is \emph{well-formed}, written as
  $\Omega \vdash \dom{\sigma}$ (or $\dom{\varphi}$), iff for every session $\kappa\in \dom{\sigma}$ (or $\dom{\varphi}$):
\begin{itemize}
\item $\kappa$ is disjoint unioned, i.e., for every two ranges $x[i..j]$ and $y[i'..j']$, $x[i..j]\cap y[i'..j']=\emptyset$.

\item For every range $x[i..j]\in\kappa$, $\Omega(x)=\qmode{n}$ and $[i,j) \subseteq [0,n)$.
\end{itemize}
\end{definition}

\begin{definition}[Well-formed state predicate]\label{def:well-formed-pred}\rm 
  A predicate $P$ is well-formed, written as $\Omega,\sigma \vdash P$, iff every variable and session appearing in $P$ is defined in $\Omega$ and $\sigma$, respectively; particularly, if $P=\kappa \mapsto q * P'$, $\kappa \in \dom{\sigma}$.
\end{definition}

\begin{figure}{h}
  \includegraphics[width=.60\textwidth]{shorsmap}
  \caption{The array analogy of Shor's first half in \Cref{fig:shorqafny}. }
\label{fig:shorsanalog}
\end{figure}


\subsection{Translation from \qafny to \sqir Full Rules}\label{appx:vqir-compilation}

\Cref{appxfig:compile-vqir} depicts compilation rules.
The first two rules in the first line show how a $\texttt{let}$-binding is handled for a $\cmode$ and $\mmode$ kind variable.
Similar to the type system, we assume that \texttt{let}-binding introduces new variables probably with proper variable renaming.
The last rule in the first line describes an oracle application compilation, which is handled by the \oqasm compiler \cite{oracleoopsla}. The \qafny type system ensures that the qubits mentioned in $\mu$ are the same as qubits in session $\kappa$, so that the translation does not rely on $\kappa$ itself.
\begin{figure}[t]
{\Small

  \begin{mathpar}

    \inferrule{x\not\in \dom{\Omega} \\\\ \Omega[x\mapsto \cmode];\gamma;n\vdash s[m/x] \to\textcolor{blue}{\epsilon}}
           {\Omega;\gamma;n\vdash \sexp{x}{m}{s} \to \textcolor{blue}{\epsilon}}

    \inferrule{x\not\in \dom{\Omega} \\\\ \Omega[x\mapsto \mmode];\gamma;n\vdash s[(r,n)/x] \to\textcolor{blue}{\epsilon}}
           {\Omega;\gamma;n\vdash \sexp{x}{(r,n)}{s} \to \textcolor{blue}{\epsilon}}

    \inferrule{\Omega;\gamma;n\vdash \mu \to \textcolor{blue}{\epsilon} }
         {\Omega;\gamma;n\vdash \ssassign{\kappa}{}{\mu} \to \textcolor{blue}{\epsilon}}
 
    \inferrule{\Omega;\gamma;n\vdash b@x[i] \to \textcolor{blue}{\epsilon}\\
                \Omega;\gamma;n\vdash s \to \textcolor{blue}{\epsilon'}}
        {\Omega;\gamma;n\vdash \sifq{b@x[i]}{s} \to \textcolor{blue}{\sseq{\epsilon}{\texttt{ctrl}(\gamma(x[i]),\epsilon')}}}    

    \inferrule{\forall t\in[i,j).\,\Omega;\gamma;n\vdash \sifq{b[t/x]}{s[t/x]} \to \textcolor{blue}{\epsilon_{t}}}
        {\Omega;\gamma;n\vdash \sqwhile{x}{i}{j}{b}{s} \to \textcolor{blue}{\epsilon_{i}\,;...;\,\epsilon_{j\,\sminus\,1}}}  
  
  \end{mathpar}
}
\caption{Select \qafny to \sqir translation rules (\sqir circuits are marked blue)}
\label{appxfig:compile-vqir}
\end{figure}


